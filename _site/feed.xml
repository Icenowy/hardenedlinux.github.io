<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hardened GNU/Linux</title>
    <description>We are a group of free software enthusiasts, anarchists, cyber security researchers. 0ld sch00l long lives!!!
</description>
    <link>http://www.hardenedlinux.org/</link>
    <atom:link href="http://www.hardenedlinux.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 25 May 2015 14:56:58 +0800</pubDate>
    <lastBuildDate>Mon, 25 May 2015 14:56:58 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>PAGEEXEC的最早设计文档</title>
        <description>&lt;p&gt;Shawn：事实证明对性能影响很大，在之后的一些年里SEGEXEC用的更多，但
PAGEXEC让我们明白了初始的PaX feature到底是什么样的一个东东，不了解你
hacking领域历史的人永远无法去解决未来所要面对的问题，过去的15年里系统安
全经历了有趣的进化，关于进攻阵营介绍已经够多了（或许我们未来可以花些时
间聊聊），Aleph One也是名利双收。&lt;/p&gt;

&lt;p&gt;在防御的这一方，虽然PaX/Grsecurity对整个内核安全造成了巨大影响和冲击，
但The PaX team和Spender并未从中赚取哪怕1美分，而PAGEEXEC是
PaX/Grsecurity的alpha，我们不知道哪个feature会成为omega，但至少我们可以
借助PaX team的这篇文档对那个0ld g00d h4ck1ng days的年代有一些回顾。&lt;/p&gt;

&lt;h2 id=&quot;pageexechttpspaxgrsecuritynetdocspageexecoldtxt&quot;&gt;原文：&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.old.txt&quot;&gt;PAGEEXEC的最早设计文档&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;作者：The PaX team&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck&lt;/p&gt;

&lt;h3 id=&quot;abstract&quot;&gt;0. abstract&lt;/h3&gt;

&lt;p&gt;这篇文档讨论在IA-32处理器上实现不可执行（比如用户态代码所在的页只有读和
写的权限，但没有执行的权限）。因为处理器的原生页表和页目录不提供这样的
功能，所以这个实现有一定的难度。&lt;/p&gt;

&lt;p&gt;这个设计的想法是源于Kevin Lawton, Ramon van Handler和其他为plex86项目贡
献的人（看footnote 1）。&lt;/p&gt;

&lt;h3 id=&quot;intro&quot;&gt;1. intro&lt;/h3&gt;

&lt;p&gt;联网计算机的安全是最近每天都在讨论的议题。很多安全问题都是归结于一种基
于缓冲区利用的特的攻击技术，这类攻击都依赖于应用程序内部不恰当的数据处
理（看footnote 2）。&lt;/p&gt;

&lt;p&gt;大部分的攻击都是程序错误的数据处理导致执行攻击者的代码（就如程序自己执
行一样），这个影响允许攻击者去执行任何的操作而应用程序也会允许攻击者的
代码这么干。&lt;/p&gt;

&lt;p&gt;这是一个非常糟糕的事情，必须得想法修复掉。最直观的解决这个问题的方法当
然是修复现有的漏洞和保证新的代码在设计和实现时的质量（完美程序员模式）。&lt;/p&gt;

&lt;p&gt;但是人类总是会犯错，现在已经有几种对抗缓冲区溢出的方法，其中的一个就是
不可执行的页，这也是能根除原本应该是数据的页但用于执行的可能性（在一个
典型的缓冲区溢出的场景是数组保存在栈上）。&lt;/p&gt;

&lt;p&gt;有一些处理器支持给页标注为只能执行（vs. 数据读/写），但不幸的是IA-32类
的CPU不支持（Intel, Amd, etc)。&lt;/p&gt;

&lt;h3 id=&quot;the-idea&quot;&gt;2. the idea&lt;/h3&gt;

&lt;p&gt;1999年7月，plex86(后来的freemware)项目在一些来自互联网用户的帮助下开始
了针对IA-32处理器的一个特性（一些人认为是一个bug，尽管后来成为了拯救者）
进行了测试。&lt;/p&gt;

&lt;p&gt;这个特性依赖于Pentium处理器和更新的处理器的TLB（translation lookaside
buffer)是区分数据TLB（DTLB）和指令TLB（ITLB）的。TLBs作为PTEs(page
table entries，页表条目)的缓存，因此保存着user/supervisor(用户和管理员）
受访问的权限。通常情况下ITLB和DTLB条目（对于特定的线性/物理地址对）是加
载于同样的PTE，因此他们包含了一致的状态。&lt;/p&gt;

&lt;p&gt;plex86社区想要测试是否能让DTLB和ITLB的条目产生不一样的状态。他们当时有
兴趣看看在一个只允许代码执行的页上去做数据读写造成的页错误( page
fault, PF），因为允许类似自修改代码的检测对于虚拟化来说是重要的特性。&lt;/p&gt;

&lt;p&gt;然后这个机制可以导致另一种不一致的状态，即只允许读和写，而代码执行是被
禁止的；这正是对抗基于缓冲区溢出所需要的。&lt;/p&gt;

&lt;p&gt;他们的测试被证实是成功的（看footnote 3)&lt;/p&gt;

&lt;h3 id=&quot;the-theory&quot;&gt;3. the theory&lt;/h3&gt;

&lt;p&gt;PTE和TLB管理是内核内存管理子系统的功能，因此实现不可执行的页必须是改动
内核本身，这个章节我们将会描述在实现过程中哪些地方需要处理，之后会谈谈
在Windows NT/2000和Linux内核里的实现，因为Windows的源代码和底层系统相关
的一些文档并不能以公开的渠道获取，我们将会涉足一些逆向工程（希望微软会
把这个安全机制在未来的NT系统中加入）。&lt;/p&gt;

&lt;p&gt;一个不可执行的页需要在TLB里创建和维护一组特殊的状态，这些状态信息用于表
示对于特定的页的TLB信息，看下图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                          ITLB

                           - | S | U
                          -----------
                 D     - | 0 | 1 | 2 |
                 T        -----------
                 L     S | 3 | 4 | 5 |
                 B        -----------
                       U | 6 | 7 | 8 |
                          -----------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TLB要么没有任何对应线性/物理地址对( - )的条目，要么有一个条目指向用户
（U）或者管理员（S）的访问权限。&lt;/p&gt;

&lt;p&gt;注意，通常情况下状态5和7从来不会发生（他们都是不一致的状态）。&lt;/p&gt;

&lt;p&gt;任何页的初始状态都是0，当处理器访问了页（指令fetch或者数据读写操作），
状态就开始有所变化。一般的可能的状态转换如下面所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 -&amp;gt; 1 (ITLB fill, PTE specifies Supervisor rights)
    0 -&amp;gt; 2 (ITLB fill, PTE specifies User rights)
    3 -&amp;gt; 4 (ITLB fill, PTE specifies Supervisor rights)
    3 -&amp;gt; 5 (ITLB fill, PTE specifies User rights)      
    6 -&amp;gt; 7 (ITLB fill, PTE specifies Supervisor rights)
    6 -&amp;gt; 8 (ITLB fill, PTE specifies User rights)      

    0 -&amp;gt; 3 (DTLB fill, PTE specifies Supervisor rights)
    0 -&amp;gt; 6 (DTLB fill, PTE specifies User rights)      
    1 -&amp;gt; 4 (DTLB fill, PTE specifies Supervisor rights)
    1 -&amp;gt; 7 (DTLB fill, PTE specifies User rights)      
    2 -&amp;gt; 5 (DTLB fill, PTE specifies Supervisor rights)
    2 -&amp;gt; 8 (DTLB fill, PTE specifies User rights) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一半可能的状态转换刚好和上面的状态转换方向相反（用于表示冲刷到期的
TLB条目）以及下面两个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    4 -&amp;gt; 0 (显式调用TLB flush指令)
    8 -&amp;gt; 0 (显式调用TLB flush指令)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读到这里，仔细的读者可能已经发现没有在S和U状态之间的直接转换。因为在这
里我们不讨论直接通过MSRs的方式操作TLB页表的方式。如果内核直接操作TLB条
目，那么额外的状态转换必须考虑。&lt;/p&gt;

&lt;p&gt;有了以上的信息，我们可以定义什么“好”和“坏”的状态以及状态转换了，之后可
以决定怎么进入和维护仅仅是“好”的状态。&lt;/p&gt;

&lt;p&gt;不违反在一个页上“不可执行”的特性时被称为“好”状态，“好”状态如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0,3,6: 由于没有ITLB条目所以无法取指令，所以没有代码可以在这种页
           上执行

    1,4,7: 用户态代码（一个执行线程的CPL（当前权限）为3）可以在这些
           页上导致一个页错误，所以内核可以做相应的动作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，初始状态（0）是一个“好”状态，我们仅会去保证不会有转换到“坏”状态。&lt;/p&gt;

&lt;p&gt;一个好的状态转换是转换到一个”好“状态（坏的状态转换是导致最终转换到了”坏
“状态），我们的目标是维护一个”好“状态，因此我们想当”坏“状态转换发生时收
到通知（然后去阻止它）。但并没有办法通过一个TLB条目的冲刷收到通知（过期
冲刷或者显式调用），我们从现在开始不应该考虑这个问题（除了5 -&amp;gt; 2和8 -&amp;gt;
2，这2个状态初始时就已经是“坏”状态了“，这种情况尽量在设计时考虑不要让它
们发生，请看关于paranoid security的footnote）。&lt;/p&gt;

&lt;p&gt;“好”的状态转换如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 -&amp;gt; 1
    3 -&amp;gt; 4
    6 -&amp;gt; 7
    0 -&amp;gt; 3
    0 -&amp;gt; 6
    1 -&amp;gt; 4
    1 -&amp;gt; 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“坏”的状态转换如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 -&amp;gt; 2
    3 -&amp;gt; 5
    6 -&amp;gt; 8
    2 -&amp;gt; 5
    2 -&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，最后2个“坏”状态转换的初始状态就是“坏”的（这种情况在我们的设计里要
避免）。如何对待它们取决于我们对安全有多被害妄想症结（我们有多信任我们
的实现，内核完整性等问题）。在接下来的讨论中，我们不会把这2种状态转换纳
入考虑（因此也不会有针对的防御机制），我们仅会指出它们会影响设计和实现
的哪些方面。这些问题让我们本质上要做一个性能 vs. (被害妄想症)安全的决定。&lt;/p&gt;

&lt;p&gt;现在我们可以把注意力转移到如何检测在用户空间里“坏”状态转换的尝试上，如
果我们可以让转换时触发处理器中断的正常流程，那应该可以做到检测。达到这
个目的唯一的途径是在相应的转换时触发一个页错误，每个可能的”坏“状态转换
大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 0 -&amp;gt; 2, 3 -&amp;gt; 5, 6 -&amp;gt; 8:

    - 一个PTE（页目录条目）的P( Present)位不设置（PTE.NP）。当任何
      代码导致ITLB从这个PTE读取时，我们能获得一个页错误。

    - 一个PTE的U/S（User/Supervisor）位设置到S（PTE.S）。当用户态代
      码导致ITLB从这个PTE读取时，我们能获取到一个页错误。

 2 -&amp;gt; 5, 2 -&amp;gt; 8:

    - 一个PTE（页目录条目）的P( Present)位不设置（PTE.NP）。当任何
      代码导致ITLB从这个PTE读取时，我们能获得一个页错误。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不论我们如何选择，我们都必须先了解对于不同方式实现”好“状态转换的不同影
响：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; - PTE.NP方式的状态转换会导致正常情况下不会造成的额外页错误

 - PTE.S会消除掉一些转换，也会造成额外的页错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这个表描述了当被内核态和用户态代码触发时上述选择可以造成的“好”转换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; trans | choice: PTE.NP          PTE.S
 ition | mode:   S     U         S     U
 -------------------------------------------------------------------
 0 -&amp;gt; 1:         PF    PF        none  PF (transformed from 0 -&amp;gt; 2)
 3 -&amp;gt; 4:         PF    PF        none  PF (transformed from 3 -&amp;gt; 5)
 6 -&amp;gt; 7:         PF    PF        none  PF (transformed from 6 -&amp;gt; 8)
 0 -&amp;gt; 3:         PF    PF        none  PF
 0 -&amp;gt; 6:         PF    PF        n/a   n/a (transformed into 0 -&amp;gt; 3)
 1 -&amp;gt; 4:         PF    n/a       none  n/a
 1 -&amp;gt; 7:         PF    n/a       none  n/a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里我们可以看出的确得在性能与安全之间做出决定，如果我们继续选择被害
妄想症模式，唯一的选择就是PTE.NP，不幸的是这个模式产生更多的页错误会对
系统的性能有很大的影响，还必须对现有的内核页管理系统进行大规模修改，特
别是针对基于页文件（swap）的虚拟内存管理的部分，而U/S位通常没有太大性能
影响。&lt;/p&gt;

&lt;p&gt;总结一下这个章节，陈述一个不可执行的页必须实现哪些部分：&lt;/p&gt;

&lt;h3 id=&quot;usspte&quot;&gt;3.1. 创建U/S位为S的PTE页。&lt;/h3&gt;

&lt;h3 id=&quot;ptepteuss&quot;&gt;3.2. 在PTE的生命周期里，保持PTE的U/S位始终设置为S。&lt;/h3&gt;

&lt;h3 id=&quot;section&quot;&gt;3.3. 扩展页错误处理到&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; - 当“坏”转换发生时处理页错误（记得有些转换是被某些转换给重定向的）：


    0 -&amp;gt; 1:
    3 -&amp;gt; 4:
    6 -&amp;gt; 7:

           终止尝试在被标为不可执行的页上执行代码的用户线程，具体的
           操作可以更细粒度的给人类用户或者其他程序选择的提示，当然
           不排除有人乐意在繁忙的web服务器上点击yes/no按钮... ;-)


  - 当“好”转换发生时处理页错误：

    0 -&amp;gt; 3:
            
	正常数据访问页时从状态转换0 -&amp;gt; 6（栈操作，堆访问等）重
	定向过来的，这必须得保证处理的速度足够快：

            - 为这个页冲刷TLBs（x86指令：invlpg）
            - 从PTE.S改变为PTE.U
            - 访问页，以用户权限加载DTLB
            - 把PTE.U变回PTE.S（按照3.2的要求）
	- 恢复用户线程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得区分不同的原因导致的页错误，处理程序必须判断错误代码（去判断是否是
PTE.S或者其他原因导致的页错误）然后对比错误地址（寄存器CR2）和导致错误
的指令地址（存储在栈上的EIP），然后判断是否一致（“坏”转换尝试）或者不一
致。&lt;/p&gt;

&lt;p&gt;最后一个需要讨论的问题是关于多CPU环境。幸运的是，并没有太多需要担心的。
只有一种情况多CPU可能是个问题，就是当页错误处理程序尝试以用户权限加载
DTLB的同一时间段里违反了3.2，如果PTEs是在多CPU间共享的话，我们必须阻止
其他CPU加载ITLB，这里也有关于带来的性能问题考量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    - 对于正在处理错误的CPU我们可以切换到一个新的私有页目录和修改或
      者使用一个私有的PTE拷贝。这个方法会冲刷整个TLBs（劣势），虽然为全局页
      保持了条目，但并不需要在CPU间进行任何同步操作（优势）。

    - 拖延其他CPU的执行，修改或者使用共享的PTE。这个方法除了对于刻
      意操作的DTLB条目外不影响TLBs（优势），但需要CPU间的同步操作
      （劣势）。

    - 不拖延其他CPU去修改或者使用共享的PTE。这种方法除了对于可以操
      作的DTLB条目外不影响TLBs（优势），也不要求CPU间进行同步（优
      势），但留了很小的时间窗口可能让PTE加载到不应该加载的处理器的
      ITLB里（劣势）。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;linux-implementation&quot;&gt;4. Linux implementation&lt;/h3&gt;

&lt;p&gt;虚拟内存管理系统的核心数据结构vm_area_struct在include/linux/mm.h里声明
的，这个数据结构描述了一个任务的连续（在线性地址空间）页共享的相同的属
性（可读，可写，可执行，共享/私有，etc）。我们对两个字段有兴趣：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   vm_flags:
   决定了页能做的事情范围的flags（读/写/执行），修改后对于当前
   任务是否保持私有拷贝（COW激活），或者与其他任务共享到相同的
   范围（共享内存），有一些flags对于我们的讨论并不重要（看
   footnote 4）

   vm_page_prot:
   这些flags是在物理内存被分配到给定的内存范围时实际放进PTE的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从vm_flags到vm_page_prot的转换是被一个被称为protection_map[]的简单数组
描述，定义在mm/mmap.c文件里。这是与硬件架构无关的分页子系统，但实际的符
号是使用来自特定架构的包含文件，IA-32是在include/asm-i386/pgtable.h。&lt;/p&gt;

&lt;p&gt;在我们的实现里，我们有意打破现有的代码风格去重命名一些常量（有时是增
加），所以程序员在未来应该显式的声明是否他们需要可执行的内存。&lt;/p&gt;

&lt;p&gt;下一步是去扩展页错误处理程序，首先是特定架构本身，对于IA-32是存放在
arch/i386/mm/fault.c里的do_page_fault()。&lt;/p&gt;

&lt;p&gt;页错误可能因为不同的原因被触发，为了加速处理过程IA-32处理器放了一个特殊
格式的错误代码在栈上作为附加的异常处理程序的栈帧。页错误处理程序跟处理
器相关的部分根据错误代码和内存范围包含的错误地址的vm_flags来做出决定(当
然不是所有页错误都发生在映射的内存里，但我们暂时不考虑它们）。&lt;/p&gt;

&lt;p&gt;错误代码如下（也请查阅footnote 5）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 名字           可能性
 -------------------------------------------------------------------------
 原因           PTE不是present(PTE.NP)

                用户空间代码违反权限(PTE.S)

                尝试写入只读或者COW页(PTE.R)


 读或写尝试     错误的指令获取尝试R/W
 
 管理员或者     错误指令在用户模式执行(CPL=3)，或者在管理员模式(CPL=0)
 用户模式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们得决定针对不同原因产生错误时处理程序的操作，之后得定义我们的
方案（PTE.S）怎么去修改他们，下面的表里包含了所有老的和新的处理程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; legend:

   vm_flags: flags in vm_flags (仅4个最低有效位)

   pte:      针对特定vm_flags的pte里的flags (仅3个最低有效位)

   err:      pte flags的可能错误代码 (仅3个最低有效位)

   action:   sigbus (np): signal task （访问非Present的页)
             sigbus (w):  signal task （尝试写只读的页）
             cow:         处理 copy-on-write
             emu:         模拟PTE.U以及允许访问
             emu/kill:    检查访问是否合法(emu)或者不合法(kill)


 vm_flags   原始pte错误动作         PaX的pte错误动作
 ------------------------------------------------------
 0000       000 xx0 sigbus (np)     000 xx0 sigbus (np)
 0001       101 x11 sigbus (w)      001 011 sigbus (w)
                                        111 sigbus (w)
                                        101 emu/kill
 0010       101 x11 cow             001 011 cow
                                        111 cow
                                        101 emu/kill
                                    011 111 emu
 0011       101 x11 cow             001 011 cow
                                        111 cow
                                        101 emu/kill
                                    011 111 emu

 0100       101 x11 sigbus (w)      101 011 sigbus (w)
 0101       101 x11 sigbus (w)      101 011 sigbus (w)
 0110       101 x11 cow             101 011 cow
 0111       101 x11 cow             101 011 cow

 1000       000 xx0 sigbus (np)     000 xx0 sigbus (np)
 1001       101 x11 sigbus (w)      001 011 sigbus (w)
                                        111 sigbus (w)
                                        101 emu/kill
 1010       111 cannot fault        011 101 emu/kill
                                        111 emu
 1011       111 cannot fault        011 101 emu/kill
                                        111 emu

 1100       101 x11 sigbus (w)      101 011 sigbus (w)
 1101       101 x11 sigbus (w)      101 011 sigbus (w)
 1110       111 cannot fault        111 cannot fault
 1111       111 cannot fault        111 cannot fault
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的表显示了相同的信息（为PaX），但对于程序员更适合的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; vm_flags| err
         | 000 001 010 011 100 101 110 111
 ---------------------------------------------
 0000      sig     sig     sig     sig
 0001                  sig     e/k     sig
 0010                  cow     e/k     cow/emu
 0011                  cow     e/k     cow/emu

 0100                  sig
 0101                  sig
 0110                  cow
 0111                  cow

 1000      sig     sig     sig     sig
 1001                  sig     e/k     sig
 1010                          e/k     emu
 1011                          e/k     emu

 1100                  sig
 1101                  sig
 1110
 1111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们创建了新的页错误处理程序，让我们多少讨论一下Linux内核相关的问题，
比如PaX的副作用。首先是当前的可执行的栈（也可以说是被滥用的…）就这样
被干掉了，我们的改动影响了信号处理（比如return-from-sig-handling代码被
放到了用户空间的栈）和trampolines(GCC扩展）。&lt;/p&gt;

&lt;p&gt;在当前的实现中我们决定只解决之前（可能会有更严重的问题）问题，处理
trampolines还是留给别人吧（在注重安全的环境中这种代码本来就不应该允许执
行）。&lt;/p&gt;

&lt;p&gt;幸运的是，这些放在用户模式栈的代码都是固定的长度/内容，因此我们所需要做
的只是检查代码pattern。一个需要注意的地方是：这些检测尝试去的内存可能在
页上而非错误的指令，我们用了一个小技巧在代码拷贝到用户态栈（读者被邀请
去做做数学）之前去改变对齐。&lt;/p&gt;

&lt;p&gt;考虑到还有正常的可执行栈的使用，内核可以分配一个（可执行）页然后映射到
每个任务的地址空间（“浪费”了4kb的内存）。&lt;/p&gt;

&lt;p&gt;第2个问题（不算针对Linux）是PaX的性能损耗，我们有坏消息和好消息。其中能
猜到的是，越大和越高效的TLB会产生越少的页错误。在标准的IA-32处理器上，
TLBs看起来拥有64到256个条目（看footnote 6），他们至少4-way associative
（Shawn：暂时翻译成4组相连，如果每组是8个条目那4组是32个条目），或者全
部关联。这个意思是针对在至少1个TLB条目上的不同的页最多访问256次后必须让
其过期（打开了一扇通向潜在页错误的未来之门）。下面一个简单的测试程序能
看出PaX的性能影响。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #include &amp;lt;stdio.h&amp;gt;

  int main()
  {
    char* buf;
    int i,j;

    buf = (char*)malloc(4096*257);
    for (j=0; j&amp;lt;100000; j++) {
      for (i=0; i&amp;lt;257; i++) {
        buf[i*4096] = 'a';
      }
    }
    return (0);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在标准的Linux内核2.2.14上和打了PaX补丁的2.2.17内核上的测试结果如下：&lt;/p&gt;

&lt;p&gt;6.20user 0.01system 0:06.21elapsed 100%CPU (0avgtext+0avgdata 0maxresident)k
   0inputs+0outputs (77major+266minor)pagefaults 0swaps&lt;/p&gt;

&lt;p&gt;6.15user 29.74system 0:35.89elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
   0inputs+0outputs (77major+266minor)pagefaults 0swaps&lt;/p&gt;

&lt;p&gt;意料之中，PaX内核的额外页错误处理导致了一些性能下降（没有免费午餐）。好
消息是在真实世界的测试中性能损耗通常小于5–8%…..&lt;/p&gt;

&lt;h3 id=&quot;windows-nt2000-implementation&quot;&gt;5. Windows NT/2000 implementation&lt;/h3&gt;

&lt;p&gt;不辛的是，由于缺乏时间/心情/etc，我们不打算为Windows实现，有兴趣的读者
可以联系Ice (white_ice@usa.net)或者fOSSiL &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&quot;&gt;&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&lt;/a&gt;去做一些逆向
工程，设计和实现的工作&lt;/p&gt;

&lt;p&gt;给那些打算单干的路标：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   - 逆向工程工具IDA (the Interactive DisAssembler,
     http://www.datarescue.com). the next source of information is
     the symbol files available at the Customer Support
     Diagnostics page
     (http://www.microsoft.com/WINDOWS2000/downloads/ Other
     Downloads section has the link)

   - the following symbols are probably worth a look:
       - _MmUserProtectionToMask1, _MmUserProtectionToMask2
       - @KiFlushSingleTb@8, @KeFlushSingleTb@20
       - @MiDetermineUserGlobalPteMask@4, @MiMakeProtectionMask@4
       - _MmProtectToPteMask, _MmProtectToValue

   - 实现应该在让内核模式驱动（KMD）在启动时加载，大概也必须做一些
     运行时的内核patching，这些工作难度不低（想想SMP的场景）

   - 注意PAE和PSE

   - 别信任你最喜欢的调试器，它仅能提供很少关于Windows NT/2000的分
     析子系统的信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;final-words&quot;&gt;6. final words&lt;/h3&gt;

&lt;p&gt;(to protect the innocent, names have been changed ;-)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;innocent&amp;gt; well, buffer overflows will be gone in 2-3 years 
   &amp;lt;innocent&amp;gt; hopefully
   &amp;lt;pax&amp;gt; sooner ;-)
   &amp;lt;pax&amp;gt; a month at most
   &amp;lt;innocent&amp;gt; what ??
   &amp;lt;innocent&amp;gt; you bullshitting me now or what ?
   &amp;lt;pax&amp;gt; just sit back and watch ;-)
   &amp;lt;pax&amp;gt; sure i do
   &amp;lt;pax&amp;gt; no ;-)
   &amp;lt;innocent&amp;gt; ok
   &amp;lt;innocent&amp;gt; phew
   &amp;lt;innocent&amp;gt; argh
   &amp;lt;innocent&amp;gt; you got me there for a second ;&amp;gt;
   &amp;lt;pax&amp;gt; heh, why?
   &amp;lt;innocent&amp;gt; coz I was in panic that there was something big coming up
   &amp;lt;innocent&amp;gt; it is already getting harder to find overflows now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;on a more serious note, the PaX team would like to thank acpizer, dezzy
   and halvar for their support, help and testing the Linux version.&lt;/p&gt;

&lt;h3 id=&quot;contact-information&quot;&gt;7. contact information&lt;/h3&gt;

&lt;p&gt;The PaX Team &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#112;&amp;#097;&amp;#103;&amp;#101;&amp;#101;&amp;#120;&amp;#101;&amp;#099;&amp;#064;&amp;#102;&amp;#114;&amp;#101;&amp;#101;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#104;&amp;#117;&quot;&gt;&amp;#112;&amp;#097;&amp;#103;&amp;#101;&amp;#101;&amp;#120;&amp;#101;&amp;#099;&amp;#064;&amp;#102;&amp;#114;&amp;#101;&amp;#101;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#104;&amp;#117;&lt;/a&gt;
   PGP key fingerprint: D2E0 B4B6 16A3 B532 20B8  969B 956D 2366 39F0 81BF&lt;/p&gt;

&lt;p&gt;for participation in the Windows NT/2000 research/implementation contact
   Ice &amp;lt;white_ice@usa.net&amp;gt; or fOSSiL &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&quot;&gt;&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;history&quot;&gt;8. history&lt;/h3&gt;

&lt;p&gt;2000.08.06 初始文档
   2000.10.01 PaX的Linux实现诞生
   2000.10.22 修复一些小错误
   2000.10.27 增加COW场景
   2000.10.28 完成Linux实现的描述
   2000.11.05 修复处理VM_IO，IPC共享内存变成NOEXEC等问题
   2000.11.16 修复pd/pt访问竞争条件问题&lt;/p&gt;

&lt;h3 id=&quot;footnotes&quot;&gt;9. footnotes&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.plex86.org/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;depending on where this data originates from (local or a remote host),
we talk about local and remote exploits, although the underlying problem
remains the same.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.plex86.org/news.phtml?id=3&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;we found it somewhat unfortunate how VM_STACK_FLAGS was defined. first,
its definition was not based on the existing symbolic constants but had
the raw hexadecimal value (so a simple ‘grep’ for ‘interesting’ symbols
would miss it whereas it is of crucial importance for determining the
protection flags for stack pages). second, its value included execution
permission which is of course exactly what we want to avoid. our patch
fixes at least the latter issue (holy lazyness ;-).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;for PPro+ processors when CR4.PSE is enabled the error code may also
indicate whether the fault occured due to some reserved bits in the
paging structures not being 0. in Linux (2.2.x at least) this can never
happen, hence its omission.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;see links at http://www.sandpile.org/ in the ‘impl’ section&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 25 May 2015 10:08:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/05/25/pageexec-old.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/05/25/pageexec-old.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>PaX的技术考古之旅</title>
        <description>&lt;p&gt;h4rdenedzer0会尝试翻译PaX/Grsecurity的一些文档，请关注。&lt;/p&gt;

&lt;h2 id=&quot;grsecuritypax&quot;&gt;0. 什么是Grsecurity/PaX?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://pax.grsecurity.net/&quot;&gt;PaX&lt;/a&gt;是针对linux kernel的一个加固版本的补丁，它让linux内核的内存页受限于
最小权限原则，是这个星球上有史以来最极端和最优秀的防御系统级别0day的方
案，第1版的设计和实现诞生于2000年，那可是一个没有
ASLR/RELRO/NX/CANARY/FORITY/PIE都没有的年代，这些今天意义上的现代
mitigation技术不管是linux/windows/macosx都多少抄袭和模仿了PaX的设计和实
现，但有很多朋友会问：既然这东东这么厉害，为什么不在linux mainline里？
PaX没有进入Linux内核upstream的原因不止一个，甚至有时候都不是纯粹技术本身的问题：&lt;/p&gt;

&lt;p&gt;1) &lt;a href=&quot;http://unix.stackexchange.com/questions/59020/why-are-the-grsecurity-patches-not-included-in-the-vanilla-kernel&quot;&gt;PaX Team并不在意PaX是否进入Linux主干代码&lt;/a&gt;，但多年来有很多关心Linux内核安全的人不断的尝试把PaX的代码分拆成小的patch提交给Linux内核社区。&lt;/p&gt;

&lt;p&gt;2) Linux内核社区认为PaX的代码难以维护，而Linux内核社区更喜欢花时间在性能和新功能上，而非安全。&lt;/p&gt;

&lt;p&gt;3) Linux内核社区和Linux基金会受到由各个大厂商的影响，大厂商对于安全的要求取决于他们的客户的需求，如果很多真相不曝光大厂商是不会在意安全性的&lt;/p&gt;

&lt;p&gt;4) 商业公司在意他们的主要利润来源，比如Five-eyes国家（美国，英国，加拿大，澳大利亚和新西兰）的政府项目都会统一采购SELinux的项目，所以大厂商都会花费精力去满足这一需求，这也是SELinux虽然备受争议但是一直有厂商和NSA持续投入的原因。&lt;/p&gt;

&lt;p&gt;SELinux也是一个著名的开源MAC（强制访问控制）实现，是由NSA(美国国家安全局）于1990年代末发起的项目，于2000年以GPL自由软件许可证开放源代码，2003年&lt;a href=&quot;http://www.internetnews.com/ent-news/article.php/3317331&quot;&gt;合并到Linux内核中&lt;/a&gt;，过去10年中关于&lt;a href=&quot;https://www.schneier.com/blog/archives/2008/04/nsas_linux.html&quot;&gt;是否NSA在其中放后门的争论&lt;/a&gt;没有停过，一些人认为应该信任SELinux，因为它是以GPL自由软件许可证公开的源代码，也有人认为它是NSA参与过的项目，所以不应该信任。2013年Snowden曝光棱镜后更多的人极度的不信任NSA，认为&lt;a href=&quot;http://www.zerohedge.com/news/2013-07-09/nsa-has-inserted-its-code-android-os-bugging-three-quarters-all-smartphones&quot;&gt;NSA有对Android代码植入后门的前科&lt;/a&gt;，所以应该&lt;a href=&quot;http://www.eteknix.com/nsa-has-code-running-in-the-linux-kernel-and-android/&quot;&gt;怀疑所有NSA积极参与的项目包括SELinux&lt;/a&gt;。目前MAC的开源实现里，SELinux主要由RedHat/CentOS/Fedora社区维护，Apparmor主要由OpenSuSE/Ubuntu社区维护，关于SELinux是否应该使用是一个长久争论的话题，个人认为这取决于你的威胁建模，如果你是Five-Eyes阵营你当然应该使用SELinux，如果你是其他阵营比如德国或者中国，或许你应该考虑其他选择。&lt;/p&gt;

&lt;p&gt;针对Linux内核的MAC实现都是基于LSM( Linux Security Module)去实现的，LSM利用了一堆CAPABILITY的
机制提供了一些限制用户态程序访问控制的接口，SELinux和Apparmor都是基于LSM开发的，注意LSM并不是一个传统意义上的linux kernel module，至少在2个地方不同于普通module:&lt;/p&gt;

&lt;p&gt;1) 必须在bootloader启动内核时启动，不能在内核加载完后启动。&lt;/p&gt;

&lt;p&gt;2) 不能同时启动2个LSM的实现。&lt;/p&gt;

&lt;p&gt;但PaX Team是一群old school security hackers，他们认为LSM一方面打破了
“security as a whole”的哲学，另外一方面对于&lt;a href=&quot;https://grsecurity.net/compare.php&quot;&gt;内核漏洞没有防御能力&lt;/a&gt;，虽然在早年Linux内核社区以及大厂商不管是刻意还是无意的想要掩盖这一点，但&lt;a href=&quot;https://grsecurity.net/spender_summit.pdf&quot;&gt;时间&lt;/a&gt;证明PaX Team是正确的。其
实当人们谈到Gnu/Linux安全性比windows/OSX更好时，其实未必，至少linux内核社区并没有把安全性放在首位，Linus Torvalds从来都不是太care安全问题，不是吗？&lt;/p&gt;

&lt;p&gt;PaX从一开始就主要关注如何防御和检测memory corruption，PaX由PaX team维护，Grsecurity主要包括了RBAC（基于角色的访问控制）和一系列对PaX的改进，Grsecurity主要由Spender维护，最近几年这2组Patch都合并到了一起发布，所以我们都称这组补丁为Grsecurity/PaX或者PaX/Grsecurity。&lt;/p&gt;

&lt;h2 id=&quot;pax&quot;&gt;0.1 PaX的诞生&lt;/h2&gt;

&lt;p&gt;这个section描述的是这篇“过时”的&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.old.txt&quot;&gt;论文&lt;/a&gt;，这是PaX的Genesis，1999年7月的
&lt;a href=&quot;http://www.plex86.org/&quot;&gt;plex86社区&lt;/a&gt;(old school虚拟化社区之一)打算验证一个概念，当时Pentium(包
括P6family)处理器新增加了一个功能，就是CPU把TLB区分为DTLB(数据TLB)和
ITLB(指令TLB)，TLB主要是PTE( page table entries)的缓存，因此存放着
user/kernel spaces的访问权限信息，在正常的情况下，ITLB和DTLB entries从
相同的PTE里读出相同的状态，但如果状态有所改变的话也就意味着可以把数据读
写和代码执行分开，如果这个POC能成功也就意味着可以对抗缓冲区溢出的最佳方
案，这个成为了今天的NX=&amp;gt;要么可读写要么可执行。&lt;/p&gt;

&lt;p&gt;在PaX的初始设计文档中经过了对PTE中的2个flags的分析：&lt;/p&gt;

&lt;p&gt;Present位，如果设置1，指向的page(或者page table)是存在于内存里的；如果
设置为0，page没有在内存里和保存的入口位(bits)可能会被OS用作其他用途。如
果page table或者page directory的入口需要执行地址转换(线性地址到物理地
址)时Present位被清0，会产生一个异常:page fault异常。&lt;/p&gt;

&lt;p&gt;U/S位，权限管理，U-&amp;gt;user space, S-&amp;gt;kernel space&lt;/p&gt;

&lt;p&gt;关于ITLB和DTLB的状态之间的转换这篇paper里已经有非常详细的描述，这里就不
多阐述了，linux内核的实现问题，虚拟内存管理的主要结构是vm_area_struct，
主要是描述连续的线性地址的一些属性包括
READ/WRITE/EXECUTE/SHARED/PRIVATE等，里面有2个结构体成员需要关注：
vm_flags，vm_page_prot。PaX在出现page fault的时候多增加了一些动作包括模
拟page table entry里的可访问U标志位和在模拟PTE中检查访问权限。&lt;/p&gt;

&lt;p&gt;PaX的第一版的副作用也不小，
1，用户态可执行的栈是不可能的
2，性能损耗在5%–8%&lt;/p&gt;

&lt;p&gt;old school社区plex86在1999年的一个概念验证建立了后来NX(目前是硬件支持)
的基础，个人觉得最有意思的地方是防御缓冲区溢出利用最早的策略是基于对于
TLB的研究导致的，这听起来怎么那么像emerging property, Out of C0ntrol?
KK? Ring the bell?&lt;/p&gt;

&lt;h2 id=&quot;pax-1&quot;&gt;1. 2003年PaX谈”未来”&lt;/h2&gt;

&lt;p&gt;PaX在2003年的时候开始思考如何在[未来&lt;a href=&quot;https://pax.grsecurity.net/docs/pax-future.txt&quot;&gt;(2003以后)在根本上根除漏洞利用&lt;/a&gt;，PaX
对于W-xor-X的实现非常奏效，具体在&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.old.txt&quot;&gt;PAGEEXEC原始设计文档&lt;/a&gt;里已经有所描述。&lt;/p&gt;

&lt;p&gt;从defensive的平面来看，当时GNU/Linux平台主要依赖PaX的patch来进行加固(包
括ASLR)，ASLR和NX进入linux内核mainstream是后来的事情，OpenBSD和Windows
XP SP2和OSX 10.5也加入了NX，但都是抄袭PaX的设计(或许也包括实现)，&lt;/p&gt;

&lt;p&gt;从offensive的平面来看，2003年的背景是stack-based overflow和string
format vuln已经泛滥，但ROP还没有大规模的流行，但old school社区对于ROP的
研究已经有相当的研究，包括Solar Designer在1997年发到&lt;a href=&quot;http://seclists.org/bugtraq/1997/Aug/63&quot;&gt;bugtraq里的讨论&lt;/a&gt;，之后更精彩的paper是在2001年&lt;a href=&quot;http://phrack.org/archives/issues/58/4.txt&quot;&gt;Phrack Issue 58的那篇论文”The advanced return-into-lib(c) exploits: PaX case study”&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意：2003年时SK的那篇Borrowed code chunks还没有发布。&lt;/p&gt;

&lt;p&gt;2003年，PaX team认为会导致漏洞利用的bug给予了攻击者(区分攻击者和黑客是
不同的term)在3个不同层面上访问被攻击的进程：&lt;/p&gt;

&lt;p&gt;(1) 执行任意代码
(2) 执行现有代码但打破了原有的执行顺序
(3) 原有的执行顺序执行现有代码，但加载任意数据&lt;/p&gt;

&lt;p&gt;NOEXEC( Non-executable pages)和MPROTECT(mmap/mprotect)能防御(1)，但有一
种情况是例外：如果攻击者能创建和写入一个文件然后mmap()到被攻击的进程空
间里，这样可以执行任意的代码。&lt;/p&gt;

&lt;p&gt;ASLR在一定程度上降低了(1),(2),(3)的风险，但如果内核有信息泄露的bug例外。
PaX team在当时就认为把内核当成可信计算( Trusted Computing)的基础是一件
可笑的事情，因为内核跟用户空间一样容易遭受各种攻击。所以他们认为”未来”
需要做一些事情(注：这些事情今天都已经搞定）：&lt;/p&gt;

&lt;p&gt;(a) 尝试处理(1)不能处理的那个例外情况
(b) 实现所有可能在内核态自己的防御机制
(c) 为(2)实现确定性( deterministic)防护，可能也为(3)实现类似的机制
(d) 为(2)实现概率行( probalilistic)防护以实现阻止信息泄露&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;处理(a)更好的解决方案是使用访问控制和可信路径执行来限制，Grsecurity今
天就是这么做的
—————————————————&lt;/p&gt;

&lt;p&gt;之后这篇文档里详细的罗列了针对(a)(b)(c)(d)需要去实现的加固方案。在&lt;a href=&quot;https://raw.githubusercontent.com/citypw/security-regression-testing-for-suse/master/other/vulns_hardening_assessment.log&quot;&gt;这里已经能看出一些后来出现的mitigation技术&lt;/a&gt;：Stack Canary, RELRO,
pointer constant/encryption?&lt;/p&gt;

&lt;h2 id=&quot;paxvma-mirroring&quot;&gt;1.1 2003年PaX里vma mirroring的设计&lt;/h2&gt;

&lt;p&gt;在2003年的晚些时候PaX实现了&lt;a href=&quot;https://pax.grsecurity.net/docs/vmmirror.txt&quot;&gt;虚拟内存空间的镜像( vma mirroring)&lt;/a&gt;，vma
mirroring的目的是为了在一组物理页上做特殊文件隐射时有2个不同的线性地址，
这2个地址即使在swap-out/swap-in或者COW后依然是不会改变的。这样做的目的
为了满足几种场景：&lt;/p&gt;

&lt;p&gt;1，把可执行的区域在使用SEGMEXEC隐射进入代码段。在32-bit的linux内核里的
4GB地址空间是其中3GB给用户空间，1GB给内核空间，而vma mirroring把用户空
间的3GB划分成了2个1.5GB分别是给代码段和数据段，在可执行区域里包含的数据
的部分(常量字符串，函数指针表等)都会mirroring到数据段里。&lt;/p&gt;

&lt;p&gt;2，实现可执行区域的地址随机化( RANDEXEC)。&lt;/p&gt;

&lt;p&gt;3，这个引出了第3种情况，就是SEGMEXEC和RANDEXEC同时激活，个人觉得这个的
效果应该和PIE＋ASLR的效果类似，不同的不是整个elf binary的代码段随机化，
而是在mirroring时对代码段和数据段进行随机化。&lt;/p&gt;

&lt;p&gt;之后这篇文章开始聊到实现的问题，对于一个普通的用户态binary在执行后，内
核得做一系列的工作，fs/binfmt_elf.c里的load_elf_binary()负责进程地址空
间的一些基本的映射包括stack,动态连接器和binary本身。而文件的映射是通过
elf_map()调用do_mmap()完成的。用户态binary的第1条指令从ld.so或者binary
自己fetch到后会raise一个page fault，linux内核内存管理是按需分配内存的，
所以在binary刚执行时是没有建立有效的物理映射的。x86架构的page fault
handler在arch/i386/mm/fault.c文件里的do_page_fault()去找到vma结构体，
VMA里包含了物理页的数据(ELF文件里的代码段, etc)。&lt;/p&gt;

&lt;p&gt;当时的PaX的做法大致是这样的，vma mirror是根据已经内存映射mmap()后的地址，
用户态通过mmap()是无法直接去做vma mirror请求的，所有的mmap()请求多会经
过include/linux/mm.h的do_map()，PaX扩展( SEGMEXEC)也是在这个地方处理，
原始内核通过调用do_mmap_pgoff()来调用do_mmap()，PaX在这里为了确保
SEGMEXEC能知道来自用户态和内核态的原生文件映射请求所以略过
do_mmap_pgoff()而直接调用do_mmap()，而vma mirror请求使用一些特殊参数传
递给do_mmap_pgoff():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'file'    必须是NULL，因为mirror会引用相同文件的vma作为镜像
'addr'    正常使用
'len'    必须是0
‘prot'    正常使用
'flags'    正常使用，除了一种情况：指定MAP_MIRROR和只能指定private映射
'pgoff'    指定vma的线性起始地址作为镜像
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章给出了一个例子：&lt;/p&gt;

&lt;p&gt;# cp /bin/cat /tmp/
# /tmp/cat /proc/self/maps&lt;/p&gt;

&lt;p&gt;激活PaX的2个功能: SEGMEXEC, MPROTECT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1] 08048000-0804a000 R-Xp 00000000 00:0b 1109       /tmp/cat
[2] 0804a000-0804b000 RW-p 00002000 00:0b 1109       /tmp/cat
[3] 0804b000-0804d000 RW-p 00000000 00:00 0
[4] 20000000-20015000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
[5] 20015000-20016000 RW-p 00014000 03:07 110818     /lib/ld-2.2.5.so
[6] 2001e000-20143000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
[7] 20143000-20149000 RW-p 00125000 03:07 106687     /lib/libc-2.2.5.so
[8] 20149000-2014d000 RW-p 00000000 00:00 0
[9] 5fffe000-60000000 RW-p fffff000 00:00 0    [10] 68048000-6804a000 R-Xp 00000000 00:0b 1109       /tmp/cat    [11] 80000000-80015000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so    [12] 8001e000-80143000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个binary是一个动态连接的可执行程序，所以在执行时会映射其他的库文件。&lt;/p&gt;

&lt;p&gt;[1] 这个binary文件/tmp/cat的第1个PT-LOAD段映射为有读和执行的权限，包含
了可执行的代码和只读的初始化后的数据。因为是可执行的所以被[10]镜像。&lt;/p&gt;

&lt;p&gt;[2] 第2个PT_LOAD段，映射为读写权限，包含了可写的数据(所有初始化和没有初
始化的)&lt;/p&gt;

&lt;p&gt;[3] brk()管理的堆，在运行时会根据malloc()/free()来调整大小&lt;/p&gt;

&lt;p&gt;[4][5] 动态连接器&lt;/p&gt;

&lt;p&gt;[6][7] C库 ，[4][6]被映射到了[11][12]，因为他们是可执行的。&lt;/p&gt;

&lt;p&gt;[8] 一个针对C库的初始化数据的匿名映射&lt;/p&gt;

&lt;p&gt;[9] 一个匿名映射包含了stack。我们能观察到这个地址在用户空间的数据部分的
结束地址，开启SEGMEXEC后是TASK_SIZE/2。&lt;/p&gt;

&lt;p&gt;[10][11][12] 分别映射可执行镜像[1][4][6]。&lt;/p&gt;

&lt;p&gt;激活PaX的3个功能的情况: SEGMEXEC，RANDEXEC，MPROTECT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1] 08048000-0804a000 R-Xp 00000000 00:0b 1109       /tmp/cat
[2] 0804a000-0804b000 RW-p 00002000 00:0b 1109       /tmp/cat
    0804b000-0804d000 RW-p 00000000 00:00 0
[3] 20000000-20002000 ++-p 00000000 00:00 0
[4] 20002000-20003000 RW-p 00002000 00:0b 1109       /tmp/cat
    20003000-20018000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
    20018000-20019000 RW-p 00014000 03:07 110818     /lib/ld-2.2.5.so
    20021000-20146000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
    20146000-2014c000 RW-p 00125000 03:07 106687     /lib/libc-2.2.5.so
    2014c000-20150000 RW-p 00000000 00:00 0
[5] 5fffe000-60000000 RW-p 00000000 00:00 0
[6] 80000000-80002000 R-Xp 00000000 00:0b 1109       /tmp/cat
    80003000-80018000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
    80021000-80146000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RANDEXEC有一些改变，[3]成了第1个可执行的PT_LOAD段的匿名映射，[4]成为第
2个PT_LOAD段的的mirror，[2]和[4]有相同的页偏移值，文档说[1]被[6]给
mirror后是超出了TASK/SIZE/2的范围，但个人觉得这个地方是代码段的区域所以
必然是在1.5G以上(如果数据段在0-1.5G的话)，还有就是在RANDUSTACK开启后由
于stack的第1部分不能关闭随机化，所以多比第1个例子多占了1个page，这个怎
么得出的呢？靠我真不知道，可能是fffff000 xor ffffffff = fff来的？&lt;/p&gt;

&lt;p&gt;激活PaX的3个功能的情况: PAGEEXEC, RANDEXEC, MPROTECT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1] 08048000-0804a000 R--p 00000000 00:0b 1109       /tmp/cat
[2] 0804a000-0804b000 RW-p 00002000 00:0b 1109       /tmp/cat
    0804b000-0804d000 RW-p 00000000 00:00 0
[3] 40000000-40002000 R-Xp 00000000 00:0b 1109       /tmp/cat
[4] 40002000-40003000 RW-p 00002000 00:0b 1109       /tmp/cat
    40003000-40018000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
    40018000-40019000 RW-p 00014000 03:07 110818     /lib/ld-2.2.5.so
    40021000-40146000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
    40146000-4014c000 RW-p 00125000 03:07 106687     /lib/libc-2.2.5.so
    4014c000-40150000 RW-p 00000000 00:00 0
    bfffe000-c0000000 RW-p fffff000 00:00 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的这种情况是vma mirroring所产生最简单的内存layout，只有binary本生被
镜像了，[1]被[3]，[2]被[4]镜像了。注意[1]没有R-X权限了，在PAGEEXEC下只
有R–。&lt;/p&gt;

&lt;p&gt;虽然现在的PaX实现肯定不是这个设计的版本，但读读原始的paper会有一些意想
不到的收获，也算技术进化考古的过程了;-)&lt;/p&gt;

&lt;h2 id=&quot;ld-sch00l&quot;&gt;2. 0ld sch00l黑客的出埃及记&lt;/h2&gt;

&lt;p&gt;Grsecurity/PaX目前&lt;a href=&quot;https://grsecurity.net/the_case_for_grsecurity.pdf&quot;&gt;应用广泛&lt;/a&gt;，特别是具有高安全性的环境，Gnu/Linux发行版里
Gentoo提供PaX作为加固选项，最近半年Debian社区发起的对抗大规模监控的加固
项目&lt;a href=&quot;http://mempo.org/&quot;&gt;Mempo&lt;/a&gt;在内核中也使用了Grsecurity/PaX。&lt;/p&gt;

&lt;p&gt;这篇文章仅仅是在学习PaX的3篇paper里的记录，PaX的思路的确非常的震撼，那
都是10多年前的设计和实现，在这个一天云计算一天雾计算的年代，虽然关注本
质的黑客越来越少，但地下精神并未死去，PaX Team就是一个活生生的例证，相
反，不少old school黑客都坚信其实old school的数量并没有减少，至少我个人
相信这是真的…Phrack没死，Grsecurity/PaX没死，DNFWAH也没死，希望更多的
黑客分享自己的hacking之旅。&lt;/p&gt;

&lt;p&gt;Phrack is not dead, Grsecurity/PaX is not dead, DNFWAH is not dead,
The Underground spirit is not dead…..If they were, that’d be on us!&lt;/p&gt;

&lt;p&gt;=——————————————————————–=&lt;/p&gt;

&lt;p&gt;To one of the most respected old school communities:
Grsecurity/PaX. We/I salute you!!!&lt;/p&gt;

</description>
        <pubDate>Sun, 24 May 2015 03:20:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/05/24/archeological_hacking_on_pax.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/05/24/archeological_hacking_on_pax.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>Brad Spengler( Pax Team/grsecurity)访谈, 2010年1月1日</title>
        <description>&lt;h2 id=&quot;brad-spengler-pax-teamgrsecurity-interview-jan-1-2010httpsslo-techcomclanki10001en&quot;&gt;原文：&lt;a href=&quot;https://slo-tech.com/clanki/10001en&quot;&gt;Brad Spengler (PaX Team/grsecurity) interview， Jan 1 2010&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&quot;shawn-the-r0ck-may-16-2015&quot;&gt;译者：Shawn the R0ck, May 16 2015&lt;/h2&gt;

&lt;p&gt;Shawn：PaX/Grsecurity是在OS安全上的一个开创性的贡献，没有
PaX/Grsecurity的GNU/Linux的安全性只能防御脚本小子，过去的14年里
Pax/Grsecurity为Linux内核做出了巨大出贡献的贡献，但到今天Linux内核社区
都不愿意承认，这可能的确是受商业厂商控制了主流媒体的后果，&lt;a href=&quot;https://raw.githubusercontent.com/citypw/DNFWAH/master/3/d3_0x06_hacker_nsa_free-software.txt&quot;&gt;在后棱镜时代&lt;/a&gt;，
这种现象有极端的阴谋论甚至认为NSA也是推手，当然这也并非完全没有道理，毕
竟&lt;a href=&quot;http://www.solidot.org/story?sid=43483&quot;&gt;SELinux项目&lt;/a&gt;早已成为Five-Eyes国家的标配。&lt;/p&gt;

&lt;p&gt;我尝试翻译这篇5年前的访谈是为了让更多的人了解到历史，因为反观今天的
Linux内核社区对于安全的态度相比5年前可能是更糟糕，&lt;a href=&quot;http://www.solidot.org/story?sid=42174&quot;&gt;offset2lib&lt;/a&gt;的远程利用
方式轻松绕过了GNU/Linux厂商们宣称的完美防御，相信就算是智商只有85的人也
能明白“抗爆破”机制只能抗不到1秒的时间是在扯淡;-) 即使offset2lib所带来的
风险巨大，Linux内核社区的态度也是极度傲慢，他们也不认为这个
PaX/Grsecurity在2001年就已经加固的攻击平面而他们在2015年还存在有什么问
题，而BadiRET漏洞里我们更能清晰的看到SMEP虽然被绕过，但SMAP依然有效，而这两个Intel CPU的特性也是源于2007年PaX/Grsecurity的其中一个特性UDEREF的启发，自从有了OS的攻防历史，就有了PaX/Grsecurity，如果Linux内核社区继续傲慢自大，最终的受害者是企业用户和个人用户。&lt;/p&gt;

&lt;p&gt;在Anarchist看来，这样的Linux内核社区正是数字军火商，斯拉夫兵工厂甚至
NSA所喜欢的。&lt;/p&gt;

&lt;h2 id=&quot;brad-spengler-pax-teamgrsecurity&quot;&gt;标题：Brad Spengler( PaX Team/grsecurity)访谈&lt;/h2&gt;

&lt;h3 id=&quot;slo-techspenderspengler--brad&quot;&gt;Slo-Tech：向我们的读者介绍一下你自己（工作，教育背景以及兴趣），也请你解释一下你的真名是Spender还是Spengler;-) 请问Brad是否是任何黑帽组织的成员？&lt;/h3&gt;

&lt;p&gt;Brad Spengler: Brad Spengler(不是Brad Spender)，虽然相似的名字并非偶然，
我改了改姓氏作为别名。我毕业于Bucknell大学，获得了计算机与工程（混杂了
计算机科学和电子硬件的课程）学士学位和一个应用数学的学士学位。数学/物理
学/经济学/哲学都是我最有兴趣的课程。我在学习操作系统课程之前就已经有4年
的学习Linux内核和编程的经历，所以计算机科学课程并不是那么的有趣。我从来
没有参加过任何黑帽组织。自从高中开始我总是对创造有趣的事物有兴趣。&lt;/p&gt;

&lt;p&gt;………………….(未翻译）&lt;/p&gt;

&lt;h3 id=&quot;slo-techpaxgrsecurity&quot;&gt;Slo-Tech：你能用简单描述一下什么是PaX和GRSecurity以及有多少人参与这些项目吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：&lt;a href=&quot;http://en.wikipedia.org/wiki/PaX&quot;&gt;PaX&lt;/a&gt;是一头戏剧性的改变了整个安全的形态的野兽，而且对未来
安全的影响甚至会更多。PaX专注于一次性的解决一堆各种类型的漏洞利用，有一
些工作还没有完成，但希望能有所改变，也希望8年后（Shawn：现在已经是5年后
了，愚蠢的大众还是宁愿相信商业厂商和NSA;-)）所有人都能明白PaX的前瞻性。
PaX完全专注于内存的漏洞利用，&lt;a href=&quot;http://www.grsecurity.net/&quot;&gt;grsecurity&lt;/a&gt;则增加了主机层的防御和基于现有的
PaX特性进行了一系列的改进，包括抗爆破，ASLR的抗信息泄漏，不允许文件系统
级别的任意代码执行等。Grsecurity包括了很多简单的自动化特性，比如RBAC系
统可以通过学习模式（你可以选择基于进程/用户或者整个系统）来自动化创建规
则，这些规则都是人类可读的纯文本格式（Shawn：SELinux是使用难以审计的二
进制的格式。），报错信息有助于根据攻击类型来制定相应的规则。&lt;/p&gt;

&lt;p&gt;PaX项目的参与人数是未知的！因此PaX Team至少有一个人:) 对于grsecurity这
边就我一个人。偶尔我也收到一些patch提交（比如来自Zbyniu Krzystolik），
赞助者和朋友有时也会告诉我他们想要加入一些新功能。&lt;/p&gt;

&lt;h3 id=&quot;slo-techpax-teamaslrlinuxlinuxpaxlinux&quot;&gt;Slo-Tech：只有一些人真正了解PaX Team开发了一些安全机制（比如ASLR）后来被用于Linux内核里，至少目前来看主要的Linux内核社区开发者和参与者并不打算承认PaX所带来的贡献，你认为这些机制对于Linux安全贡献最大的是什么。&lt;/h3&gt;

&lt;p&gt;Brad Spengler：好吧，对我而言很搞笑的是聪明的&lt;a href=&quot;http://en.wikipedia.org/wiki/Ingo_Molnar&quot;&gt;Ingo Molnar&lt;/a&gt;多年前对于
paxtest测试（包括检查不同区域的地址空间是否有能力执行任意代码）非常不爽，
因为第2组测试中mprotect用于标记一些内存为可写和可执行。Ingo称这个测试是
“破坏” – mprotect检测多少有些不公平（因为exec-shield完全失效了）。往前
看几年你会发现SELinux基本上把PaX的&lt;a href=&quot;http://pax.grsecurity.net/docs/mprotect.txt&quot;&gt;MPROTECT&lt;/a&gt;加入了它的规则语言。在
Windows的世界里你能找到所有人都在尝试日等价于Linux上的mprotect，glibc曾
经有一个make_stack_executable()函数也是ret2libc攻击的对象，Windows上也
有类似的函数。PaX team早在很多年前就认识到攻击者会找最薄弱的环节下手，
而这正是今天正在发生的事情。&lt;/p&gt;

&lt;p&gt;我不能说哪一个特性是对Linux安全贡献最大，因为这些特性都是叠加式的让
Linux内核更安全。同样，我认为下一个最具革命性的贡献将同样来自PaX team。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/pax_grsec_graph.jpg&quot; alt=&quot;PaX/Grsecurity&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;slo-techbradlinuxgnulinux&quot;&gt;Slo-Tech：看起来Brad和Linux内核开发者的“口水战”还在继续。什么是主要原因导致了这种不愉快的情况？你不认为其实GNU/Linux的终端用户才是遭受损失的吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我从来都没有发过一封邮件到LKML（Linux内核邮件列表），所
以我并没有参与任何”口水战“。PaX Team曾经发过邮件到LKML（比如让Linux内核
开发者承认他们的不愿意让外界关注的不披露漏洞的官方政策和安全漏洞信息模
糊化以及Linus为此多次赢得pwnie奖项的”a bug is bug”的安全哲学）。8个公开
的空指针引用的漏洞利用才被作为提权威胁来处理，在第一个公开漏洞利用后几
个月，mmap_min_addr被引入，但并不懂安全的Linux开发者开发的这个安全机制
导致了至少6个不同的绕过。Linux内核的ASLR有大量的弱点。SSP被攻破了多次最
终导致他们强行限制其工作范围。所有这些破事都来自于一个商业源头: Red
Hat – 对于公司重要的是为了赚钱你要说你有X特性（比如反病毒厂商会宣称：
“我们将会保护你不受病毒的侵害。”，至于这个特性是否有用并不是公司关心的
（但有些人会去验证厂商的宣传 — 安全研究人员或者黑帽）。&lt;/p&gt;

&lt;h3 id=&quot;slo-techlinuxlinuxsdlsdl&quot;&gt;Slo-Tech：谁是你尊重的Linux内核开发者？或者说，你不觉得在安全问题上Linux需要重新组织一下关于处理安全事件和安全开发的流程（很多回归测试代码）。比如微软的SDL…你觉得SDL怎么样？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：基于有很多公司和个人用户使用微软的产品，我很尊重微软对安
全的态度。Windows大量的二进制软件的生态系统的基础上，去实现安全功能的同
时还要保证应用程序的兼容性。这些工程的真实难度很容易被误认为是简单的事
情。&lt;/p&gt;

&lt;p&gt;Linux确实需要一些集中的领导者或者组织来处理安全。Linux开发者就算知道他
们在修复安全漏洞，但他们也不会通知任何人（包括厂商）。选择性的通知厂商
特定的安全问题，而不通知小的厂商和GNU/Linux发行版社区。Upstream基本上让
厂商难受，每个厂商都必须去做重复的劳动，因为没有标准化流程。这个Linux内
核社区官方的”a bug is just a bug”政策是在伤害所有的GNU/Linux用户。一些
很优秀的加固补丁很少被内核社区接受，因为他们过度看中安全机制造成的性能
影响。&lt;/p&gt;

&lt;h3 id=&quot;slo-techlinux-torvaldslinuxlinux&quot;&gt;Slo-Tech：你觉得Linux Torvalds能胜任Linux的安全工作吗？我的意思是，他是一个优秀的开发者，但不是一个安全研究人员。那其他的著名Linux内核开发者呢？他们有相关的技能吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我不认为他能，他没有安全思维，也无法理解安全。我不确定为
什么很多人都感觉在安全问题上Linus是否参与很重要。一些开发者”理解”安全，
但通常他们只修复bug。Upstream通常不关心系统加固方面的内容。&lt;/p&gt;

&lt;h3 id=&quot;slo-techdave-aitellinux&quot;&gt;Slo-Tech：Dave Aitel写了一封名为“需要中心平台让多厂商合作来改善Linux内核安全问题“的邮件到他的邮件列表。你同意他的观点吗？这是正确的一步吗？你愿意为这样的中心平台工作吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：这点上&lt;a href=&quot;http://en.wikipedia.org/wiki/Dave_Aitel&quot;&gt;Dave&lt;/a&gt;是对的，但我并没看到这种事情在发生。最重要的是
Linus对安全的态度必须改变才行。只要一天他还是upstream内核的看门人，不论
他的观点对还是错都会直接影响Linux的安全。同时，PaX team和我只能继续做我
们所一直在做的事情，改善Linux的安全只有一条路：单干。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/1.jpg&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;slo-techbugbug&quot;&gt;Slo-Tech：内核维护者悄然无声的修复一些内核bug是真的吗？”悄然无声的修复“是否意味着不正确的BUG分类和低估安全风险或者其他什么的？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：是的，他们已经承认这么干过。如果你回去读读LWN上我的文章
有一堆这样的例子。厂商在漏洞分类的问题上也非常糟糕 – 所有都是DoS。我认
为这个事情现在有所改善是因为他们被曝光和受到了公众的批评。部分的问题原
因是没有统一的bug管理造成了对于同一个bug有不同的解释。通常不同的厂商的
bug分析也不一样，而现在有一些厂商发的安全公告并不是安全漏洞（比如NOMMU
是用于嵌入式系统，由于用户空间和内核空间没有隔离所以根本没有安全的设计，
但至少有2个CVE是有关这种系统的BUG）。这些事情可能会促使商业公司更愿意招
聘软件开发人员而不是安全人员来完成安全有关的工作。在每天都会报无数漏洞
的年代，集中处理平台和管理流程是能减轻很多工作量的。&lt;/p&gt;

&lt;h3 id=&quot;slo-techcrispin-cowanred-hat&quot;&gt;Slo-Tech：这是个恶心的问题，所以你不愿意的话你可以不回答。你愿意为微软（像Crispin Cowan）或者Red Hat工作吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：在我大学的最后一年微软曾经邀请我去面试，但我拒绝了，因为
HR在弄丢了我的简历1年后他们才想起我，而我那时已经失去去那里工作的兴趣。
为Red Hat工作？我确定你知道答案的;)&lt;/p&gt;

&lt;h3 id=&quot;slo-techwindows-vistalinuxwindowsbug&quot;&gt;Slo-Tech：众所周知你使用Windows Vista作为你的主要操作系统。这对于一个Linux内核安全研究者很奇怪。你为什么会这样选择呢？你尝试去找过Windows的bug吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：事实上我使用的是Windows 7 – Cheddar Bay的视频里应该是
RC版。因为Linux对我而言只是用来测试和改进grsecurity的。在高中和大学的时
候，我曾经使用GNU/Linux作为我的主要桌面系统，但现在GNU/Linux都是在虚拟
机里。以前的Linux的内核和用户态都简单很多。你知道那些众所周知的配置文件，
如果你修改他们，一些”智能”的进程会背着你把配置改回去，你不会因为想要不
同的默认配置而一定要修改SELinux规则。那是更多的是感受到GNU/Linux的自由
（Shawn：个人认为Brad说的问题应该是针对RedHat/CentOS/Fedora的，至少目前
来看Debian和Gentoo是享有高度的自由），而自由的缺失我认为是因为商业化造
成的。而游戏是我用Windows的主要原因。如果Pidgin通知我有一个新版本更新，
我只是下载一个去执行，而不需要强制的更新另外100+个包，那样会增加系统的
风险的。&lt;/p&gt;

&lt;h3 id=&quot;slo-techidefensezdiimmunity-rootcheddarbay-ingom0wnar-wundebar&quot;&gt;Slo-Tech：为什么你会公布漏洞利用而不是把它们卖给像iDefense，ZDI，Immunity这样的公司… 类似像本地root提权漏洞像cheddarbay, ingom0wnar, wundebar的市场价值是什么？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我不确定他们是否关心Linux的本地提权漏洞 – 首先，这些漏
洞已经在某些版本的Linux内核开发分支上被修复了。其次这些漏洞利用太容易编
写了。所以这些漏洞利用是用于提醒大家安全的重要性的（以前的一堆讨论无法
改善Linux内核社区的看法，但那8个漏洞利用做到了）。第1个成果是帮助到了人
们去理解风险的等级（有一些人联系我说那些漏洞利用帮助他们说服了他们的老
板更关注安全），因为Linux内核公开的漏洞利用并不是那么多，不是因为漏洞不
存在，而是因为黑帽们都用于自己的目的了。第2个成果是让所有主要的的
GNU/Linux厂商和发行版都把空指针引用的攻击平面给默认防御住了，SELinux的
漏洞也修复了，厂商更注重关于mmap_min_addr的问题。用户也注意到了这个特性
和开启它的重要性（Shawn: mmap_min_addr成为今天的标准安全基线），很多人
也都升级了Linux内核。这些都是好事。我想整件事情唯一的”创新”应该是
enlightenment框架了（下一个问题跟这个有关）。&lt;/p&gt;

&lt;h3 id=&quot;slo-techlinuxenglightenmentmetasploit&quot;&gt;Slo-Tech：最近你发布的针对Linux内核漏洞利用的框架叫Englightenment。你是否有计划继续改进这个框架并且希望它成为像Metasploit一样？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我一直在改进这个框架因为她让我以攻击者的方式来思考，这会
帮助我有多种思路去考虑针对特定攻击的防御机制（我最近在grsecurity里实现
的加固就是来源于此）。我也想让她变得尽量通用：她已经支持x86和x8\6_64平台
的所有2.4和2.6内核上关闭所有LSM模块。我最近也增加了Xen特性的支持，这个
特性会更恰当的让hyppercall去修改内核代码。我也在考虑关于
namespace/container(Shawn：就是lxc，以及后来docker用的底层模块），这些
都在TODO list上。&lt;a href=&quot;http://grsecurity.net/~spender/enlightenment.tgz&quot;&gt;Enlightenment&lt;/a&gt;会仅仅针对Linux内核漏洞利用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2.jpg&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;slo-techsusesebastian-krahmersgrakkyulinux&quot;&gt;Slo-Tech：大多数人都不把本地漏洞利用提权当成真正的威胁。我知道SuSE的Sebastian Krahmer写过相关的观点而我也同意他的观点，但事实上现在已经没有任何公开的远程漏洞利用了（Sgrakkyu是最后一名勇士），远程漏洞利用标准Linux内核真的已经是不可能还是在不远的将来会有所改变？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：远程内核漏洞利用非常困难，特别是针对运行PaX的内核和定制
过的内核。只要读读sgrakkyu/twiz在Phrack上的论文Attacking the core:
Kernel exploitation notes（Shawn：发表于Phrack Issue 64，2007年）就知道
所涉及的复杂性。他们都是热衷于挑战高难度的人，而其他大部分人会选择更简
单的方式，比如从Web进入然后使用本地内核提权漏洞的方式。如果系统运行了最
新的PaX，漏洞利用会变得极度困难，而不是更简单。我仍然能看到现有的威胁会
在可预见的未来存在下去，因为GNU/Linux发行版都把时间浪费在了不太可能出现
严重bug的SUID程序上，而新的内核提权漏洞几乎每个礼拜都在曝光。还有就是
web开发人员（ 那些编写的第三方代码运行在公共的服务器上，让远程用户能进
入”非信任的本地用户”）并没有变得更聪明。&lt;/p&gt;

&lt;h3 id=&quot;slo-techgnulinuxgnulinux&quot;&gt;Slo-Tech：GNU/Linux能依然被认为是安全的操作系统吗？你觉得政府或者其他对安全性要求高的基础架构应该使用GNU/Linux吗？&lt;/h3&gt;

&lt;p&gt;Brad Spengler：我希望在高安全要求的环境中有其他的系统可以使用(Shawn: 经
过加固的GNU/Linux或者Quebes OS/MirageOS?)。作为建议，一个安全的操作系统
可能会犯下非常不安全愚蠢的错误，而一个不安全的操作系统可以变得安全如果
不跑任何业务的话。&lt;/p&gt;

&lt;h3 id=&quot;slo-tech0-day&quot;&gt;Slo-Tech：你有任何私人的0-day漏洞利用在你的硬盘上吗;)&lt;/h3&gt;

&lt;p&gt;Brade Spenger：有的，&lt;a href=&quot;http://grsecurity.net/~spender/ext4_own.tgz&quot;&gt;ext4_own.tgz&lt;/a&gt;，它小于1000bytes。&lt;/p&gt;

&lt;p&gt;感谢Brad Spengler的访谈。&lt;/p&gt;
</description>
        <pubDate>Mon, 18 May 2015 00:49:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/05/18/grsec-interview.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/05/18/grsec-interview.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>PaX/Grsecurity for Nexus 7 2013</title>
        <description>&lt;h1 id=&quot;armv7-nexus7-grsechttpsgithubcomhardenedlinuxarmv7-nexus7-grsec&quot;&gt;&lt;a href=&quot;https://github.com/hardenedlinux/armv7-nexus7-grsec&quot;&gt;armv7-nexus7-grsec&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;PaX/Grsecurity patch for Nexus7, which the original version is 3.4
kernel based with a bunch of backport features and fixes. In some
particular cases, TrustZone is useless if the Android kernel were
compromised. I don't think we need another rootkit-friendly solution
like SELinux always does. Get rid of one entire class of vulns in
kernel would be an inevitable ways to make your device secure.&lt;/p&gt;

&lt;h1 id=&quot;credit-for-paxgrsecurity&quot;&gt;Credit for PaX/Grsecurity&lt;/h1&gt;

&lt;p&gt;PaX/Grsecurity is the most respected 0ld sch00l community and they
have been creating the best defense-in-depth kernel hardening solution
for 14 years. What PaX/Grsecurity brings to us, is amazing and
incridble work. Unfortunately, there are a lot of reasons that
PaX/Grsecurity don't get the credit what they deserves. Let me make
this short: To love those who are hatred by BIG BROTHER. That's the 
fuc*ing point.&lt;/p&gt;

&lt;h1 id=&quot;what-makes-us-ticks&quot;&gt;What makes us ticks&lt;/h1&gt;

&lt;p&gt;The age of &lt;a href=&quot;https://www.iotivity.org/&quot;&gt;IoT( Internet of things)&lt;/a&gt; is coming soon…There will be
huge numbers of devices running with diverse communication
protocols. For the simply classify, I'll only treat these devices as
two types: One with TCP/IP stack, or not. The one with TCP/IP stack
might have high probablity run with GNU/Linux. The one without TCP/IP
stack may be just a simple MCU stuff. The heterougenous network need
to be protected in various ways. These devices may be running on our
cars, refrigrator, or everywhere around us, which could be a risk to
our money-shitty property and even lives. That’s one of most important
reasons we need to &quot;H A R D E N E N I N G   E V E R Y T H I N G&quot; by free
software.&lt;/p&gt;

&lt;h3 id=&quot;paxgrsecurityhttpsgrsecuritynet&quot;&gt;&lt;a href=&quot;https://grsecurity.net/&quot;&gt;PaX/Grsecurity&lt;/a&gt;&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;NAME&lt;/th&gt;
      &lt;th&gt;DESCRIPTION&lt;/th&gt;
      &lt;th&gt;AUTHORS&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.txt&quot;&gt;PAGEEXEC&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;paging based non-executable pages&lt;/td&gt;
      &lt;td&gt;The PaX team, Mar 15 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/segmexec.txt&quot;&gt;SEGMEXEC&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;segmentation based non-executable pages&lt;/td&gt;
      &lt;td&gt;The PaX team, May 1 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/aslr.txt&quot;&gt;ASLR&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;address space layout randomization&lt;/td&gt;
      &lt;td&gt;The PaX team, Mar 15 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/mprotect.txt&quot;&gt;MPROTECT&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;mmap() and mprotect() restrictions&lt;/td&gt;
      &lt;td&gt;The PaX team, Nov 4 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/randustack.txt&quot;&gt;RANDUSTACK&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;userland stack randomization&lt;/td&gt;
      &lt;td&gt;The PaX team, Feb 12 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/randkstack.txt&quot;&gt;RANDKSTACK&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;kernel stack randomization&lt;/td&gt;
      &lt;td&gt;The PaX team, Jan 24 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/randmmap.txt&quot;&gt;RANDMMAP&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;mmap() randomization&lt;/td&gt;
      &lt;td&gt;The PaX team, Jan 24 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/randexec.txt&quot;&gt;RANDEXEC&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;non-relocatable executable file randomization&lt;/td&gt;
      &lt;td&gt;The PaX team, Feb 19 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/vmmirror.txt&quot;&gt;VMMIRROR&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;vma mirroring, the core of SEGMEXEC and RANDEXEC&lt;/td&gt;
      &lt;td&gt;The PaX team, Oct 6 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/emutramp.txt&quot;&gt;EMUTRAMP&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;gcc nested function and kernel sigreturn trampolines emulation&lt;/td&gt;
      &lt;td&gt;The PaX team, May 1 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://pax.grsecurity.net/docs/emusigrt.txt&quot;&gt;EMUSIGRT&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;automatic kernel sigreturn trampoline emulation&lt;/td&gt;
      &lt;td&gt;The PaX team, Feb 19 2003&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://grsecurity.net/~spender/uderef.txt&quot;&gt;UDEREF&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Prevent improper userland code/date access by the kernel&lt;/td&gt;
      &lt;td&gt;The PaX team, May 15 2007&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html&quot;&gt;UDEREF/amd64&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;paxgrsecurityhttpsforumsgrsecuritynetviewforumphpf7sid0c5e947c94d1dc30e3ea8a0daa6683bd-writings&quot;&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewforum.php?f=7&amp;amp;sid=0c5e947c94d1dc30e3ea8a0daa6683bd&quot;&gt;PaX/Grsecurity&lt;/a&gt; writings&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=2520&quot;&gt;intro&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Dec 30 2010&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=2521&quot;&gt;Assorted Notes on Defense and Exploitation&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Dec 31 2010&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=2522&quot;&gt;False Boundaries and Arbitrary Code Execution&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Jan 2 2011&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=2551&quot;&gt;The Dangers of Copy and Paste&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Feb 1 2011&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=2574&quot;&gt;The Unseen Benefits of a Security Mindset&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Mar 12 2011&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=2596&quot;&gt;Much Ado About Nothing: A Response in Text and Code&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Apr 16 2011&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=2939&quot;&gt;Recent Advances: How We Learn From Exploits&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Feb 15 2012&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=3046&quot;&gt;Supervisor Mode Access Prevention&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Sep 7 2012&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=3043&quot;&gt;Inside the Size Overflow Plugin&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Aug 28 2012&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=3292&quot;&gt;Recent ARM Security Improvements&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Feb 18 2013&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=3367&quot;&gt;KASLR: An Exercise in Cargo Cult Security&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Mar 20 2013&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=7&amp;amp;t=4173&quot;&gt;Guest Blog by Rodrigo Branco: PAX_REFCOUNT Documentation&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;Mar 21 2015&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;gcc-plugins&quot;&gt;&lt;em&gt;GCC plugins&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://lwn.net/Articles/461696/&quot;&gt;Better kernels with GCC plugins&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;history&quot;&gt;History&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;2005&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://lwn.net/Articles/118251/&quot;&gt;grsecurity 2.1.0 and kernel vulnerabilities&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://lkml.org/lkml/2005/2/8/93&quot;&gt;the “Turing Attack” (was: Sabotaged PaXtest)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;2009&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://lwn.net/Articles/313621/&quot;&gt;The future for grsecurity&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2010&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://slo-tech.com/clanki/10001en&quot;&gt;Brad Spengler (PaX Team/grsecurity) interview&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;2011&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://lwn.net/Articles/415653/&quot;&gt;proactive defense: using read-only memory&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;2012&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://unix.stackexchange.com/questions/59020/why-are-the-grsecurity-patches-not-included-in-the-vanilla-kernel&quot;&gt;Why are the grsecurity patches not included in the Vanilla Kernel?&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;2013&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://lwn.net/Articles/538600/&quot;&gt;How The Linux Foundation and Fedora are Addressing Workstation Security&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;2014&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=3&amp;amp;t=3906&amp;amp;p=13803&amp;amp;hilit=ANDROID#p13803&quot;&gt;Some Links for Newbies on Grsecurity, and the Big Picture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.openwall.com/lists/oss-security/2014/12/06/14&quot;&gt;How GNU/Linux distros deal with offset2lib attack?&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;recent-isues&quot;&gt;Recent isues&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=1&amp;amp;t=4143&quot;&gt;locking bug( it may also an issue in upstream)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://forums.grsecurity.net/viewtopic.php?f=3&amp;amp;t=3958&quot;&gt;RPI not booting due to randomize layout plugin&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 12 May 2015 06:49:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/jekyll/update/2015/05/12/Grsecurity-for-Nexus-7-2013.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/jekyll/update/2015/05/12/Grsecurity-for-Nexus-7-2013.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
